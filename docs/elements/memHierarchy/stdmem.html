<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-elements/memHierarchy/stdmem" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">StandardMem Interface | The Structural Simulation Toolkit</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://sstsimulator.github.io/sst-docs/img/sst-logo-small.png"><meta data-rh="true" name="twitter:image" content="https://sstsimulator.github.io/sst-docs/img/sst-logo-small.png"><meta data-rh="true" property="og:url" content="https://sstsimulator.github.io/sst-docs/docs/elements/memHierarchy/stdmem"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="StandardMem Interface | The Structural Simulation Toolkit"><meta data-rh="true" name="description" content="MemHierarchy implements the SST::StandardMem API for integration with a processor model. The picture below shows how components like processors, accelerators, etc. interface with memHierarchy using StandardMem. The processor or other &quot;endpoint&quot; exchanges StandardMem requests with memHierarchy&#x27;s StandardMem API implementation, standardInterface. The implementation handles translating requests into MemHierarchy&#x27;s internal event types. To use the interface, a processor should load the memHierarchy.standardInterface subcomponent and connect the subcomponent&#x27;s port to a memHierarchy component as shown."><meta data-rh="true" property="og:description" content="MemHierarchy implements the SST::StandardMem API for integration with a processor model. The picture below shows how components like processors, accelerators, etc. interface with memHierarchy using StandardMem. The processor or other &quot;endpoint&quot; exchanges StandardMem requests with memHierarchy&#x27;s StandardMem API implementation, standardInterface. The implementation handles translating requests into MemHierarchy&#x27;s internal event types. To use the interface, a processor should load the memHierarchy.standardInterface subcomponent and connect the subcomponent&#x27;s port to a memHierarchy component as shown."><link data-rh="true" rel="icon" href="/sst-docs/img/sst-logo-small.png"><link data-rh="true" rel="canonical" href="https://sstsimulator.github.io/sst-docs/docs/elements/memHierarchy/stdmem"><link data-rh="true" rel="alternate" href="https://sstsimulator.github.io/sst-docs/docs/elements/memHierarchy/stdmem" hreflang="en"><link data-rh="true" rel="alternate" href="https://sstsimulator.github.io/sst-docs/docs/elements/memHierarchy/stdmem" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://B6IFEXV9WE-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/sst-docs/blog/rss.xml" title="The Structural Simulation Toolkit RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/sst-docs/blog/atom.xml" title="The Structural Simulation Toolkit Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="The Structural Simulation Toolkit" href="/sst-docs/opensearch.xml">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous">
<script src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/sst-docs/assets/css/styles.8a84b442.css">
<script src="/sst-docs/assets/js/runtime~main.7c9ae6a7.js" defer="defer"></script>
<script src="/sst-docs/assets/js/main.db31649e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbar--primary"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/sst-docs/"><div class="navbar__logo"><img src="/sst-docs/img/sst-logo-small.png" alt="" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/sst-docs/img/sst-logo-small.png" alt="" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">The Structural Simulation Toolkit</b></a><a class="navbar__item navbar__link" sidebarid="guides" href="/sst-docs/docs/guides/start">Guides</a><a class="navbar__item navbar__link" sidebarid="core" href="/sst-docs/docs/core/component/introduction">SST-Core API</a><a class="navbar__item navbar__link" sidebarid="config" href="/sst-docs/docs/config">Configuration</a><a class="navbar__item navbar__link" sidebarid="elements" href="/sst-docs/docs/elements/intro">Elements</a><a class="navbar__item navbar__link" sidebarid="tools" href="/sst-docs/docs/tools/commandLine/sst-info">Tools</a><a class="navbar__item navbar__link" sidebarid="community" href="/sst-docs/docs/community">Community</a><a href="https://sstsimulator.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main Site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/intro">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/ariel/intro">ariel</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/sst-docs/docs/elements/balar/intro">balar</a><button aria-label="Expand sidebar category &#x27;balar&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/cacheTracer/intro">cacheTracer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/cassini/intro">cassini</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/cramsim/intro">cramSim</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/sst-docs/docs/elements/ember/intro">ember</a><button aria-label="Expand sidebar category &#x27;ember&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/firefly/intro">firefly</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/gensa/intro">gensa</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/golem/intro">golem</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/hermes/intro">hermes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/iris/intro">iris</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/juno/intro">juno</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/kingsley/intro">kingsley</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/llyr/intro">llyr</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/macro/intro">macro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/maskmpi/intro">mask-mpi</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/sst-docs/docs/elements/memHierarchy/intro">memHierarchy</a><button aria-label="Collapse sidebar category &#x27;memHierarchy&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/sst-docs/docs/elements/memHierarchy/stdmem">StandardMem Interface</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/sst-docs/docs/elements/memHierarchy/connecting">Connecting to MemHierarchy</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/sst-docs/docs/elements/memHierarchy/cache">Caches</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/mercury/intro">mercury</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/merlin/intro">merlin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/messier/intro">messier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/miranda/intro">miranda</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/mmu/intro">mmu</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/opal/intro">opal</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/osseous/intro">osseous</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/prospero/intro">prospero</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/rdmaNic/intro">rdmaNic</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/samba/intro">samba</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/serrano/intro">serrano</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/shogun/intro">shogun</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/simpleElementExample/intro">simpleElementExample</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/simpleExternalElement/intro">simpleExternalElement</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/simpleSimulation/intro">simpleSimulation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/thornhill/intro">thornhill</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/vanadis/intro">vanadis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/vaultsim/intro">vaultsim</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/sst-docs/docs/elements/zodiac/intro">zodiac</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/sst-docs/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/sst-docs/docs/elements/memHierarchy/intro"><span itemprop="name">memHierarchy</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">StandardMem Interface</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>StandardMem Interface</h1></header><p>MemHierarchy implements the <a href="/sst-docs/docs/core/iface/StandardMem/class"><code>SST::Interfaces::StandardMem</code></a> API for integration with a processor model. The picture below shows how components like processors, accelerators, etc. interface with memHierarchy using <code>StandardMem</code>. The processor or other &quot;endpoint&quot; exchanges StandardMem requests with memHierarchy&#x27;s StandardMem API implementation, <code>standardInterface</code>. The implementation handles translating requests into MemHierarchy&#x27;s internal event types. To use the interface, a processor should load the <code>memHierarchy.standardInterface</code> subcomponent and connect the subcomponent&#x27;s port to a memHierarchy component as shown.</p>
<p><img decoding="async" loading="lazy" alt="Interfacing with MemHierarchy&amp;#39;s SST::StandardMem implementation" src="/sst-docs/assets/images/stdmem_structure-89de4aa621dca1299338478de7b1efca.png" width="1104" height="802" class="img_ev3q"></p>
<p>Even though the picture shows the processor connected to a cache, the same <code>memHierarchy.standardInterface</code> subcomponent also supports connections to scratchpads, memory controllers, and networks with memHierarchy components on them. This page discusses how memHierarchy implements the interface and assumptions it makes, as well as specifics about how particular memHierarchy components treat various request types. The <code>memHierarchy.standardInterface</code> subcomponent is implemented by the <code>MemHierarchy::StandardInterface</code> class.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="requests-versus-events">Requests versus Events<a href="#requests-versus-events" class="hash-link" aria-label="Direct link to Requests versus Events" title="Direct link to Requests versus Events">​</a></h2>
<p>In SST terminology, an <em>Event</em> is an object that can be passed over an SST <em>Link</em>. Events inherit from <code>SST::Event</code>. <code>StandardMem::Request</code> and derivatives such as <code>StandardMem::Read</code> or <code>StandardMem::WriteResp</code> are not events in this sense and are exchanged with the StandardMem interface using function calls. MemHierarchy then translates these <em>requests</em> to events in the SST sense. To avoid confusion between (SST) events and requests, this guide refers to <code>StandardMem::Request</code> derivatives as &#x27;requests&#x27;, whether the object represent an actual request (e.g., read) or a response. For requests that get translated into a MemHierarchy event, it also gives the event type.
This diagram shows the inheritance structure of MemHierarchy events, with base classes to the left.</p>
<p><img decoding="async" loading="lazy" alt="MemHierarchy event inheritance" src="/sst-docs/assets/images/memh_events-fa1306d4e2d6602e8d3362e5267cb6e3.png" width="2690" height="591" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="requests-sent-to-memhierarchys-standardinterface">Requests Sent to MemHierarchy&#x27;s StandardInterface<a href="#requests-sent-to-memhierarchys-standardinterface" class="hash-link" aria-label="Direct link to Requests Sent to MemHierarchy&#x27;s StandardInterface" title="Direct link to Requests Sent to MemHierarchy&#x27;s StandardInterface">​</a></h2>
<p>These are requests that are sent from a processor or other endpoint into memHierarchy.
Interpret &quot;request sent to memHierarchy&quot; to mean a request sent to <code>MemHierarchy::StandardInterface</code> using StandardMem&#x27;s <code>void send(Request* req)</code> function.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemread"><a href="/sst-docs/docs/core/iface/StandardMem/req/read">StandardMem::Read</a><a href="#standardmemread" class="hash-link" aria-label="Direct link to standardmemread" title="Direct link to standardmemread">​</a></h3>
<p>A <code>Read</code> request sent to memHierarchy is interpreted as a read of the specified physical address. All memHierarchy components support reads.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemread-fields">StandardMem::Read fields<a href="#standardmemread-fields" class="hash-link" aria-label="Direct link to StandardMem::Read fields" title="Direct link to StandardMem::Read fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address where the read should start. MemHierarchy will use this to compute a cache line address for cacheable requests.</li>
<li><code>size</code> - number of bytes to be read, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. See the Assumptions below.</li>
<li><code>flags</code> - <code>F_NONCACHEABLE</code> is supported. If set, memHierarchy components will forward the request until it reaches the appropriate memory controller. Noncacheable requests do not query caches for potential hits and are not checked against outstanding cacheable requests for conflicts.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions">Assumptions<a href="#assumptions" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines (if cacheable) or multiple distinct memory controller address spaces (if noncacheable). MemHierarchy does <em>not</em> split requests. For performance reasons, MemHierarchy will only run checks to detect violations of these conditions if the SST-Core is compiled with <code>--enable-debug</code>.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response">Response<a href="#response" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::ReadResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation">MemEvent Translation<a href="#memevent-translation" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>Internally, MemHierarchy translates <code>SST::StandardMem::Read</code> to <code>SST::MemHierarchy::MemEvent</code>.
This table describes the translation of each field. Only relevant MemEvent fields are listed.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::Read</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::Read</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::Read::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::GetS</code> (Get-Shared)</td></tr><tr><td><code>flags_</code></td><td>Flags</td><td>Set to <code>MemEventBase::F_NONCACHEABLE</code> if <code>StandardMem::Read::flags == F_NONCACHEABLE</code></td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::Read:size</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::Read:pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>For cacheable requests, this is calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size. For noncacheable requests, this matches <code>addr_</code></td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::Read::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::Read::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemwrite"><a href="/sst-docs/docs/core/iface/StandardMem/req/write">StandardMem::Write</a><a href="#standardmemwrite" class="hash-link" aria-label="Direct link to standardmemwrite" title="Direct link to standardmemwrite">​</a></h3>
<p>A <code>Write</code> request sent to memHierarchy is interpreted as a write to the specified address. Writes to caches are performed in the cache after the block is obtained. Noncacheable writes and those sent to memory controllers are performed at the memory controller. Scratchpad writes occur in the scratchpad.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemwrite-fields">StandardMem::Write fields<a href="#standardmemwrite-fields" class="hash-link" aria-label="Direct link to StandardMem::Write fields" title="Direct link to StandardMem::Write fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address where the write should start. MemHierarchy will use this to compute a cache line address for cacheable requests.</li>
<li><code>size</code> - number of bytes to be written, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. See the Assumptions below.</li>
<li><code>data</code> - a vector of <code>uint8_t</code> containing the bytes to be written. If the processor does not use actual data, this field is not required. However, if its size is nonzero, the vector size should match the write&#x27;s &#x27;size&#x27; field.</li>
<li><code>posted</code> - if true, the write will not be acknowledged. By default, <code>posted</code> is false and memHierarchy will acknowledge every write.</li>
<li><code>flags</code> - <code>F_NONCACHEABLE</code> is supported. If set, memHierarchy components will forward the request until it reaches the appropriate memory controller. Noncacheable requests do not query caches for potential hits and are not checked against outstanding cacheable requests for conflicts.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-1">Assumptions<a href="#assumptions-1" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines (if cacheable) or multiple distinct memory controller address spaces (if noncacheable). For performance reasons, MemHierarchy will only run checks to detect violations of these conditions if the SST-Core is compiled with <code>--enable-debug</code>.</li>
<li>The data vector should either be empty or its size should match the size field. Otherwise, both sizes will be used inconsistently. If SST-Core is compiled with <code>--enable-debug</code>, mismatched sizes will be detected and produce a warning.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-1">Response<a href="#response-1" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::WriteResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-1">MemEvent Translation<a href="#memevent-translation-1" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::Write</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::Write</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::Write</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::Write::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::Write</code></td></tr><tr><td><code>flags_</code></td><td>Flags</td><td>If <code>StandardMem::Write::flags == F_NONCACHEABLE</code>,<code>flags_</code> contains <code>MemEventBase::F_NONCACHEABLE</code>. If <code>StandardMem::Write::posted == true</code>,<code>flags_</code> contains <code>MemEventBase::F_NORESPONSE</code>.</td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::Write:size</code> if <code>StandardMem::Write::data</code> is empty, otherwise size of <code>StandardMem::Write::data</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::Write:pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>For cacheable requests, this is calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size. For noncacheable requests, this matches <code>addr_</code></td></tr><tr><td><code>payload_</code></td><td><code>StandardMem::Write::data</code> if non-empty, otherwise a vector of size <code>StandardMem::Write::size</code> containing 0s.</td><td></td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::Write::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::Write::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemflushaddr"><a href="/sst-docs/docs/core/iface/StandardMem/req/flushaddr">StandardMem::FlushAddr</a><a href="#standardmemflushaddr" class="hash-link" aria-label="Direct link to standardmemflushaddr" title="Direct link to standardmemflushaddr">​</a></h3>
<p>A <code>FlushAddr</code> request sent to memHierarchy flushes an address from cache and/or directory.
Scratchpads do not handle flush requests and will error if one is received.
Memory controllers do process flushes to support persistent memory.
Flushes write dirty (written) data back to memory or a lower level cache
and can optionally invalidate the flushed address from cache too.
Flushes cause the line to be written back and/or evicted from all levels of cache.
Flushing any part of a cache line will flush the entire line.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemflushaddr-fields">StandardMem::FlushAddr fields<a href="#standardmemflushaddr-fields" class="hash-link" aria-label="Direct link to StandardMem::FlushAddr fields" title="Direct link to StandardMem::FlushAddr fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address where the flush should start. For memory, this can be non-cache line aligned. For caches, a flush of any portion of the cache line will flush the entire line.</li>
<li><code>size</code> - number of bytes to flush, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. Cache flushes to any portion of a cache line will flush the entire line. See the Assumptions below.</li>
<li><code>inv</code> - if true, the flush will also invalidate the line from cache. If false, the flush will only write back dirty data.</li>
<li><code>depth</code> - NOT YET SUPPORTED. Once supported, this will be the number of memHierarchy levels to apply the flush to. For example, depth=1, will only flush the first cache or memory encountered. Depth=2 will flush the first two. If depth is equal to or greater than the number of components in the hierarchy, the flush will propagate all the way to memory. Currently, flushes propagate all the way to memory.</li>
<li><code>flags</code> - No standard flags supported.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-2">Assumptions<a href="#assumptions-2" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines or multiple distinct memory controller address spaces. For performance reasons, MemHierarchy will only run checks to detect violations of these conditions if the SST-Core is compiled with <code>--enable-debug</code>.</li>
<li>A FlushAddr may not be noncacheable. For performance reasons, MemHierarchy will only detect noncacheable flushes and generate an error if the SST-Core is compiled with <code>--enable-debug</code>.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-2">Response<a href="#response-2" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::FlushResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-2">MemEvent Translation<a href="#memevent-translation-2" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::FlushAddr</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::FlushAddr</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::FlushAddr</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::FlushAddr::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td>If <code>StandardMem::FlushAddr::inv == true</code> then <code>cmd_ = MemHierarchy::Command::FlushLineInv</code>. Otherwise, <code>cmd_ = MemHierarchy::Command::FlushLine</code>.</td></tr><tr><td><code>flags_</code></td><td>Flags</td><td>Empty (not supported).</td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::FlushAddr:size</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::FlushAddr:pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>Calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size. If there is no cache in the system, this matches <code>addr_</code></td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::FlushAddr::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::FlushAddr::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemflushcache"><a href="/sst-docs/docs/core/iface/StandardMem/req/flushcache">StandardMem::FlushCache</a><a href="#standardmemflushcache" class="hash-link" aria-label="Direct link to standardmemflushcache" title="Direct link to standardmemflushcache">​</a></h3>
<p>A <code>FlushCache</code> request sent to memHierarchy flushes the entire cache hierarchy.
Scratchpads do not handle flush requests and will error if one is received.
Memory controllers do process flushes to support persistent memory.
Flushes write dirty (written) data back to memory or a lower level cache and invalidate
the flushed addresses from the cache.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemflushcache-fields">StandardMem::FlushCache fields<a href="#standardmemflushcache-fields" class="hash-link" aria-label="Direct link to StandardMem::FlushCache fields" title="Direct link to StandardMem::FlushCache fields">​</a></h4>
<ul>
<li><code>depth</code> - NOT YET SUPPORTED. Once supported, this will be the number of memHierarchy levels to apply the flush to. For example, depth=1, will only flush the first cache or memory encountered. Depth=2 will flush the first two. If depth is equal to or greater than the number of components in the hierarchy, the flush will propagate all the way to memory. Currently, flushes propagate all the way to memory.</li>
<li><code>flags</code> - No standard flags supported.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate flushes generated by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-3">Assumptions<a href="#assumptions-3" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A single thread may not issue multiple concurrent FlushCache requests.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-3">Response<a href="#response-3" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::FlushResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-3">MemEvent Translation<a href="#memevent-translation-3" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::FlushCache</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::FlushCache</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::FlushCache</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::FlushCache::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code> MemHierarchy::Command::FlushAll</code>.</td></tr><tr><td><code>flags_</code></td><td>Flags</td><td>Empty (not supported).</td></tr><tr><td><code>size_</code></td><td>Size</td><td>Empty (not relevant).</td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td>Empty (not relevant).</td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>Empty (not relevant).</td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::FlushCache::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td>Empty (not relevant).</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemloadlink"><a href="/sst-docs/docs/core/iface/StandardMem/req/loadlink">StandardMem::LoadLink</a><a href="#standardmemloadlink" class="hash-link" aria-label="Direct link to standardmemloadlink" title="Direct link to standardmemloadlink">​</a></h3>
<p><code>LoadLink</code> is the read part of a conditional read-modify-write atomic operation. See <code>StoreConditional</code> below for conditions that cause a LoadLink/StoreConditional (LL/SC) pair to fail. LoadLink and StoreConditional operations are only supported in L1 caches. A LoadLink brings a cache line into cache in exclusive state to ensure a subsequent atomic StoreConditional is a cache hit. Because of the exclusive state, multiple simultaneous LoadLinks to the same line are not supported. LoadLink is tracked on a per-cache-line basis so (1) atomicity is detected at cache line granularity and (2) nested LL/SC pairs, as well as accesses to <em>other</em> lines between the LoadLink and StoreConditional are supported.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemloadlink-fields">StandardMem::LoadLink fields:<a href="#standardmemloadlink-fields" class="hash-link" aria-label="Direct link to StandardMem::LoadLink fields:" title="Direct link to StandardMem::LoadLink fields:">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address to be read. MemHierarchy will use this to compute a cache line address for atomicity detection.</li>
<li><code>size</code> - number of bytes to be read, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. This only controls the number of bytes returned by the read. Atomicity violations will be enforced at cache line granularity. See the Assumptions below.</li>
<li><code>flags</code> - no standard flags supported.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The L1 uses this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-4">Assumptions<a href="#assumptions-4" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check for violations if the SST-Core is compiled with <code>--enable-debug</code>.</li>
<li>A LoadLink cannot be noncacheable as only L1 caches implement the LL/SC logic. This restriction may be removed in the future.</li>
<li>Atomicity violations between LoadLink and StoreConditional are detected at the cache line granularity</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-4">Response<a href="#response-4" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::ReadResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-4">MemEvent Translation<a href="#memevent-translation-4" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::LoadLink</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::LoadLink</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::LoadLink</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::LoadLink::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::GetSX</code> (Get-shared-and-exclusive)</td></tr><tr><td><code>flags_</code></td><td>Flags</td><td><code>MemEventBase::F_LLSC</code></td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::LoadLink::size</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::LoadLink:pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>Calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size.</td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::LoadLink::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::LoadLink::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemstoreconditional"><a href="/sst-docs/docs/core/iface/StandardMem/req/storeconditional">StandardMem::StoreConditional</a><a href="#standardmemstoreconditional" class="hash-link" aria-label="Direct link to standardmemstoreconditional" title="Direct link to standardmemstoreconditional">​</a></h3>
<p><code>StoreConditional</code> is the write part of a conditional read-modify-write atomic operation. See <code>LoadLink</code> above for the read part. Like LoadLink, StoreConditional is only handled by L1 cache components. A StoreConditional is a conditional write that succeeds only if the write is atomic with respect to a prior LoadLink read. A number of conditions will cause MemHierarchy StoreConditionals to fail following a LoadLink and as described above, atomicity is detected at a cache line granularity. Conditions that cause the write to fail are:</p>
<ul>
<li>The line has been written by any processor or thread (including the requesting thread) since the most recent LoadLink</li>
<li>The line has been LoadLink&#x27;d by any other processor or thread since the most recent LoadLink</li>
<li>The line is evicted, downgraded, flushed, or invalidated from cache after the LoadLink and before the StoreConditional</li>
</ul>
<p>LL/SC is prone to livelock. To support forward progress guarantees, L1 caches have a parameterizable window in which non-atomic accesses to a LoadLink&#x27;d line can be blocked. The window begins when the LoadLink completes in the L1 and ends as soon as a successful StoreConditional arrives or the window&#x27;s timeout period has elapsed. A StoreConditional must arrive and begin processing within the LL/SC window to guarantee forward progress. Once the window expires, a subsequent StoreConditional is subject to failure.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemstoreconditional-fields">StandardMem::StoreConditional fields<a href="#standardmemstoreconditional-fields" class="hash-link" aria-label="Direct link to StandardMem::StoreConditional fields" title="Direct link to StandardMem::StoreConditional fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address where the write should start. MemHierarchy will use this to compute a cache line address for atomicity detection.</li>
<li><code>size</code> - number of bytes to be written, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. See the Assumptions below.</li>
<li><code>data</code> - a vector of <code>uint8_t</code> containing the bytes to be written. If the processor does not use actual data, the vector can be empty. However, if its size is nonzero, the vector size should match the StoreConditional&#x27;s &#x27;size&#x27; field.</li>
<li><code>flags</code> - no standard flags supported.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-5">Assumptions<a href="#assumptions-5" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check  to detect violations of these conditions if the SST-Core is compiled with <code>--enable-debug</code>.</li>
<li>A StoreConditional cannot be noncacheable as only L1 caches implement the LL/SC logic. This restriction may be removed in the future.</li>
<li>The data vector should either be empty or its size should match the size field. Otherwise, the data vector size will be used. If SST-Core is compiled with <code>--enable-debug</code>, mismatched sizes will be detected and produce a warning.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-5">Response<a href="#response-5" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::WriteResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-5">MemEvent Translation<a href="#memevent-translation-5" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::StoreConditional</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::StoreConditional</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::StoreConditional</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::StoreConditional::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::Write</code></td></tr><tr><td><code>flags_</code></td><td>Flags</td><td><code>MemEventBase::F_LLSC</code></td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::StoreConditional:size</code> if <code>StandardMem::StoreConditional::data</code> is empty, otherwise size of <code>StandardMem::StoreConditional::data</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::StoreConditional:pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>For cacheable requests, this is calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size. For noncacheable requests, this matches <code>addr_</code></td></tr><tr><td><code>payload_</code></td><td><code>StandardMem::StoreConditional::data</code> if non-empty, otherwise a vector of size <code>StandardMem::StoreConditional::size</code> containing 0s.</td><td></td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::StoreConditional::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::StoreConditional::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemreadlock"><a href="/sst-docs/docs/core/iface/StandardMem/req/readlock">StandardMem::ReadLock</a><a href="#standardmemreadlock" class="hash-link" aria-label="Direct link to standardmemreadlock" title="Direct link to standardmemreadlock">​</a></h3>
<p>Together with <code>StandardMem::WriteUnlock</code>, <code>StandardMem::ReadLock</code> implements an unconditional read-modify-write. ReadLock and WriteUnlock operations are only supported at L1 caches. A <code>ReadLock</code> causes the cache line containing the request address to be brought into the L1 in an exclusive state. The line is then locked, preventing access by any other processor or thread until the L1 receives a WriteUnlock from the locking thread. Multiple ReadLocks can be issued to the same line from a thread. The line will not be unlocked until the same number of WriteUnlocks have been received. Locking is implemented at cache line granularity. <strong>Failure to send a WriteUnlock for every ReadLock sent will result in the line being permanently locked.</strong></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemreadlock-fields">StandardMem::ReadLock fields<a href="#standardmemreadlock-fields" class="hash-link" aria-label="Direct link to StandardMem::ReadLock fields" title="Direct link to StandardMem::ReadLock fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address to be read. MemHierarchy will use this to compute a cache line address for atomicity enforcement.</li>
<li><code>size</code> - number of bytes to be read, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. This only controls the number of bytes returned by the read. Atomicity violations will be enforced at cache line granularity. See the Assumptions below.</li>
<li><code>flags</code> - no standard flags supported.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The L1 uses this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-6">Assumptions<a href="#assumptions-6" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check for violations if the SST-Core is compiled with <code>--enable-debug</code>.</li>
<li>A ReadLock cannot be noncacheable as only L1 caches implement the ReadLock/WriteUnlock logic. This restriction may be removed in the future.</li>
<li>Atomicity enforcement between a ReadLock and WriteUnlock is done at the cache line granularity</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-6">Response<a href="#response-6" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::ReadResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-6">MemEvent Translation<a href="#memevent-translation-6" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::ReadLock</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::ReadLock</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::ReadLock</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::ReadLock::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::GetSX</code> (Get-shared-and-exclusive)</td></tr><tr><td><code>flags_</code></td><td>Flags</td><td><code>MemEventBase::F_LOCKED</code></td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::ReadLock::size</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::ReadLock:pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>Calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size.</td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::ReadLock::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::ReadLock::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemwriteunlock"><a href="/sst-docs/docs/core/iface/StandardMem/req/writeunlock">StandardMem::WriteUnlock</a><a href="#standardmemwriteunlock" class="hash-link" aria-label="Direct link to standardmemwriteunlock" title="Direct link to standardmemwriteunlock">​</a></h3>
<p><code>WriteUnlock</code> is the write part of an unconditional read-modify-write atomic operation. See <code>ReadLock</code> above for the read part. A <code>WriteUnlock</code> <strong>must</strong> be sent at some point following a <code>ReadLock</code> or the line will be permanently locked, preventing eviction, invalidation, and accesses by other threads or processors. Note that it is possible for a ReadLock/WriteUnlock pair to result in deadlock if they are not issued back-to-back. As an example, if a WriteUnlock cannot be processed until an intervening access executes and the intervening access cannot execute because it needs to evict the locked line, deadlock will occur.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemwriteunlock-fields">StandardMem::WriteUnlock fields<a href="#standardmemwriteunlock-fields" class="hash-link" aria-label="Direct link to StandardMem::WriteUnlock fields" title="Direct link to StandardMem::WriteUnlock fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical byte address where the write should start. MemHierarchy will use this to compute a cache line address for atomicity enforcement.</li>
<li><code>size</code> - number of bytes to be written, starting at <code>pAddr</code>. MemHierarchy does <em>not</em> split requests that span cache lines or memory controller address spaces. See the Assumptions below.</li>
<li><code>data</code> - a vector of <code>uint8_t</code> containing the bytes to be written. If the processor does not use actual data, the vector can be empty. However, if its size is nonzero, the vector size should match the WriteUnlock&#x27;s &#x27;size&#x27; field.</li>
<li><code>flags</code> - no standard flags supported.</li>
<li><code>vAddr</code> (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-7">Assumptions<a href="#assumptions-7" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check  to detect violations of these conditions if the SST-Core is compiled with <code>--enable-debug</code>.</li>
<li>A WriteUnlock cannot be noncacheable as only L1 caches implement the ReadLock/WriteUnlock logic. This restriction may be removed in the future.</li>
<li>The data vector should either be empty or its size should match the size field. Otherwise, the data vector size will be used. If SST-Core is compiled with <code>--enable-debug</code>, mismatched sizes will be detected and produce a warning.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-7">Response<a href="#response-7" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::WriteResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="memevent-translation-7">MemEvent Translation<a href="#memevent-translation-7" class="hash-link" aria-label="Direct link to MemEvent Translation" title="Direct link to MemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::WriteUnlock</code> requests to <code>MemHierarchy::MemEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::WriteUnlock</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::WriteUnlock</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::WriteUnlock::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::Write</code></td></tr><tr><td><code>flags_</code></td><td>Flags</td><td><code>MemEventBase::F_LOCKED</code></td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::WriteUnlock:size</code> if <code>StandardMem::WriteUnlock::data</code> is empty, otherwise size of <code>StandardMem::WriteUnlock::data</code></td></tr><tr><td><code>addr_</code></td><td>Physical address</td><td><code>StandardMem::WriteUnlock::pAddr</code></td></tr><tr><td><code>baseAddr_</code></td><td>Line address</td><td>Calculated by <code>MemHierarchy::StandardInterface</code> using the detected cache line size.</td></tr><tr><td><code>payload_</code></td><td><code>StandardMem::WriteUnlock::data</code> if non-empty, otherwise a vector of size <code>StandardMem::WriteUnlock::size</code> containing 0s.</td><td></td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::WriteUnlock::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::WriteUnlock::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemmovedata"><a href="/sst-docs/docs/core/iface/StandardMem/req/movedata">StandardMem::MoveData</a><a href="#standardmemmovedata" class="hash-link" aria-label="Direct link to standardmemmovedata" title="Direct link to standardmemmovedata">​</a></h3>
<p>The <code>MoveData</code> request is a request to move data between a scratchpad and a memory. In memHierarchy, only scratchpads handle MoveData requests.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemmovedata-fields">StandardMem::MoveData fields<a href="#standardmemmovedata-fields" class="hash-link" aria-label="Direct link to StandardMem::MoveData fields" title="Direct link to StandardMem::MoveData fields">​</a></h4>
<ul>
<li><code>pSrc</code> (source physical address) - the physical byte address of the data to be moved</li>
<li><code>pDst</code> (destination physical address) - the physical byte address to which the data should be moved</li>
<li><code>size</code> - number of bytes to be moved, starting at <code>pSrc</code>. MemHierarchy does <em>not</em> split requests that span memory controller address spaces so if a request maps to more than one memory controller, the processor should issue multiple <code>MoveData</code> requests, one per memory controller. See the Assumptions below.</li>
<li><code>posted</code> - if true, the move will not be acknowledged. By default, <code>posted</code> is false.</li>
<li><code>flags</code> - no standard flags supported.</li>
<li><code>vSrc</code> (source virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>vDst</code> (destination virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-8">Assumptions<a href="#assumptions-8" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>The requested data must map to a single source component (scratchpad or memory) and a single destination component. The request may span scratchpad or cache lines.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-8">Response<a href="#response-8" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::WriteResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="moveevent-translation">MoveEvent Translation<a href="#moveevent-translation" class="hash-link" aria-label="Direct link to MoveEvent Translation" title="Direct link to MoveEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::MoveData</code> requests to <code>MemHierarchy::MoveEvent</code> events.</p>
<table><thead><tr><th>MemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::MoveData</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::MoveData</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::MoveData::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::Put</code> if source address belongs to a scratchpad otherwise <code>MemHierarchy::Command::Get</code></td></tr><tr><td><code>flags_</code></td><td>Flags</td><td>If <code>StandardMem::MoveData::posted == true</code>,<code>flags_</code> contains <code>MemEventBase::F_NORESPONSE</code>.</td></tr><tr><td><code>dstAddr_</code></td><td>Destination physical address</td><td><code>StandardMem::MoveData:pDst</code></td></tr><tr><td><code>dstBaseAddr_</code></td><td>Destination line address</td><td>Calculated by <code>MemHierarchy::StandardInterface</code> using the detected line size.</td></tr><tr><td><code>srcAddr_</code></td><td>Source physical address</td><td><code>StandardMem::MoveData:pSrc</code></td></tr><tr><td><code>srcBaseAddr_</code></td><td>Source line address</td><td>Calculated by <code>MemHierarchy::StandardInterface</code> using the detected line size.</td></tr><tr><td><code>size_</code></td><td>Size</td><td><code>StandardMem::MoveData:size</code></td></tr><tr><td><code>dstVAddr_</code></td><td>Destination virtual address</td><td><code>StandardMem::MoveData:vDst</code></td></tr><tr><td><code>srcVAddr_</code></td><td>Source virtual address</td><td><code>StandardMem::MoveData:vSrc</code></td></tr><tr><td><code>instPtr_</code></td><td>Instruction pointer</td><td><code>StandardMem::MoveData::iPtr</code></td></tr><tr><td><code>vAddr_</code></td><td>Virtual address</td><td><code>StandardMem::MoveData::vAddr</code></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemcustomreq"><a href="/sst-docs/docs/core/iface/StandardMem/req/customreq">StandardMem::CustomReq</a><a href="#standardmemcustomreq" class="hash-link" aria-label="Direct link to standardmemcustomreq" title="Direct link to standardmemcustomreq">​</a></h3>
<p>The StandardMem API allows extension using custom request data structures derived from <code>StandardMem::CustomData</code>. As an example, a use case may be to send memory-mapped I/O (MMIO) requests between a processor and accelerator. The <code>StandardMem::CustomReq</code> request wraps the data structure as a request and the <code>StandardMem::CustomRsp</code> wraps the data structure as a response. When MemHierarchy receives a <code>StandardMem::CustomReq</code>, it copies the wrapped <code>CustomData</code> structure into a <code>MemHierarchy::CustomMemEvent</code>. MemHierarchy uses the <code>StandardMem::CustomData::getRoutingAddress()</code> function to forward the event to its destination and uses <code>StandardMem::CustomData::getSize()</code> to account for bandwidth consumed by the event. <code>getRoutingAddress()</code> should return a physical address in memHierarchy&#x27;s known address space. Caches forward custom events based on the routing address, memory controllers can attempt to handle them if an appropriate handler has been registered with the controller, and scratchpads do not currently support custom requests.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemcustomreq-fields">StandardMem::CustomReq fields<a href="#standardmemcustomreq-fields" class="hash-link" aria-label="Direct link to StandardMem::CustomReq fields" title="Direct link to StandardMem::CustomReq fields">​</a></h4>
<ul>
<li><code>data</code> (<code>CustomData*</code>) - a pointer to an object derived from <code>StandardMem::CustomData</code></li>
<li><code>flags</code> - no standard flags supported</li>
<li><code>iPtr</code> (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging.</li>
<li><code>tid</code> (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. While memHierarchy does not currently use this field to process <code>CustomReq</code> requests, it may in the future.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="assumptions-9">Assumptions<a href="#assumptions-9" class="hash-link" aria-label="Direct link to Assumptions" title="Direct link to Assumptions">​</a></h4>
<ul>
<li>The custom data structure passed via custom requests must be serializable. SST will use the data structure&#x27;s serialization method if it needs to serialize the generated <code>MemHierarchy::CustomMemEvent</code>.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="response-9">Response<a href="#response-9" class="hash-link" aria-label="Direct link to Response" title="Direct link to Response">​</a></h4>
<p><code>StandardMem::CustomResp</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="custommemevent-translation">CustomMemEvent Translation<a href="#custommemevent-translation" class="hash-link" aria-label="Direct link to CustomMemEvent Translation" title="Direct link to CustomMemEvent Translation">​</a></h4>
<p>MemHierarchy translates <code>StandardMem::CustomReq</code> requests to <code>MemHierarchy::CustomMemEvent</code> events.</p>
<table><thead><tr><th>CustomMemEvent Field</th><th>Description</th><th>How set</th></tr></thead><tbody><tr><td><code>eventID_</code></td><td>Unique ID</td><td>Generated when event is generated. Does not match the <code>StandardMem::CustomReq</code> ID.</td></tr><tr><td><code>src_</code></td><td>Event source name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>dst_</code></td><td>Event destination name</td><td>Updated by memHierarchy each time event is forwarded</td></tr><tr><td><code>rqstr_</code></td><td>Event requestor</td><td>The name of the <code>memHierarchy.standardInterface</code> that originated the <code>StandardMem::Write</code></td></tr><tr><td><code>tid_</code></td><td>Thread ID</td><td><code>StandardMem::CustomReq::tid</code></td></tr><tr><td><code>cmd_</code></td><td>Command</td><td><code>MemHierarchy::Command::CustomReq</code></td></tr><tr><td><code>data_</code></td><td>Pointer to custom data structure</td><td><code>StandardMem::CustomReq::data</code></td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="requests-sent-from-memhierarchys-standardinterface">Requests Sent From MemHierarchy&#x27;s StandardInterface<a href="#requests-sent-from-memhierarchys-standardinterface" class="hash-link" aria-label="Direct link to Requests Sent From MemHierarchy&#x27;s StandardInterface" title="Direct link to Requests Sent From MemHierarchy&#x27;s StandardInterface">​</a></h2>
<p>The following are <code>StandardMem::Request</code> types sent from memHierarchy to a processor via the StandardMem API. Processors should be equipped to handle these. Most are responses to the request types described above as, with the exception of <code>posted</code> requests, every <code>StandardMem::Request</code> results in a response once the request completes in memHierarchy.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemreadresp"><a href="/sst-docs/docs/core/iface/StandardMem/req/readresp">StandardMem::ReadResp</a><a href="#standardmemreadresp" class="hash-link" aria-label="Direct link to standardmemreadresp" title="Direct link to standardmemreadresp">​</a></h3>
<p>A <code>ReadResp</code> is sent in response to every <code>Read</code>, <code>LoadLink</code>, and <code>ReadLock</code> request once the request has completed in the memory system. The response carries the data bytes read starting at the requested <code>pAddr</code>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemresp-fields">StandardMem::Resp fields<a href="#standardmemresp-fields" class="hash-link" aria-label="Direct link to StandardMem::Resp fields" title="Direct link to StandardMem::Resp fields">​</a></h4>
<ul>
<li><code>rid</code> (Request ID) - the ID of the matching request for this response</li>
<li><code>pAddr</code> (physical address) - the physical byte address of the read data, copied from the matching request</li>
<li><code>size</code> - number of bytes read, copied from the matching request</li>
<li><code>data</code> - a vector of <code>uint8_t</code> containing the read bytes</li>
<li><code>flags</code> - no standard flags supported</li>
<li><code>vAddr</code> (virtual address) - copied from the matching request&#x27;s <code>vAddr</code></li>
<li><code>iPtr</code> (instruction pointer) - copied from the matching request&#x27;s <code>iPtr</code></li>
<li><code>tid</code> (thread ID) - copied from the matching request&#x27;s <code>tid</code></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemwriteresp"><a href="/sst-docs/docs/core/iface/StandardMem/req/writeresp">StandardMem::WriteResp</a><a href="#standardmemwriteresp" class="hash-link" aria-label="Direct link to standardmemwriteresp" title="Direct link to standardmemwriteresp">​</a></h3>
<p>A <code>WriteResp</code> is sent in response to every <code>Write</code>, <code>StoreConditional</code>, and <code>WriteUnlock</code> request once the request has completed in the memory system unless the write was posted. If a <code>StoreConditional</code> failed and the write was not completed, the <code>WriteResp::flags</code> contain the <code>StandardMem::F_FAIL</code> flag. This can queried using <code>StandardMem::WriteResp::getSuccess()</code> or <code>StandardMem::WriteResp::getFail()</code>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemwriteresp-fields">StandardMem::WriteResp fields<a href="#standardmemwriteresp-fields" class="hash-link" aria-label="Direct link to StandardMem::WriteResp fields" title="Direct link to StandardMem::WriteResp fields">​</a></h4>
<ul>
<li><code>rid</code> (Request ID) - the ID of the matching request for this response</li>
<li><code>pAddr</code> (physical address) - the physical byte address of the written data, copied from the matching request</li>
<li><code>size</code> - number of bytes that were to be written, copied from the matching request</li>
<li><code>flags</code> - if the matching was request was <code>StoreConditional</code> and failed, the <code>F_FAIL</code> flag will be set. Otherwise, the request was either unconditional (<code>Write</code>, <code>WriteUnlock</code>), or conditional but succeeded.</li>
<li><code>vAddr</code> (virtual address) - copied from the matching request&#x27;s <code>vAddr</code></li>
<li><code>iPtr</code> (instruction pointer) - copied from the matching request&#x27;s <code>iPtr</code></li>
<li><code>tid</code> (thread ID) - copied from the matching request&#x27;s <code>tid</code></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemflushresp"><a href="/sst-docs/docs/core/iface/StandardMem/req/flushresp">StandardMem::FlushResp</a><a href="#standardmemflushresp" class="hash-link" aria-label="Direct link to standardmemflushresp" title="Direct link to standardmemflushresp">​</a></h3>
<p>A <code>FlushResp</code> is sent in response to every <code>FlushReq</code> once the flush has completed. MemHierarchy can, in rare cases, fail to flush - this occurs if a Flush encounters a locked line (due to a <code>ReadLock</code> or during a <code>LoadLink</code> lockout window). If the flush fails, the <code>F_FAIL</code> flag will be set on the <code>FlushResp</code>. <code>StandardMem::FlushResp::getFail()</code> or <code>StandardMem::FlushResp::getSuccess()</code> can be used to check the flag.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemflushresp-fields">StandardMem::FlushResp fields<a href="#standardmemflushresp-fields" class="hash-link" aria-label="Direct link to StandardMem::FlushResp fields" title="Direct link to StandardMem::FlushResp fields">​</a></h4>
<ul>
<li><code>rid</code> (Request ID) - the ID of the matching request for this response</li>
<li><code>pAddr</code> (physical address) - the physical byte address of the written data, copied from the matching request</li>
<li><code>size</code> - number of bytes that were to be written, copied from the matching request</li>
<li><code>flags</code> - if the flush request failed, the <code>F_FAIL</code> flag will be set</li>
<li><code>vAddr</code> (virtual address) - copied from the matching request&#x27;s <code>vAddr</code></li>
<li><code>iPtr (instruction pointer) - copied from the matching request&#x27;s </code>iPtr`</li>
<li><code>tid</code> (thread ID) - copied from the matching request&#x27;s <code>tid</code></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmeminvnotify"><a href="/sst-docs/docs/core/iface/StandardMem/req/invnotify">StandardMem::InvNotify</a><a href="#standardmeminvnotify" class="hash-link" aria-label="Direct link to standardmeminvnotify" title="Direct link to standardmeminvnotify">​</a></h3>
<p>Some processor atomic semantics require them to snoop L1 cache invalidations. To support that, the MemHierarchy L1 can be configured to notify the processor when a line is invalidated. The notification is sent through the StandardMem interface as a <code>StandardMem::InvNotify</code>. No response to this notification is needed.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmeminvnotify-fields">StandardMem::InvNotify fields<a href="#standardmeminvnotify-fields" class="hash-link" aria-label="Direct link to StandardMem::InvNotify fields" title="Direct link to StandardMem::InvNotify fields">​</a></h4>
<ul>
<li><code>pAddr</code> (physical address) - the physical address of the line that was evicted</li>
<li><code>size</code> - number of bytes evicted (typically, the cache line size)</li>
<li><code>flags</code> - no standard flags supported</li>
<li><code>vAddr</code> (virtual address) - unused</li>
<li><code>iPtr</code> (instruction pointer) - unused</li>
<li><code>tid</code> (thread ID) - unused</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemcustomresp"><a href="/sst-docs/docs/core/iface/StandardMem/req/customreq">StandardMem::CustomResp</a><a href="#standardmemcustomresp" class="hash-link" aria-label="Direct link to standardmemcustomresp" title="Direct link to standardmemcustomresp">​</a></h3>
<p>Custom requests can control whether a response is returned using the <code>StandardMem::CustomData::needsResponse()</code> function. If a response is needed, the response arrives as a <code>StandardMem::CustomResp</code>. Like <code>CustomReq</code>, <code>CustomResp</code> wraps an object derived from <code>StandardMem::CustomData</code> which contains in the custom response data fields.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="standardmemcustomresp-fields">StandardMem::CustomResp fields<a href="#standardmemcustomresp-fields" class="hash-link" aria-label="Direct link to StandardMem::CustomResp fields" title="Direct link to StandardMem::CustomResp fields">​</a></h4>
<ul>
<li><code>rid</code> (Request ID) - the ID of the matching request for this response</li>
<li><code>data</code> (<code>StandardMem::CustomData*</code>) - pointer to the custom data structure being returned by the response</li>
<li><code>flags</code> - no standard flags supported</li>
<li><code>iPtr</code> (instruction pointer) - copied from the matching request&#x27;s <code>iPtr</code></li>
<li><code>tid</code> (thread ID) - copied from the matching request&#x27;s <code>tid</code></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="other-implementation-notes">Other Implementation Notes<a href="#other-implementation-notes" class="hash-link" aria-label="Direct link to Other Implementation Notes" title="Direct link to Other Implementation Notes">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tracing">Tracing<a href="#tracing" class="hash-link" aria-label="Direct link to Tracing" title="Direct link to Tracing">​</a></h3>
<p>The <code>StandardMem</code> interface has an <code>F_TRACE</code> flag that can be put on requests. The intent is for memHierarchy to eventually propagate and query that flag and generate trace output for events with the flag set. As of now, memHierarchy ignores the flag.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="polling">Polling<a href="#polling" class="hash-link" aria-label="Direct link to Polling" title="Direct link to Polling">​</a></h3>
<p>The <code>StandardMem</code> interface supports polling received requests using the <code>poll()</code> function. The memHierarchy implementation does not support polling. Instead, the component loading <code>memHierarchy.standardInterface</code> must register a callback handler with the interface to handle received requests.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="flags">Flags<a href="#flags" class="hash-link" aria-label="Direct link to Flags" title="Direct link to Flags">​</a></h3>
<p><code>StandardMem</code> defines some standard flags and also reserves space in the <code>flags</code> bit vector for custom flags. Not all standard flags are supported by memHierarchy for all request types, but memHierarchy will copy and propagate any custom flags through its events.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="requests-exchanged-during-ssts-init-phase">Requests exchanged during SST&#x27;s <code>init()</code> phase<a href="#requests-exchanged-during-ssts-init-phase" class="hash-link" aria-label="Direct link to requests-exchanged-during-ssts-init-phase" title="Direct link to requests-exchanged-during-ssts-init-phase">​</a></h3>
<p>Prior to simulation start, SST components can exchange events during <code>init()</code>. MemHierarchy supports initializing memory contents during this phase using the <code>StandardMem::sendUntimedData()</code> function. Processors issue writes which will be forwarded to the appropriate memory controller. During <code>init()</code> only, data can be written at granularities larger than a cache line. A single write request may not map to multiple memory controllers however. The caches/scratchpads do not operate during this phase and only forward requests. The interface does not (yet) support receiving messages during <code>init()</code>, so, for example, processors cannot exchange MMIO requests.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="scratchpad-addressing">Scratchpad addressing<a href="#scratchpad-addressing" class="hash-link" aria-label="Direct link to Scratchpad addressing" title="Direct link to Scratchpad addressing">​</a></h3>
<p>When the memHierarchy scratchpad was originally written, scratchpads were assumed to be private to a processor with an address space of 0 to sizeof(scratchpad) and memory addresses mapped above that. MemHierarchy relies on this assumption to determine whether a StandardMem::MoveData request is converted to a MemHierarchy Get (copy data from memory to scratch) or Put (copy data from scratch to memory). We are looking into changing this assumption.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mmio">MMIO<a href="#mmio" class="hash-link" aria-label="Direct link to MMIO" title="Direct link to MMIO">​</a></h3>
<p>MemHierarchy supports memory-mapped I/O. Processors/accelerators/etc. should use <code>StandardMem::setMemoryMappedAddressRegion()</code> to set a contiguous range of addresses that map to the endpoint. This must be called prior to SST&#x27;s <code>init()</code> phase. Accesses to MMIO addresses are always noncacheable.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/memHierarchy/stdmem.mdx" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2025-05-19T22:06:10.000Z" itemprop="dateModified">May 19, 2025</time></b> by <b>grvosku</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/sst-docs/docs/elements/memHierarchy/intro"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">memHierarchy</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/sst-docs/docs/elements/memHierarchy/connecting"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Connecting to MemHierarchy</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#requests-versus-events" class="table-of-contents__link toc-highlight">Requests versus Events</a></li><li><a href="#requests-sent-to-memhierarchys-standardinterface" class="table-of-contents__link toc-highlight">Requests Sent to MemHierarchy&#39;s StandardInterface</a><ul><li><a href="#standardmemread" class="table-of-contents__link toc-highlight">StandardMem::Read</a></li><li><a href="#standardmemwrite" class="table-of-contents__link toc-highlight">StandardMem::Write</a></li><li><a href="#standardmemflushaddr" class="table-of-contents__link toc-highlight">StandardMem::FlushAddr</a></li><li><a href="#standardmemflushcache" class="table-of-contents__link toc-highlight">StandardMem::FlushCache</a></li><li><a href="#standardmemloadlink" class="table-of-contents__link toc-highlight">StandardMem::LoadLink</a></li><li><a href="#standardmemstoreconditional" class="table-of-contents__link toc-highlight">StandardMem::StoreConditional</a></li><li><a href="#standardmemreadlock" class="table-of-contents__link toc-highlight">StandardMem::ReadLock</a></li><li><a href="#standardmemwriteunlock" class="table-of-contents__link toc-highlight">StandardMem::WriteUnlock</a></li><li><a href="#standardmemmovedata" class="table-of-contents__link toc-highlight">StandardMem::MoveData</a></li><li><a href="#standardmemcustomreq" class="table-of-contents__link toc-highlight">StandardMem::CustomReq</a></li></ul></li><li><a href="#requests-sent-from-memhierarchys-standardinterface" class="table-of-contents__link toc-highlight">Requests Sent From MemHierarchy&#39;s StandardInterface</a><ul><li><a href="#standardmemreadresp" class="table-of-contents__link toc-highlight">StandardMem::ReadResp</a></li><li><a href="#standardmemwriteresp" class="table-of-contents__link toc-highlight">StandardMem::WriteResp</a></li><li><a href="#standardmemflushresp" class="table-of-contents__link toc-highlight">StandardMem::FlushResp</a></li><li><a href="#standardmeminvnotify" class="table-of-contents__link toc-highlight">StandardMem::InvNotify</a></li><li><a href="#standardmemcustomresp" class="table-of-contents__link toc-highlight">StandardMem::CustomResp</a></li></ul></li><li><a href="#other-implementation-notes" class="table-of-contents__link toc-highlight">Other Implementation Notes</a><ul><li><a href="#tracing" class="table-of-contents__link toc-highlight">Tracing</a></li><li><a href="#polling" class="table-of-contents__link toc-highlight">Polling</a></li><li><a href="#flags" class="table-of-contents__link toc-highlight">Flags</a></li><li><a href="#requests-exchanged-during-ssts-init-phase" class="table-of-contents__link toc-highlight">Requests exchanged during SST&#39;s <code>init()</code> phase</a></li><li><a href="#scratchpad-addressing" class="table-of-contents__link toc-highlight">Scratchpad addressing</a></li><li><a href="#mmio" class="table-of-contents__link toc-highlight">MMIO</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="/sst-docs/img/sst-logo-small.png" class="footer__logo themedComponent_mlkZ themedComponent--light_NVdE"><img src="/sst-docs/img/sst-logo-small.png" class="footer__logo themedComponent_mlkZ themedComponent--dark_xIcU"></div><div class="footer__copyright">Copyright © 2009-2025 NTESS</div></div></div></footer></div>
</body>
</html>