"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[34142],{28453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>r});var d=i(96540);const n={},a=d.createContext(n);function l(e){const t=d.useContext(a);return d.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),d.createElement(a.Provider,{value:t},e.children)}},79763:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>f,frontMatter:()=>l,metadata:()=>d,toc:()=>s});const d=JSON.parse('{"id":"core/statoutput/outputField","title":"outputField","description":"These functions should be overridden for each type supported by the statistic output.","source":"@site/../docs/core/statoutput/outputField.md","sourceDirName":"core/statoutput","slug":"/core/statoutput/outputField","permalink":"/sst-docs/docs/core/statoutput/outputField","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/statoutput/outputField.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"outputField"},"sidebar":"core","previous":{"title":"implStopOutputEntries","permalink":"/sst-docs/docs/core/statoutput/implStopOutputEntries"},"next":{"title":"serialize_order","permalink":"/sst-docs/docs/core/statoutput/serialize_order"}}');var n=i(74848),a=i(28453);const l={title:"outputField"},r=void 0,o={},s=[{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Header",id:"header",level:2}];function u(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"virtual void outputField(fieldHandle_t fieldHandle, int32_t data);\nvirtual void outputField(fieldHandle_t fieldHandle, uint32_t data);\nvirtual void outputField(fieldHandle_t fieldHandle, int64_t data);\nvirtual void outputField(fieldHandle_t fieldHandle, uint64_t data);\nvirtual void outputField(fieldHandle_t fieldHandle, float data);\nvirtual void outputField(fieldHandle_t fieldHandle, double data);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["These functions ",(0,n.jsx)(t.em,{children:"should"})," be overridden for each type supported by the statistic output."]}),"\n",(0,n.jsx)(t.p,{children:'The default implementations produce an error message that the function is not implemented. When outputting statistics, each statistic will call the appropriate function for each of its data members. For example, an accumulator will call this for "sum", "sum-squared", "count", "min", and "max" while a histogram will call these to output the histogram\'s bin configuration (number, width, etc.), the value of each bin, and any outliers.'}),"\n",(0,n.jsxs)(t.p,{children:["The function implementations may simply store the data value formatted as needed or it may also use ",(0,n.jsx)(t.code,{children:"fieldHandle"})," to look up information about the specific field being output."]}),"\n",(0,n.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"fieldHandle"})," (fieldHandle_t) A handler indicating the specific field being output."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"data"})," (various types) The data value to be output."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(t.h3,{id:"example-1",children:"Example 1"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",metastring:'title="Buffering data as strings without any field information"',children:'void outputField(fieldHandle_t fieldHandle, int32_t data) override { buffer_string += format_string(" %" PRId32, data); }\nvoid outputField(fieldHandle_t fieldHandle, uint32_t data) override { buffer_string += format_string(" %" PRIu32, data); }\nvoid outputField(fieldHandle_t fieldHandle, int64_t data) override { buffer_string += format_string(" %" PRId64, data); }\nvoid outputField(fieldHandle_t fieldHandle, uint64_t data) override { buffer_string += format_string(" %" PRIu64, data); }\nvoid outputField(fieldHandle_t fieldHandle, float data) override { buffer_string += format_string(" %f", data); }\nvoid outputField(fieldHandle_t fieldHandle, double data) override { buffer_string += format_string(" %f", data); }\n'})}),"\n",(0,n.jsx)(t.h3,{id:"example-2",children:"Example 2"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",metastring:'title="Buffering data as strings with field information"',children:'void outputField(fieldHandle_t fieldHandle, int32_t data) override \n{ \n    buffer_string += format_string(" %" PRId32, data); \n}\n\nvoid outputField(fieldHandle_t fieldHandle, uint32_t data) override \n{ \n    buffer_string += format_string(" %" PRIu32, data); \n}\n\nvoid outputField(fieldHandle_t fieldHandle, int64_t data) override \n{ \n    buffer_string += format_string(" %" PRId64, data); \n}\n\nvoid outputField(fieldHandle_t fieldHandle, uint64_t data) override \n{ \n    buffer_string += format_string(" %" PRIu64, data); \n}\nvoid outputField(fieldHandle_t fieldHandle, float data) override \n{ \n    buffer_string += format_string(" %f", data); \n}\nvoid outputField(fieldHandle_t fieldHandle, double data) override \n{ \n    buffer_string += format_string(" %f", data); \n}\n'})}),"\n",(0,n.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/statapi/statoutput.h>\n"})})]})}function f(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}}}]);