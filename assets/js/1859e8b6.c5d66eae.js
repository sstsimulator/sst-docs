"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[10957],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},71573:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"elements/memHierarchy/intro","title":"memHierarchy","description":"The memHierarchy library is a collection of cache, scratchpad, directory, and memory components that can be used to build memory systems. The components are generally designed to be interoperable. The library implements SST\'s StandardMemory interface for interfacing between endpoints (CPU, GPU, other accelerator, etc.) and the memHierarchy memory system. Additionally, memHierarchy components can be connected to each other and endpoints via both both raw SST links and network libraries that implement the SimpleNetwork interface.","source":"@site/../docs/elements/memHierarchy/intro.md","sourceDirName":"elements/memHierarchy","slug":"/elements/memHierarchy/intro","permalink":"/sst-docs/docs/elements/memHierarchy/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/memHierarchy/intro.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"memHierarchy"},"sidebar":"elements","previous":{"title":"mask-mpi","permalink":"/sst-docs/docs/elements/maskmpi/intro"},"next":{"title":"StandardMem Interface","permalink":"/sst-docs/docs/elements/memHierarchy/stdmem"}}');var r=n(74848),i=n(28453);const a={title:"memHierarchy"},o=void 0,c={},m=[{value:"Required dependencies",id:"required-dependencies",level:3},{value:"Optional dependencies",id:"optional-dependencies",level:3}];function d(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.em,{children:"memHierarchy"})," library is a collection of cache, scratchpad, directory, and memory components that can be used to build memory systems. The components are generally designed to be interoperable. The library implements SST's ",(0,r.jsx)(t.a,{href:"/sst-docs/docs/core/iface/StandardMem/class",children:(0,r.jsx)(t.code,{children:"StandardMemory"})})," interface for interfacing between endpoints (CPU, GPU, other accelerator, etc.) and the memHierarchy memory system. Additionally, memHierarchy components can be connected to each other and endpoints via both both raw SST links and network libraries that implement the ",(0,r.jsx)(t.a,{href:"/sst-docs/docs/core/iface/SimpleNetwork/class",children:(0,r.jsx)(t.code,{children:"SimpleNetwork"})})," interface."]}),"\n",(0,r.jsx)(t.admonition,{title:"At a Glance",type:"note",children:(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Source Code:"})," ",(0,r.jsx)(t.a,{href:"https://github.com/sstsimulator/sst-elements/tree/master/src/sst/elements/memHierarchy",children:"sst-elements/.../memHierarchy"})," \xa0",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.strong,{children:"SST Name:"})," ",(0,r.jsx)(t.code,{children:"memHierarchy"})," \xa0",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.strong,{children:"Maturity Level:"})," Mature (3) \xa0",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.strong,{children:"Development Path:"})," Active \xa0",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.strong,{children:"Last Released:"})," SST 15.0"]})}),"\n",(0,r.jsx)(t.h3,{id:"required-dependencies",children:"Required dependencies"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"None"})}),"\n",(0,r.jsx)(t.h3,{id:"optional-dependencies",children:"Optional dependencies"}),"\n",(0,r.jsxs)(t.p,{children:["MemHierarchy memories can optionally use any of the following simulators in place of the included timing models for main memory, scratchpad, and other components that load a backend timing model. SST-Elements must be compiled with the appropriate ",(0,r.jsx)(t.code,{children:"--with-<SIMULATOR>=/path/to/sim"})," flag for the integration to be enabled. See the SST ",(0,r.jsx)(t.a,{href:"http://sst-simulator.org/SSTPages/SSTBuildAndInstall_15dot0dot0_SeriesAdditionalExternalComponents/",children:"dependency build instructions"})," for details."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"../cramsim/intro",children:"CramSim"}),"; included with sst-elements"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/tactcomplabs/gc64-hmcsim",children:"HMCSim"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/tactcomplabs/gc64-hmcsim/archive/sst-8.0.0-release.zip",children:"Download"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"../messier/intro",children:"messier"}),"; included with sst-elements"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/CMU-SAFARI/ramulator/",children:"Ramulator"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/CMU-SAFARI/ramulator/archive/master.zip",children:"Download"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/CMU-SAFARI/ramulator2/",children:"Ramulator2"}),"; Ramulator2 does not have releases; SST tests against commit ",(0,r.jsx)(t.code,{children:"a26ee92f"})," ",(0,r.jsx)(t.strong,{children:"New in SST 15.0"})]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The following dependencies are no longer supported as of SST 15.0:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/dramninjaUMD/DRAMSim2",children:"DramSim2"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/dramninjasUMD/DRAMSim2/archive/v2.2.2.tar.gz",children:"Download"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/umd-memsys/dramsim3",children:"DramSim3"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/umd-memsys/dramsim3",children:"Download"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/tactcomplabs/HBM",children:"HBMDramSim"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/tactcomplabs/HBM/releases/tag/sst-8.0.0-release",children:"Download"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/jimstevens2001/NVDIMMSim/",children:"NVDIMMSim"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/jimstevens2001/NVDIMMSIM/archive/v2.0.0.tar.gz",children:"Download"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://github.com/jimstevens2001/HybridSim",children:"HybridSim"}),"; ",(0,r.jsx)(t.a,{href:"https://github.com/jimstevens2001/HybridSim/archive/v2.0.1.tar.gz",children:"Download"})]}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);