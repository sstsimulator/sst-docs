"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[52562],{14584:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"core/serialization/overview","title":"Serialization","description":"SST uses serialization in three different contexts during simulation:","source":"@site/../docs/core/serialization/overview.md","sourceDirName":"core/serialization","slug":"/core/serialization/overview","permalink":"/sst-docs/docs/core/serialization/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/serialization/overview.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1762293106000,"frontMatter":{"title":"Serialization"},"sidebar":"core","previous":{"title":"simulationSignalShutdown","permalink":"/sst-docs/docs/core/realtime/simulationSignalShutdown"},"next":{"title":"Shared Objects","permalink":"/sst-docs/docs/core/sharedobj/overview"}}');var r=n(74848),a=n(28453);const l={title:"Serialization"},t=void 0,o={},d=[{value:"When does a class need to be serializable?",id:"when-does-a-class-need-to-be-serializable",level:2},{value:"How do I make a class serializable?",id:"how-do-i-make-a-class-serializable",level:2},{value:"The <code>serialize_order</code> function",id:"the-serialize_order-function",level:2},{value:"SerOption",id:"seroption",level:4},{value:"When the default serialization does not work",id:"when-the-default-serialization-does-not-work",level:4},{value:"The <code>serialize_impl</code> template class",id:"the-serialize_impl-template-class",level:2},{value:"Serialization odds and ends",id:"serialization-odds-and-ends",level:2},{value:"Serializing pointers",id:"serializing-pointers",level:3},{value:"C-style arrays",id:"c-style-arrays",level:4},{value:"Malloc/free versus new/delete",id:"mallocfree-versus-newdelete",level:4},{value:"See also: Checkpoint Guide.",id:"see-also-checkpoint-guide",level:2}];function c(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"SST uses serialization in three different contexts during simulation:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["When transferring ",(0,r.jsx)(i.code,{children:"SST::Events"})," between parallel processes"]}),"\n",(0,r.jsx)(i.li,{children:"For checkpoint/restart"}),"\n",(0,r.jsx)(i.li,{children:"To map an object's state, for example, for introspection and modification in an interactive console"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["SST provides a serialization framework for elements, however elements need to manually specify how they should be serialized. In most cases, this is as simple as adding a special ",(0,r.jsx)(i.code,{children:"serialize_order"})," function and passing each of the class's data members to the ",(0,r.jsx)(i.code,{children:"SST_SER"})," macro as shown."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"void serialize_order(SST::Core::Serialization::serializer& ser) {\n    SST_SER(var0);\n    SST_SER(var1);\n    SST_SER(var2);\n    // ... and so on\n}\n"})}),"\n",(0,r.jsx)(i.p,{children:"While SST performs serialization slightly differently for each context, a class only needs to implement serialization once to support all three uses."}),"\n",(0,r.jsx)(i.h2,{id:"when-does-a-class-need-to-be-serializable",children:"When does a class need to be serializable?"}),"\n",(0,r.jsxs)(i.p,{children:["Will an object of your class type ever be sent over a Link between Components, either because the class inherits from ",(0,r.jsx)(i.code,{children:"SST::Event"})," or is a data member of an ",(0,r.jsx)(i.code,{children:"SST::Event"}),"? You need to support serialization."]}),"\n",(0,r.jsxs)(i.p,{children:["Do you want to enable checkpoint/restart of your simulation as a whole? ",(0,r.jsx)(i.em,{children:"Every"})," object that will be checkpointed needs to be serializable."]}),"\n",(0,r.jsx)(i.p,{children:"Do you want to enable introspection and/or modification of your class during simulation via an interactive console? The class needs to be serializable. This is the only case in which you may choose to partially serialize the class. Only serialized data members will be visible during introspection."}),"\n",(0,r.jsxs)(i.p,{children:["If the class is not an ",(0,r.jsx)(i.code,{children:"Event"}),", and you do not intend to support checkpoint or interactive introspection, then it does not need to be serializable."]}),"\n",(0,r.jsx)(i.h2,{id:"how-do-i-make-a-class-serializable",children:"How do I make a class serializable?"}),"\n",(0,r.jsx)(i.p,{children:"Provide a function that SST can use to serialize the class. The specifics depend on the class that needs to be serialized."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Case 1: Your class inherits from an SST element class or other SST type such as Event"})}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsx)(i.li,{children:"Add a default constructor"}),"\n",(0,r.jsxs)(i.li,{children:["Implement a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function in your class."]}),"\n",(0,r.jsxs)(i.li,{children:["Add a serialization macro to the class's header.","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ImplementSerializable(class_name)"}),": For classes that are serializable"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ImplementVirtualSerializable(class_name)"}),": For abstract classes that are serializable"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"NotSerializable(class_name)"}),": If a class is not serializable, it needs to declare this macro instead of the above. You can then  skip implementing a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Case 2: Your class is not polymorphic or is declared final"}),"\nUsing this method, final classes can only be serialized as their final type. To allow serialization using base class pointers, follow the instructions in Case 3."]}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsx)(i.li,{children:"Add a default constructor"}),"\n",(0,r.jsxs)(i.li,{children:["Implement a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function for your class."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Case 3: Your class is polymorphic and does not inherit from a serializable class"})}),"\n",(0,r.jsx)(i.p,{children:"In this case you have two options:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["(Recommended) Inherit from ",(0,r.jsx)(i.code,{children:"SST::Core::Serialization::Serializable"}),' and follow the steps in "Case 1".\nOR']}),"\n",(0,r.jsxs)(i.li,{children:["Implement a default constructor and a ",(0,r.jsx)(i.code,{children:"serialize_impl"})," class templated on your type"]}),"\n"]}),"\n",(0,r.jsxs)(i.h2,{id:"the-serialize_order-function",children:["The ",(0,r.jsx)(i.code,{children:"serialize_order"})," function"]}),"\n",(0,r.jsxs)(i.p,{children:["Many classes can be made serializable by adding a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function. This function serializes and deserializes all data members belonging to the class using a special ",(0,r.jsx)(i.code,{children:"SST_SER"})," macro. The macro accepts data of many types including:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["All POD types (",(0,r.jsx)(i.code,{children:"bool"}),", ",(0,r.jsx)(i.code,{children:"int"}),", etc.) and ",(0,r.jsx)(i.code,{children:"std::string"})]}),"\n",(0,r.jsxs)(i.li,{children:["All standard library containers (",(0,r.jsx)(i.code,{children:"std::vector"}),", ",(0,r.jsx)(i.code,{children:"std::map"}),", ",(0,r.jsx)(i.code,{children:"std::array"}),", etc.)"]}),"\n",(0,r.jsxs)(i.li,{children:["Several standard library types: ",(0,r.jsx)(i.code,{children:"std::atomic"}),", ",(0,r.jsx)(i.code,{children:"std::pair"}),", ",(0,r.jsx)(i.code,{children:"std::tuple"}),", ",(0,r.jsx)(i.code,{children:"std::unique_ptr"})]}),"\n",(0,r.jsxs)(i.li,{children:["SST types: ",(0,r.jsx)(i.code,{children:"Link"}),", ",(0,r.jsx)(i.code,{children:"TimeConverter"}),", ",(0,r.jsx)(i.code,{children:"Output"}),", ",(0,r.jsx)(i.code,{children:"RNG:Random"}),", ",(0,r.jsx)(i.code,{children:"RNG:RandomDistribution"}),", ",(0,r.jsx)(i.code,{children:"SharedArray"}),", ",(0,r.jsx)(i.code,{children:"SharedMap"}),", ",(0,r.jsx)(i.code,{children:"SharedSet"}),", ",(0,r.jsx)(i.code,{children:"UnitAlgebra"}),", ",(0,r.jsx)(i.code,{children:"Statistic"}),", ",(0,r.jsx)(i.code,{children:"StatisticOutput"})]}),"\n",(0,r.jsxs)(i.li,{children:["SST Handlers: ",(0,r.jsx)(i.code,{children:"Clock::Handler2"}),", ",(0,r.jsx)(i.code,{children:"Event::Handler2"})]}),"\n",(0,r.jsxs)(i.li,{children:["SST Interfaces: ",(0,r.jsx)(i.code,{children:"SimpleNetwork"}),", ",(0,r.jsx)(i.code,{children:"StandardMem"})]}),"\n",(0,r.jsx)(i.li,{children:"Any object type for which you have implemented serialization"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["The serialize_order function looks like this. If your class inherits from another, it should call that class's ",(0,r.jsx)(i.code,{children:"serialize_order"})," function ",(0,r.jsx)(i.em,{children:"before"})," it serializes its own data."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"virtual void serialize_order(SST::Core::Serialization::serializer& ser) override {\n    Base::Class:serialize_order(ser);\n    SST_SER(data0);\n    SST_SER(data1);\n    SST_SER(data2);\n    SST_SER(data3);\n    // ... and so on\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"SST_SER"})," macros have the following syntax."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"SST_SER(variable);\nSST_SER(variable, options);\nSST_SER_NAME(variable, mapping_name, options);\n"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"variable"})," is required and is the variable being serialized. ",(0,r.jsx)(i.code,{children:"options"})," may be passed if needed as described in the next section. ",(0,r.jsx)(i.code,{children:"mapping_name"})," allows providing a different (e.g., more user-friendly) name than the variable name when mapping the object."]}),"\n",(0,r.jsx)(i.admonition,{type:"warning",children:(0,r.jsxs)(i.p,{children:["Do not change the name of the serializer variable ",(0,r.jsx)(i.code,{children:"ser"})," that is passed to ",(0,r.jsx)(i.code,{children:"serialize_order"}),". The ",(0,r.jsx)(i.code,{children:"SST_SER"})," macro uses it."]})}),"\n",(0,r.jsx)(i.h4,{id:"seroption",children:"SerOption"}),"\n",(0,r.jsxs)(i.p,{children:["Depending on how a variable is used, you may need to pass options to ",(0,r.jsx)(i.code,{children:"SST_SER"})," to control serialization. Options and when to use them are as follows. Options may be combined with the ",(0,r.jsx)(i.code,{children:"|"})," operator."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.em,{children:"Note: All options are ignored during event serialization"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::as_ptr"}),"\nUse this option if you are serializing a non-pointer variable but a pointer to the variable will also be serialized. The non-pointer must be serialized ",(0,r.jsx)(i.em,{children:"before"})," the pointer."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::as_ptr_elem"}),"\nUse this to pass the ",(0,r.jsx)(i.code,{children:"as_ptr"})," option to the contents of a container"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::map_read_only"}),"\nPrevents the variable's value from being modified when mapping an object."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::no_map"}),"\nIndicates that a variable should not be included when mapping the object."]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"when-the-default-serialization-does-not-work",children:"When the default serialization does not work"}),"\n",(0,r.jsxs)(i.p,{children:["In many cases, calling ",(0,r.jsx)(i.code,{children:"SST_SER"})," will be sufficient for both serialization and deserialization. However, in some instances, particularly with complex data structures, you may find the default serialization is not sufficient. In these cases, you can handle serialization manually by detecting which ",(0,r.jsx)(i.em,{children:"mode"})," the serializer is in and performing the necessary actions. There are four modes:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SIZER"})," Determine the size of the buffer to allocate"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"PACK"})," Serialize the data into the buffer"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"UNPACK"})," Deserialize the data"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"MAP"})," Map the object by serializing it"]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["During event serialization and checkpoint, the serializer will enter SIZER and then PACK mode. During event deserialization and restart, the serializer will enter UNPACK mode. During mapping, the serializer will enter MAP mode. Query the mode using ",(0,r.jsx)(i.code,{children:"ser.mode()"}),"."]}),"\n",(0,r.jsx)(i.p,{children:"Ensure that SIZER and PACK are identical. UNPACK should serialize data in the same order as SIZER/PACK."}),"\n",(0,r.jsx)(i.p,{children:"As an example, this code manages an iterator that needs to be re-initialized for checkpoint/restart."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"\n// iter_ starts at neighbors_.begin() and increments each time an event is sent\n// events_sent_ counts the total number of sent events\nstd::set<std::string> neighbors_;\nstd::set<std::string>::iterator iter_;\nsize_t events_sent_;\n\nvoid serialize_order(SST::Core::Serialization::serializer& ser)\n{\n    SST_SER(events_sent_);\n    SST_SER(neighbors_);\n\n    // Re-initialize iter_ if deserializing (UNPACKing)\n    if ( ser.mode() == SST::Core::Serialization::serializer::UNPACK) {\n        // Move iter forward from neighbors.begin() events_sent_ times\n        int index = events_sent_ % neighbors_.size();\n        iter_ = neighbors_.begin();\n        std::advance(iter_, index);\n    }\n}\n"})}),"\n",(0,r.jsxs)(i.h2,{id:"the-serialize_impl-template-class",children:["The ",(0,r.jsx)(i.code,{children:"serialize_impl"})," template class"]}),"\n",(0,r.jsxs)(i.p,{children:["In some cases, implementing a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function may not be ideal or possible -- for example, a polymorphic class that cannot, for whatever reason, inherit from ",(0,r.jsx)(i.code,{children:"Serializable"}),". In this case, you may implement a ",(0,r.jsx)(i.code,{children:"serialize_impl"})," class templated on the type to be serialized. You will need to handle the ",(0,r.jsxs)(i.a,{href:"#seroption",children:[(0,r.jsx)(i.code,{children:"SerOption"})," options"]})," manually in the template class."]}),"\n",(0,r.jsx)(i.p,{children:"An example of using this method will be forthcoming."}),"\n",(0,r.jsx)(i.h2,{id:"serialization-odds-and-ends",children:"Serialization odds and ends"}),"\n",(0,r.jsx)(i.h3,{id:"serializing-pointers",children:"Serializing pointers"}),"\n",(0,r.jsx)(i.p,{children:"When serializing events, pointer tracking is NOT enabled. Serializing a pointer will serialize the pointed-to object, creating a copy at the recipient if the receiving component is on different thread or rank."}),"\n",(0,r.jsxs)(i.p,{children:["When serializing for checkpoint or mapping/debug, pointer tracking is enabled. You may serialize pointers and the pointed-to object will be serialized as well. Objects will be serialized once, even if multiple pointers point to them and are serialized. However, ensure that all serialized pointers are either valid or set to ",(0,r.jsx)(i.code,{children:"nullptr"}),"."]}),"\n",(0,r.jsx)(i.h4,{id:"c-style-arrays",children:"C-style arrays"}),"\n",(0,r.jsx)(i.p,{children:"C-style arrays are a special case of pointers. Serializing the pointer will only serialize the first element in the array. Use SST's array function to pass both the pointer and size (number of elements) to the serializer."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"// size_t size = 4;\n// char* arr = new char[size];\n\nSST_SER(SST::Core::Serialization::array(arr, size));\n"})}),"\n",(0,r.jsx)(i.h4,{id:"mallocfree-versus-newdelete",children:"Malloc/free versus new/delete"}),"\n",(0,r.jsxs)(i.p,{children:["When deserializing, SST uses ",(0,r.jsx)(i.code,{children:"new"})," to allocate objects. If you are using ",(0,r.jsx)(i.code,{children:"malloc"})," and may ",(0,r.jsx)(i.code,{children:"free"})," the object, manually allocate and then serialize/deserialize the object itself (rather than a pointer)."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"// MyStruct* ptr = (MyStruct*) malloc(sizeof(MyStruct));\nswitch( ser.mode() ) {\n    case SST::Core::Serialization::serializer::SIZER:\n    case SST::Core::Serialization::serializer::PACK:\n    case SST::Core::Serialization::serializer::MAP:\n        SST_SER(*ptr);\n        break;\n    case SST::Core::Serialization::serializer::UNPACK:\n        ptr = (MyStruct*)malloc(sizeof(MyStruct));\n        SST_SER(*ptr);\n        break;\n}\n"})}),"\n",(0,r.jsxs)(i.h2,{id:"see-also-checkpoint-guide",children:["See also: ",(0,r.jsx)(i.a,{href:"/sst-docs/docs/guides/features/checkpoint",children:"Checkpoint Guide"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>t});var s=n(96540);const r={},a=s.createContext(r);function l(e){const i=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(a.Provider,{value:i},e.children)}}}]);