"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[20112],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},44628:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"guides/features/checkpoint","title":"Checkpoint and restart","description":"Checkpoint/restart is supported in SST 15 and partially supported in SST 14. Elements are not automatically checkpoint-able. To enable checkpoint/restart, developers must create a function in each element that describes how to serialize the element. A simulation can be checkpointed if all of the elements it uses support checkpoint (i.e., are serializable).","source":"@site/../docs/guides/features/checkpoint.mdx","sourceDirName":"guides/features","slug":"/guides/features/checkpoint","permalink":"/sst-docs/docs/guides/features/checkpoint","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/guides/features/checkpoint.mdx","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1762293106000,"frontMatter":{"title":"Checkpoint and restart"},"sidebar":"guides","previous":{"title":"Features","permalink":"/sst-docs/docs/category/features"},"next":{"title":"Signal handling","permalink":"/sst-docs/docs/guides/features/signal"}}');var s=i(74848),r=i(28453),a=i(65537),l=i(79329);const o={title:"Checkpoint and restart"},c=void 0,d={},h=[{value:"Support status",id:"support-status",level:2},{value:"Creating a checkpoint",id:"creating-a-checkpoint",level:2},{value:"Restarting from a checkpoint",id:"restarting-from-a-checkpoint",level:2},{value:"Adding checkpoint support to element libraries",id:"adding-checkpoint-support-to-element-libraries",level:2},{value:"Step 1: Inherit from the Serializable class - non-Element classes ONLY",id:"step-1-inherit-from-the-serializable-class---non-element-classes-only",level:3},{value:"Step 2: Change Clock and Event handler functions",id:"step-2-change-clock-and-event-handler-functions",level:3},{value:"Step 3: Add a default constructor",id:"step-3-add-a-default-constructor",level:3},{value:"Step 4: Add a serialization function",id:"step-4-add-a-serialization-function",level:3},{value:"Step 5: Add the appropriate serialization macro",id:"step-5-add-the-appropriate-serialization-macro",level:3},{value:"Step 6: Document that the element is checkpointable",id:"step-6-document-that-the-element-is-checkpointable",level:3},{value:"Put it together: An example",id:"put-it-together-an-example",level:3},{value:"Problems and solutions",id:"problems-and-solutions",level:2},{value:"Serializing uninitialized pointers",id:"serializing-uninitialized-pointers",level:3},{value:"Lambdas",id:"lambdas",level:3},{value:"Advanced notes on serialization",id:"advanced-notes-on-serialization",level:2},{value:"Background",id:"background",level:3},{value:"Approach 1: Handle serialization phases differently",id:"approach-1-handle-serialization-phases-differently",level:3},{value:"Example: Serializing a C-style array that uses <code>malloc</code>/<code>free</code>",id:"example-serializing-a-c-style-array-that-uses-mallocfree",level:4},{value:"Example: Serializing a type as a different type",id:"example-serializing-a-type-as-a-different-type",level:4},{value:"Approach 2: Manually implementing serialization support",id:"approach-2-manually-implementing-serialization-support",level:3},{value:"Planned improvements",id:"planned-improvements",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Checkpoint/restart is supported in SST 15 and partially supported in SST 14. Elements are not automatically checkpoint-able. To enable checkpoint/restart, developers must create a function in each element that describes how to serialize the element. A simulation can be checkpointed if ",(0,s.jsx)(n.em,{children:"all"})," of the elements it uses support checkpoint (i.e., are serializable)."]}),"\n",(0,s.jsxs)(n.p,{children:["The checkpoint/restart infrastructure is intended to enable users to recover from node failure or to comply with job timeouts on machines with job time limits. Thus the assumption is that restart will occur on the same or a similar machine with the same version of SST. SST's serialization uses C++ ",(0,s.jsx)(n.code,{children:"typeid"}),"s which are not guaranteed to be portable across architectures or compilers."]}),"\n",(0,s.jsx)(n.p,{children:"This guide describes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#support-status",children:"Support status"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#creating-a-checkpoint",children:"How to checkpoint"})," and ",(0,s.jsx)(n.a,{href:"#restarting-from-a-checkpoint",children:"restart a simulation"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#adding-checkpoint-support-to-element-libraries",children:"How to add checkpoint support to an element library"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#planned-improvements",children:"Planned improvements"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"support-status",children:"Support status"}),"\n",(0,s.jsx)(n.p,{children:"Select the version of SST you are using to see version-specific information. As support evolves, the repository information will be updated."}),"\n","\n",(0,s.jsxs)(a.A,{groupId:"release-version",children:[(0,s.jsxs)(l.A,{value:"15.0",label:"15.0 Release",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"As of SST 15.0, the serialization API for checkpoint is stable."})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel support:"})," All simulations, parallel and serial, can be checkpointed. Checkpoint and restart require the same parallelization (e.g., if checkpoint was generated with SST running two threads, SST must be restarted using two threads)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serialization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"SST_SER"})," macro replaces now deprecated ",(0,s.jsx)(n.code,{children:"ser &"})," and ",(0,s.jsx)(n.code,{children:"ser |"})," operators"]}),"\n",(0,s.jsxs)(n.li,{children:["A similar ",(0,s.jsx)(n.code,{children:"SST_SER_NAME"})," macro can take an alias name for mapping as well as options from the ",(0,s.jsx)(n.code,{children:"SerOption"})," enum"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SerOption"})," includes: ",(0,s.jsx)(n.code,{children:"SerOption::as_ptr"})," (replaced ",(0,s.jsx)(n.code,{children:"ser |"})," and ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"}),"), ",(0,s.jsx)(n.code,{children:"SerOption::as_ptr_elem"}),", ",(0,s.jsx)(n.code,{children:"SerOption::map_read_only"})," and ",(0,s.jsx)(n.code,{children:"SerOption::no_map"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API available: Component, SubComponent, ComponentExtension, Module, PortModule"}),"\n",(0,s.jsxs)(n.li,{children:["POD types (including ",(0,s.jsx)(n.code,{children:"std::string"}),") and pointers to POD types"]}),"\n",(0,s.jsxs)(n.li,{children:["All C++ standard containers, ",(0,s.jsx)(n.code,{children:"std::tuple"}),", ",(0,s.jsx)(n.code,{children:"std::pair"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Interfaces: ",(0,s.jsx)(n.code,{children:"StdMem"}),", ",(0,s.jsx)(n.code,{children:"SimpleNetwork"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checkpoint triggers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Simulated time, using the ",(0,s.jsx)(n.code,{children:"--checkpoint-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["Real (wall) time, using the ",(0,s.jsx)(n.code,{children:"--checkpoint-wall-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["On a signal, by using the ",(0,s.jsx)(n.code,{children:"--sigusr1=sst.rt.checkpoint"})," or ",(0,s.jsx)(n.code,{children:"--sigusr2=sst.rt.checkpoint"})," command line options."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Checkpoints are placed in a directory named ",(0,s.jsx)(n.code,{children:"<prefix>"}),' which is "checkpoint" by default. Use ',(0,s.jsx)(n.code,{children:"--checkpoint-prefix"})," to change the prefix. If the directory already exists, SST will create a new one named ",(0,s.jsx)(n.code,{children:"<prefix>_<num>"})," using a unique integer for ",(0,s.jsx)(n.code,{children:"<num>"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The checkpoint directory will be placed in SST's output directory. By default, this is the current working directory. It can be modified using ",(0,s.jsx)(n.code,{children:"--output-directory"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Within the directory, there is a subdirectory for each checkpoint which is named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"}),". The default ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," is ",(0,s.jsx)(n.code,{children:"<prefix>_<id>_<simulated_time>"})," where ",(0,s.jsx)(n.code,{children:"<id>"})," is an incrementing integer and ",(0,s.jsx)(n.code,{children:"<simulated_time>"})," is the simulated time at checkpoint. ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," name can be modified using ",(0,s.jsx)(n.code,{children:"--checkpoint-name-format"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Within the checkpoint subdirectory are a number of files.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Registry: A plaintext file named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>.sstcpt>"}),". This is the file to specify when restarting."]}),"\n",(0,s.jsxs)(n.li,{children:["Globals: A binary file containing global checkpoint data named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>_globals.bin"})]}),"\n",(0,s.jsxs)(n.li,{children:["Data files: One per thread/rank and named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>_<rank>_<thread>.bin"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]}),(0,s.jsx)(l.A,{value:"15.1",label:"15.1 Release",default:!0,children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel support:"})," All simulations, parallel and serial, can be checkpointed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API available: Component, SubComponent, ComponentExtension, Module"}),"\n",(0,s.jsxs)(n.li,{children:["POD types (including ",(0,s.jsx)(n.code,{children:"std::string"}),") and pointers to POD types"]}),"\n",(0,s.jsxs)(n.li,{children:["All C++ standard containers, ",(0,s.jsx)(n.code,{children:"std::tuple"}),", ",(0,s.jsx)(n.code,{children:"std::pair"}),", ",(0,s.jsx)(n.code,{children:"std::unique_ptr"}),", ",(0,s.jsx)(n.code,{children:"std::atomic"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Interfaces: ",(0,s.jsx)(n.code,{children:"StdMem"}),", ",(0,s.jsx)(n.code,{children:"SimpleNetwork"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checkpoint triggers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Simulated time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-sim-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["Real (wall) time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-wall-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["On a signal by using the ",(0,s.jsx)(n.code,{children:"--sigusr1=sst.rt.checkpoint"})," or ",(0,s.jsx)(n.code,{children:"--sigusr2=sst.rt.checkpoint"})," command line options."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Checkpoints are placed in a directory named ",(0,s.jsx)(n.code,{children:"<prefix>"}),' which is "checkpoint" by default. Use ',(0,s.jsx)(n.code,{children:"--checkpoint-prefix"})," to change the prefix. If the directory already exists, SST will create a new one named ",(0,s.jsx)(n.code,{children:"<prefix>_<num>"})," using a unique integer for ",(0,s.jsx)(n.code,{children:"<num>"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The checkpoint directory will be placed in SST's output directory. By default, this is the current working directory. It can be modified using ",(0,s.jsx)(n.code,{children:"--output-directory"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Within the directory, there is a subdirectory for each checkpoint which is named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"}),". The default ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," is ",(0,s.jsx)(n.code,{children:"<prefix>_<id>_<simulated_time>"})," where ",(0,s.jsx)(n.code,{children:"<id>"})," is an incrementing integer and ",(0,s.jsx)(n.code,{children:"<simulated_time>"})," is the simulated time at checkpoint. ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," name can be modified using ",(0,s.jsx)(n.code,{children:"--checkpoint-name-format"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Within the checkpoint subdirectory are a number of files.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Registry: A plaintext file named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>.sstcpt>"}),". This is the file to specify when restarting."]}),"\n",(0,s.jsxs)(n.li,{children:["Globals: A binary file containing global checkpoint data named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>_globals.bin"})]}),"\n",(0,s.jsxs)(n.li,{children:["Data files: One per thread/rank and named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>_<rank>_<thread>.bin"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Restart"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Parallel simulations can be restarted with the same parallelization (e.g., if checkpointed with 2 threads, restart with 2 threads) or in serial."}),"\n",(0,s.jsx)(n.li,{children:"Serial simulations can only be restarted in serial."}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"--load-checkpoint"})," flag is no longer required for SST to correctly detect a restart."]}),"\n"]}),"\n"]}),"\n"]})}),(0,s.jsx)(l.A,{value:"repo",label:"SST Repositories",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel support:"})," All simulations, parallel and serial, can be checkpointed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API available: Component, SubComponent, ComponentExtension, Module"}),"\n",(0,s.jsxs)(n.li,{children:["POD types (including ",(0,s.jsx)(n.code,{children:"std::string"}),") and pointers to POD types"]}),"\n",(0,s.jsxs)(n.li,{children:["All C++ standard containers, ",(0,s.jsx)(n.code,{children:"std::tuple"}),", ",(0,s.jsx)(n.code,{children:"std::pair"}),", ",(0,s.jsx)(n.code,{children:"std::unique_ptr"}),", ",(0,s.jsx)(n.code,{children:"std::atomic"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Interfaces: ",(0,s.jsx)(n.code,{children:"StdMem"}),", ",(0,s.jsx)(n.code,{children:"SimpleNetwork"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checkpoint triggers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Simulated time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-sim-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["Real (wall) time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-wall-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["On a signal by using the ",(0,s.jsx)(n.code,{children:"--sigusr1=sst.rt.checkpoint"})," or ",(0,s.jsx)(n.code,{children:"--sigusr2=sst.rt.checkpoint"})," command line options."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Checkpoints are placed in a directory named ",(0,s.jsx)(n.code,{children:"<prefix>"}),' which is "checkpoint" by default. Use ',(0,s.jsx)(n.code,{children:"--checkpoint-prefix"})," to change the prefix. If the directory already exists, SST will create a new one named ",(0,s.jsx)(n.code,{children:"<prefix>_<num>"})," using a unique integer for ",(0,s.jsx)(n.code,{children:"<num>"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The checkpoint directory will be placed in SST's output directory. By default, this is the current working directory. It can be modified using ",(0,s.jsx)(n.code,{children:"--output-directory"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Within the directory, there is a subdirectory for each checkpoint which is named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"}),". The default ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," is ",(0,s.jsx)(n.code,{children:"<prefix>_<id>_<simulated_time>"})," where ",(0,s.jsx)(n.code,{children:"<id>"})," is an incrementing integer and ",(0,s.jsx)(n.code,{children:"<simulated_time>"})," is the simulated time at checkpoint. ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," name can be modified using ",(0,s.jsx)(n.code,{children:"--checkpoint-name-format"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Within the checkpoint subdirectory are a number of files.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Registry: A plaintext file named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>.sstcpt>"}),". This is the file to specify when restarting."]}),"\n",(0,s.jsxs)(n.li,{children:["Globals: A binary file containing global checkpoint data named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>_globals.bin"})]}),"\n",(0,s.jsxs)(n.li,{children:["Data files: One per thread/rank and named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>_<rank>_<thread>.bin"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Restart"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Parallel simulations can be restarted with the same parallelization (e.g., if checkpointed with 2 threads, restart with 2 threads) or in serial."}),"\n",(0,s.jsx)(n.li,{children:"Serial simulations can only be restarted in serial."}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"--load-checkpoint"})," flag is no longer required for SST to correctly detect a restart."]}),"\n"]}),"\n"]}),"\n"]})})]}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-checkpoint",children:"Creating a checkpoint"}),"\n",(0,s.jsx)(n.p,{children:"The following instructions are valid for SST 14.1, 15.x and the repository."}),"\n",(0,s.jsx)(n.p,{children:'There are three options for triggering checkpoints: (1) on a simulation time interval, (2) on a wall (real) time interval, and (3) by sending SST a signal. A prefix to use for checkpoint directories and file names can also be given (default is "checkpoint").'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints at a simulation time interval on the command line"',children:'$ sst --checkpoint-sim-period=250us configuration.py\n$ sst --checkpoint-sim-period=250us --checkpoint-prefix="simulation" configuration.py\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints on a wall time interval on the command line"',children:'$ sst --checkpoint-wall-period=10m configuration.py\n$ sst --checkpoint-wall-period=10m --checkpoint-prefix="simulation" configuration.py\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoint when a SIGUSR1 or SIGUSR2 is sent to SST"',children:'$ sst --sigusr1=sst.rt.checkpoint configuration.py\n$ sst --sigusr2=sst.rt.checkpoint --checkpoint-prefix="simulation" configuration.py\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",metastring:'title="Any command line parameter can be set in the configuration file instead"',children:'import sst\n\nsst.setProgramOption("checkpoint-wall-period", "10m")    # Enable on a frequency in terms of wall time\nsst.setProgramOption("checkpoint-prefix", "simulation")  # Optional\n# sst.setProgramOption("checkpoint-sim-period", "250us") # Uncomment to enable on a frequency in terms of simulated time\n# sst.setProgramOption("sigusr1", "sst.rt.checkpoint")   # Uncomment to trigger a checkpoint when SST receives SIGUSR1\n# sst.setProgramOption("sigusr2", "sst.rt.checkpoint")   # Uncomment to trigger a checkpoint when SST receives SIGUSR2\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Simulated times must include units and SI-prefixes are valid. Wall times must be formatted as HH::MM::SS, MM::SS, or SS. ALternately, an integer with a time unit (",(0,s.jsx)(n.code,{children:"h"}),", ",(0,s.jsx)(n.code,{children:"m"}),", or ",(0,s.jsx)(n.code,{children:"s"}),") can be given."]}),"\n",(0,s.jsxs)(n.p,{children:["If checkpoints are enabled, SST creates a directory named ",(0,s.jsx)(n.code,{children:"<prefix>"})," in the SST output directory (unless set, the current working directory) where checkpoints will be placed. If a directory called ",(0,s.jsx)(n.code,{children:"<prefix>"})," already exists, SST will name the directory ",(0,s.jsx)(n.code,{children:"<prefix>_<num>"})," and increment ",(0,s.jsx)(n.code,{children:"<num>"}),' to the smallest integer that is a new directory name. (e.g., if "checkpoint_0" exists, SST will use "checkpoint_1"). An example directory structure is shown below.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"current working directory\n|--checkpoint\n    |--checkpoint_1_1000\n       |--checkpoint_1_1000.sstcpt\n       |--checkpoint_1_1000_globals.bin\n       |--checkpoint_1_1000_0_0.bin\n       |--checkpoint_1_1000_1_0.bin\n          |--checkpoint_2_2000\n          |--checkpoint_2_2000.sstcpt\n          |--checkpoint_2_2000_globals.bin\n          |--checkpoint_2_2000_0_0.bin\n          |--checkpoint_2_2000_1_0.bin\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Each generated checkpoint has a ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"})," which is ",(0,s.jsx)(n.code,{children:"<prefix>_<id>_<simulated_time>"})," by default. ",(0,s.jsx)(n.code,{children:"<id>"})," is a unique (incrementing) integer and ",(0,s.jsx)(n.code,{children:"<simulated_time>"})," is the simulated time when the checkpoint is created. Each checkpoint creates a subdirectory named ",(0,s.jsx)(n.code,{children:"<checkpoint_name>"}),'. In that subdirectory is a plaintext checkpoint registry file with the suffix ".sstcpt" and a number of global files (one per thread/rank). The registry file should be given to SST to restart the simulation.']}),"\n",(0,s.jsx)(n.h2,{id:"restarting-from-a-checkpoint",children:"Restarting from a checkpoint"}),"\n",(0,s.jsx)(n.p,{children:'To restart from a checkpoint pass the checkpoint file (with suffix ".sstcpt") instead of a configuration file.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ sst checkpoint/checkpoint_0_1000/checkpoint_0_1000.sstcpt\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["As of SST 15.1, the ",(0,s.jsx)(n.code,{children:"--load-checkpoint"})," flag is not required to restart from a checkpoint."]})}),"\n",(0,s.jsx)(n.h2,{id:"adding-checkpoint-support-to-element-libraries",children:"Adding checkpoint support to element libraries"}),"\n",(0,s.jsx)(n.p,{children:"Follow the steps below for each class in your element library. This will tell SST how to serialize your data structures. Depending on your object type, some steps may be skipped."}),"\n",(0,s.jsx)(n.p,{children:"Note: The same serialization engine is used both for the existing Event serialization in parallel simulations and for checkpointing. Thus, the steps are similar to the steps needed to make Events serializable. Like Event serialization, checkpointing requires data to be explicitly added to the serialization stream. Unlike Event serialization, checkpointing tracks and tags pointers to objects so that upon restart, a pointer will correctly point to the recreated object."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-inherit-from-the-serializable-class---non-element-classes-only",children:"Step 1: Inherit from the Serializable class - non-Element classes ONLY"}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"Skip this step if any of the following apply:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Your class is an SST Element or inherits from a class that is already serializable (examples: ",(0,s.jsx)(n.code,{children:"SST::Component"}),", ",(0,s.jsx)(n.code,{children:"SST::SubComponent"}),", ",(0,s.jsx)(n.code,{children:"SST::Module"}),", ",(0,s.jsx)(n.code,{children:"SST::Event"}),", etc)."]}),"\n",(0,s.jsx)(n.li,{children:"Your object is non-polymorphic"}),"\n",(0,s.jsxs)(n.li,{children:["You may optionally skip this step if your class is polymorphic but marked ",(0,s.jsx)(n.code,{children:"final"})," and you will only be serializing the class using its final type (that is, not a base class pointer). If you choose to skip this step, skip step 5 as well."]}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"For all other classes, inherit from SST's serializable class as shown."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="Inheriting from SST\'s serializable class"',children:"#include <sst/core/serialization/serializable.h>\n\nclass MyClass : public SST::Core::Serialization::serializable {\n    ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-change-clock-and-event-handler-functions",children:"Step 2: Change Clock and Event handler functions"}),"\n",(0,s.jsxs)(n.p,{children:["Change the handler type from ",(0,s.jsx)(n.code,{children:"Handler"})," to ",(0,s.jsx)(n.code,{children:"Handler2"})," and move the function pointer from the constructor parameters into the template parameters as shown. The old handler types are not serializable and will cause errors if you attempt to serialize them."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Clock handler without metadata\nSST::Clock::HandlerBase* old_handler = \n    new SST::Clock::Handler<ComponentName>(this, &ComponentName::HandlerFunction); // Not serializable\nSST::Clock::HandlerBase* new_handler = \n    new SST::Clock::Handler2<ComponentName, &ComponentName::HandlerFunction>(this); // Serializable\n\n// Clock handler with metadata\nSST::Clock::HandlerBase* old_handler = \n    new SST::Clock::Handler<ComponentName, uint32_t>(this, &ComponentName::HandlerFunction, 0); // Not serializable\nSST::Clock::HandlerBase* new_handler = \n    new SST::Clock::Handler2<ComponentName, &ComponentName::HandlerFunction, uint32_t>(this, 0); // Serializable\n\n// Event handler without metadata\nSST::Link::HandlerBase* old_handler = \n    new SST::Event::Handler<ComponentName>(this, &ComponentName::HandlerFunction); // Not serializable\nSST::Link::HandlerBase* new_handler = \n    new SST::Event::Handler2<ComponentName, &ComponentName::HandlerFunction>(this); // Serializable\n\n// Event handler with metadata\nSST::Event::HandlerBase* old_handler = \n    new SST::Event::Handler<ComponentName, uint32_t>(this, &ComponentName::HandlerFunction, 0); // Not serializable\nSST::Event::HandlerBase* new_handler = \n    new SST::Event::Handler2<ComponentName, &ComponentName::HandlerFunction, uint32_t>(this, 0); // Serializable\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-add-a-default-constructor",children:"Step 3: Add a default constructor"}),"\n",(0,s.jsx)(n.p,{children:"During deserialization, SST will call this constructor to create an object before populating its state from the checkpoint."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MyClass();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-add-a-serialization-function",children:"Step 4: Add a serialization function"}),"\n",(0,s.jsxs)(n.p,{children:["SST's serializer calls ",(0,s.jsx)(n.code,{children:"serialize_order"})," on elements during both serialization and deserialization.\nAdd this function to a public section of your class definition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title = "class.h"',children:"public:\n    // highlight-start\n    void serialize_order(SST::Core::Serialization::serializer& ser) override;\n    // highlight-end\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, if your class inherits from another, call that class's ",(0,s.jsx)(n.code,{children:"serialize_order"})," function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void MyClass:serialize_order(SST::Core::Serialization::serializer& ser)\n{\n    BaseClass::serialize_order(ser);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Last, add ",(0,s.jsx)(n.em,{children:"all"})," class data members that need to be saved to the checkpoint using the macros ",(0,s.jsx)(n.code,{children:"SST_SER"}),". ",(0,s.jsx)(n.strong,{children:"This was changed in the SST 15.0 Release and the API is now stable."}),"\nThe macro looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"SST_SER(var)        // No options needed\nSST_SER(var, opt)   // Options needed\nSST_SER_NAME(var, name, opt) // Provide an alias name to be used for mapping/interactive introspection\n"})}),"\n",(0,s.jsx)(n.p,{children:"The options determine how SST serializes the data member."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you are adding a data member that is not itself a pointer but other pointers to it exist and will be serialized, you will need to specify the option ",(0,s.jsx)(n.code,{children:"SerOption::as_ptr"}),". See note below. ",(0,s.jsxs)(n.strong,{children:["This replaces the ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"})," macro from SST 14.x."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Specifically for containers, if you have pointers to non-pointer elements in a container, use the option ",(0,s.jsx)(n.code,{children:"SerOption::as_ptr_elem"})," when serializing the container."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["In all other cases you may use ",(0,s.jsx)(n.code,{children:"SST_SER"})," without options."]}),"\n",(0,s.jsx)(n.li,{children:'Combine options using "|" if more than one option applies'}),"\n",(0,s.jsxs)(n.li,{children:["Additional options are available to control mapping (i.e., interactive introspection)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SerOption::map_read_only"}),": Do not allow a user to modify this object in an interactive console"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SerOption::no_map"}),": Do not serialize this object when mapping"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"SST_SER"})," macro also replaces the ",(0,s.jsx)(n.code,{children:"ser &"})," syntax used previously for event serialization."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note: The ",(0,s.jsx)(n.code,{children:"SerOption::as_ptr"})," and ",(0,s.jsx)(n.code,{children:"SerOption::as_ptr_elem"})," options work only for non-pointer data and add both the data to the checkpoint ",(0,s.jsx)(n.em,{children:"and"})," register pointers to the data. These operators are ",(0,s.jsx)(n.em,{children:"only"})," required if the object being serialized is not a pointer and you have a pointer elsewhere to the object that you intend to serialize as well. Using these macros allow a serialized pointer to correctly link itself to the serialized data. These options cause the serializer to consume both extra space in the checkpoint and add a (small) overhead during serialization. The non-pointer data must serialize before any pointers to the data are serialized, otherwise the deserialized data will not be correct."]}),"\n",(0,s.jsx)(n.p,{children:"By way of example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/* Class variables */\n// \nSST::Link* link;\nSST::Output* output;\nSST::TimeConverter tc;\nint count;\nstd::string name;\nstd::vector<uint32_t> nums;\nstd::string pointedToObj;\nstd::string* pointer = &pointedToObj;\n\n/* Serialization function */\nvoid serialize_order(SST::Core::Serialization::serializer& ser) override\n{\n    BaseClass::serialize_order(ser); // Assuming this class has a base class called 'BaseClass'. ALWAYS call the base class's serialize_order function prior to adding data from this class.\n    SST_SER(link);\n    SST_SER(output);\n    SST_SER(tc);\n    SST_SER(count);\n    SST_SER(name);\n    SST_SER(nums);\n    SST_SER(pointedToObj, SerOption::as_ptr); // Track a pointer to this object\n    SST_SER(pointer);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Many data types are supported natively in SST's serialization libraries. These include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["POD types including ",(0,s.jsx)(n.code,{children:"std::string"})]}),"\n",(0,s.jsxs)(n.li,{children:["All standard containers (",(0,s.jsx)(n.code,{children:"std::array"}),", ",(0,s.jsx)(n.code,{children:"std::map"}),", ",(0,s.jsx)(n.code,{children:"std::unordered_map"}),", ",(0,s.jsx)(n.code,{children:"std::vector"}),", etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:["Standard types: ",(0,s.jsx)(n.code,{children:"std::atomic"}),", ",(0,s.jsx)(n.code,{children:"std::pair"}),", ",(0,s.jsx)(n.code,{children:"std::tuple"}),", ",(0,s.jsx)(n.code,{children:"std::unique_ptr"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n",(0,s.jsx)(n.li,{children:"Pointers to serializable types"}),"\n",(0,s.jsxs)(n.li,{children:["C-style arrays, using ",(0,s.jsx)(n.code,{children:"SST_SER(SST::Core::Serialization::array(arr, size))"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"arr"})," is the array to serialize and ",(0,s.jsx)(n.code,{children:"size"})," is the number of elements in the array"]}),"\n",(0,s.jsxs)(n.li,{children:["Serialization uses ",(0,s.jsx)(n.code,{children:"new"})," rather than ",(0,s.jsx)(n.code,{children:"malloc"}),". If using malloc/free, serialize the array manually instead."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that non-polymorphic classes are special cases in the serialization library. Because there is no way to reference the class with a different type, there is no need to inherit from ",(0,s.jsx)(n.code,{children:"Serializable"})," or call the ",(0,s.jsx)(n.code,{children:"ImplementSerializable"})," macro (step 5 below). You may simply add a ",(0,s.jsx)(n.code,{children:"serialize_order()"})," function to the class as listed above and the class will be compatible with the serializer."]}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, a polymorphic class that is ",(0,s.jsx)(n.code,{children:"final"})," and will be serialized as its final type (not using a base class pointer), can be serialized without inheriting from ",(0,s.jsx)(n.code,{children:"Serializable"})," because the serializer can identify the correct type of the class."]}),"\n",(0,s.jsx)(n.h3,{id:"step-5-add-the-appropriate-serialization-macro",children:"Step 5: Add the appropriate serialization macro"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"You can skip this step if your class is non-polymorphic or is final and will be serialized as its final type."})}),"\n",(0,s.jsxs)(n.p,{children:["Classes that inherit from ",(0,s.jsx)(n.code,{children:"SST::Core::Serialization::serializable"})," must call the ",(0,s.jsx)(n.code,{children:"ImplementSerializable"})," macro with their class name. ",(0,s.jsx)(n.strong,{children:"Note that the macro changes the class access specifier."})," Be careful where you place it, place an access specifier directly after the macro, or put the macro at the end of the class definition."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ImplementSerializable"})," leaves the class in a ",(0,s.jsx)(n.code,{children:"private"})," section"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ImplementVirtualSerializable"})," leaves the class in a ",(0,s.jsx)(n.code,{children:"public"})," section"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MyClass : public SST::Component\n{\npublic:\n    // Class functions\n    \n    ImplementSerializable(MyClass)\npublic: // Make sure to restore the specifier if needed\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Pure virtual classes must use ",(0,s.jsx)(n.code,{children:"ImplementVirtualSerializable"})," instead of ",(0,s.jsx)(n.code,{children:"ImplementSerializable"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"step-6-document-that-the-element-is-checkpointable",children:"Step 6: Document that the element is checkpointable"}),"\n",(0,s.jsxs)(n.p,{children:["If you implemented serialization for an element (component, subcomponent, etc.), then add the following checkpointable macro to the element class header. The macro takes no arguments. A future enhancement will allow elements to give dynamic responses to whether they are checkpointable, such as when a component can be checkpointed if configured one way but not another. For now, the macro is only used by ",(0,s.jsx)(n.code,{children:"sst-info"})," to report whether an element has checkpoint support."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"SST_ELI_IS_CHECKPOINTABLE()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"put-it-together-an-example",children:"Put it together: An example"}),"\n",(0,s.jsx)(n.p,{children:"Here is an example of what this looks like. Note we have removed all but the relevant-to-checkpointing pieces of the class (ELI macros, most class functions, etc.)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="example.h"',children:"#ifndef SST_EXAMPLE_CHECKPOINT_HEADER\n#define SST_EXAMPLE_CHECKPOINT_HEADER\n\n#include <sst/core/component.h>\n#include <sst/core/link.h>\n#include <sst/core/rng/marsaglia.h>\n\nnamespace SST {\nnamespace ExampleSSTLibrary {\n\nclass example : public SST::Component { // Step 1 - SST::Component already inherits from Serializable\npublic:\n    // ELI macros would be here\n    //highlight-next-line\n    SST_ELI_IS_CHECKPOINTABLE()\n    \n    // Public class members would be here\n\n    //highlight-start\n    // Step 3 - Add default constructor, serialize_order, and serializable macro\n    example();\n    void serialize_order(SST::Core::Serialization::serializer& ser) override;\n    ImplementSerializable(SST::ExampleSSTLibrary::example)\n    //highlight-end\nprivate:\n    // Private member functions would be here\n\n    // Private data members - to be serialized in serialize_order\n    int64_t param0;\n    uint32_t param1;\n    std::string param2;\n    Statistic<uint64_t> stat;\n    SST::Output* out;\n    std::vector<std::string> stringVec;\n    SST::Link* link;\n    RNG::Random* rng;\n};\n\n} } // End namespaces\n#endif\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="example.cc"',children:"// Rest of class defined here\n\n// highlight-start\nexample::example() : Component() {}\n\nvoid example::serialize_order(SST::Core::Serialization::serializer& ser) {\n    // MUST call parent's serialize_order FIRST\n    Component::serialize_order(ser);\n\n    // Now, serialize everything we need to save\n    SST_SER(param0)\n    SST_SER(param1)\n    SST_SER(param2)\n    SST_SER(stat)\n    SST_SER(out)\n    SST_SER(stringVec)\n    SST_SER(link)\n    SST_SER(rng)\n}\n//highlight-end\n"})}),"\n",(0,s.jsx)(n.h2,{id:"problems-and-solutions",children:"Problems and solutions"}),"\n",(0,s.jsx)(n.h3,{id:"serializing-uninitialized-pointers",children:"Serializing uninitialized pointers"}),"\n",(0,s.jsxs)(n.p,{children:["The serializer will correctly serialize ",(0,s.jsx)(n.code,{children:"nullptr"})," but uninitialized pointers will likely cause problems in both checkpoint and/or restart. Ensure pointers are initialized or set to ",(0,s.jsx)(n.code,{children:"nullptr"})," prior to serialization."]}),"\n",(0,s.jsx)(n.h3,{id:"lambdas",children:"Lambdas"}),"\n",(0,s.jsx)(n.p,{children:"Lambdas cannot be serialized."}),"\n",(0,s.jsx)(n.h3,{id:""}),"\n",(0,s.jsx)(n.h2,{id:"advanced-notes-on-serialization",children:"Advanced notes on serialization"}),"\n",(0,s.jsxs)(n.p,{children:['While many types are serializable already within SST\'s serialization engine, complex types may require additional work. For example, if the default serialization of a type does not work or you need to implement a complex serialization, you can use the process outlined above but handle serialization and deserialization explicitly as needed (see "Approach 1" below). In other cases, the method outlined above may not work at all -- complex inheritance patterns for example might make inheriting from ',(0,s.jsx)(n.code,{children:"Serializable"}),' challenging or impossible. In this case, you can manually handle the entirety of serialization yourself as described in "Approach 2" below.']}),"\n",(0,s.jsx)(n.h3,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.em,{children:["See the ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/serialization/overview",children:"serialization documentation"})," in the Core API for more detail on serialization."]}),"\nCheckpoint uses three stages of serialization (a fourth, MAP, exists for interactive debugging). They are: (1) SIZER, (2) PACK, and (3) UNPACK. When writing a checkpoint, SIZER and PACK are used to serialize the state of simulation and write it to file. During restart, UNPACK is used to deserialize the checkpointed data. In each stage, the serializer will call ",(0,s.jsx)(n.code,{children:"serialize_order"})," on each object. Thus, if the default serialization does not work for a particular type, a custom serialization can be implemented by querying the serializer's mode in the ",(0,s.jsx)(n.code,{children:"serialize_order"})," function and taking the appropriate action to serialize the type. During ",(0,s.jsx)(n.code,{children:"SIZER"}),", the ",(0,s.jsx)(n.code,{children:"serialize_order"})," function should add the size of the data to be serialized using the ",(0,s.jsx)(n.code,{children:"SST_SER"})," macro. During ",(0,s.jsx)(n.code,{children:"PACK"}),", ",(0,s.jsx)(n.code,{children:"serialize_order"})," should add the data to be added to the serialization stream using ",(0,s.jsx)(n.code,{children:"SST_SER"})," ",(0,s.jsx)(n.em,{children:"with the same options"})," Finally, during ",(0,s.jsx)(n.code,{children:"UNPACK"}),", ",(0,s.jsx)(n.code,{children:"serialize_order"})," should read the serialized data from the stream, again using ",(0,s.jsx)(n.code,{children:"SST_SER"}),". The same macro options should be used in all three stages. The fourth stage, ",(0,s.jsx)(n.code,{children:"MAP"}),", should be defined in the case switch statements and can be left empty."]}),"\n",(0,s.jsx)(n.h3,{id:"approach-1-handle-serialization-phases-differently",children:"Approach 1: Handle serialization phases differently"}),"\n",(0,s.jsxs)(n.p,{children:["You may find that for a particular data structure, you need to handle serialization differently depending on whether the class is being serialized or deserialized. To support this, the serialization mode can be queried using ",(0,s.jsx)(n.code,{children:"ser.mode()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that manual serialization for ",(0,s.jsx)(n.code,{children:"SIZE"})," and ",(0,s.jsx)(n.code,{children:"PACK"})," should be typically be identical, as SST uses the former to determine buffer sizes for the latter."]}),"\n",(0,s.jsxs)(n.h4,{id:"example-serializing-a-c-style-array-that-uses-mallocfree",children:["Example: Serializing a C-style array that uses ",(0,s.jsx)(n.code,{children:"malloc"}),"/",(0,s.jsx)(n.code,{children:"free"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SST::DiscreteDistribution"})," distribution contains four data members."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"Random* baseDistrib;   // Pointer to a distribution\nbool deteleDistrib;    // Whether the distribution should be deleted in the destructor\ndouble* probabilities; // Discrete probability, C-style array\nuint32_t probCount;    // Size of the probabilities array\n"})}),"\n",(0,s.jsxs)(n.p,{children:["While most of the members can be serialized using default serialization, the ",(0,s.jsx)(n.code,{children:"probabilities"})," array is a C-style array that uses ",(0,s.jsx)(n.code,{children:"malloc"})," to allocate. The default serializer for C-style arrays uses ",(0,s.jsx)(n.code,{children:"new"}),". In the interest of not mixing ",(0,s.jsx)(n.code,{children:"malloc"}),"/",(0,s.jsx)(n.code,{children:"free"})," and ",(0,s.jsx)(n.code,{children:"new"}),"/",(0,s.jsx)(n.code,{children:"delete"}),", ",(0,s.jsx)(n.code,{children:"DiscreteDistribution::serialize_order"})," manually handles the ",(0,s.jsx)(n.code,{children:"probabilities"})," array as shown below so that it can correctly allocate ",(0,s.jsx)(n.code,{children:"probabilities"})," during deserialization."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void serialize_order(SST::Core::Serialization::serializer& ser) override\n{\n    SST_SER(baseDistrib);\n    SST_SER(deleteDistrib);\n    SST_SER(probCount);\n\n    // When deserializing, first allocate the probabilities array using malloc\n    // and the size `probCount` which was deserialized above.\n    if ( ser.mode() == SST::Core::Serialization::serializer::UNPACK ) {\n        probabilities = (double*)malloc(sizeof(double) * probCount);\n    }\n\n    // Serialize/deserialize each array element\n    for ( uint32_t i = 0; i < probCount; i++ ) {\n        SST_SER(probabilities[i]);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"example-serializing-a-type-as-a-different-type",children:"Example: Serializing a type as a different type"}),"\n",(0,s.jsxs)(n.p,{children:["The snippet below shows how ",(0,s.jsx)(n.code,{children:"SST::UnitAlgebra"})," is serialized. UnitAlgebra is not a polymorphic class so it only implements ",(0,s.jsx)(n.code,{children:"serialize_order"}),"; it does not inherit from ",(0,s.jsx)(n.code,{children:"Serializable"}),'. UnitAlgebra objects have two components, a "unit" struct that contains a numerator (string) and denominator (string) and a "value" object that is a custom type called ',(0,s.jsx)(n.code,{children:"decimal_fixedpoint"}),"."]}),"\n",(0,s.jsx)(n.p,{children:'The "unit" struct consists of strings and can be serialized using default serialization. However, "decimal_fixedpoint" is more complicated. To simplify the serialization and because decimal_fixedpoint can already be converted between strings and numeric values, the serialization function serializes "value" as a string. When "value" is deserialized, it gets converted back into a "decimal_fixedpoint".'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void serialize_order(SST::Core::Serialization::serializer& ser)\n{\n    SST_SER(unit.numerator);\n    SST_SER(unit.denominator);\n\n    switch ( ser.mode() ) {\n        case SST::Core::Serialization::serializer::SIZER:\n        case SST::Core::Serialization::serializer::PACK:\n        {\n            // Convert value to a string with full precision\n            std::string s = value.toString(0); \n            SST_SER(s);\n            break;\n        }\n        case SST::Core::Serialization::serializer::UNPACK:\n        {\n            // Deserialize value as a string\n            std::string s;\n            SST_SER(s);\n            // Re-initialize value using the deserialized string\n            value = sst_big_num(s);\n            break;\n        }\n        case SST::Core::Serialization::serializer::MAP:\n        {\n            // Code for representing the object in a debug map \n            // UnitAlgebra does this separately so case is empty\n            break;\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"approach-2-manually-implementing-serialization-support",children:"Approach 2: Manually implementing serialization support"}),"\n",(0,s.jsxs)(n.p,{children:["If a class cannot easily inherit from Serializable and does not meet any of the restrictions for avoiding it (non-polymorphic or polymorphic but final and serialized as its final type), a custom ",(0,s.jsx)(n.code,{children:"serialize_impl"})," template class can be implemented instead. You must handle all options passed to the serializer manually."]}),"\n",(0,s.jsx)(n.h2,{id:"planned-improvements",children:"Planned improvements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Add ability to query if an element supports checkpoint"}),"\n",(0,s.jsx)(n.li,{children:"Options to limit number of checkpoints kept"}),"\n",(0,s.jsxs)(n.li,{children:["Additional flexibility when restarting SST including ability to change parallelization and re-partition components.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The current implementation allows overriding command line options that govern output such as ",(0,s.jsx)(n.code,{children:"--verbose"})," and ",(0,s.jsx)(n.code,{children:"--output-directory"})," when restarting."]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},65537:(e,n,i)=>{i.d(n,{A:()=>k});var t=i(96540),s=i(18215),r=i(65627),a=i(56347),l=i(50372),o=i(30604),c=i(11861),d=i(78749);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((({props:{value:e,label:n,attributes:i,default:t}})=>({value:e,label:n,attributes:i,default:t})))}(i);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function u({value:e,tabValues:n}){return n.some((n=>n.value===e))}function m({queryString:e=!1,groupId:n}){const i=(0,a.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,o.aZ)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})}),[s,i])]}function x(e){const{defaultValue:n,queryString:i=!1,groupId:s}=e,r=p(e),[a,o]=(0,t.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!u({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:r}))),[c,h]=m({queryString:i,groupId:s}),[x,j]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,s]=(0,d.Dv)(n);return[i,(0,t.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:s}),S=(()=>{const e=c??x;return u({value:e,tabValues:r})?e:null})();(0,l.A)((()=>{S&&o(S)}),[S]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!u({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),h(e),j(e)}),[h,j,r]),tabValues:r}}var j=i(9136);const S={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=i(74848);function g({className:e,block:n,selectedValue:i,selectValue:t,tabValues:a}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,r.a_)(),c=e=>{const n=e.currentTarget,s=l.indexOf(n),r=a[s].value;r!==i&&(o(n),t(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;n=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;n=l[i]??l[l.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:a.map((({value:e,label:n,attributes:t})=>(0,f.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...t,className:(0,s.A)("tabs__item",S.tabItem,t?.className,{"tabs__item--active":i===e}),children:n??e},e)))})}function b({lazy:e,children:n,selectedValue:i}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===i));return e?(0,t.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function y(e){const n=x(e);return(0,f.jsxs)("div",{className:(0,s.A)("tabs-container",S.tabList),children:[(0,f.jsx)(g,{...n,...e}),(0,f.jsx)(b,{...n,...e})]})}function k(e){const n=(0,j.A)();return(0,f.jsx)(y,{...e,children:h(e.children)},String(n))}},79329:(e,n,i)=>{i.d(n,{A:()=>a});i(96540);var t=i(18215);const s={tabItem:"tabItem_Ymn6"};var r=i(74848);function a({children:e,hidden:n,className:i}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(s.tabItem,i),hidden:n,children:e})}}}]);