"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[71102],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}},40338:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core/realtime/simulationSignalShutdown","title":"simulationSignalShutdown","description":"Inform the simulation that it should end when any pending actions finish executing. The abnormal parameter controls whether the shutdown is an \\"emergency\\" and SST should immediately terminate or whether it should continue to its normal complete/finish/destruction stages.","source":"@site/../docs/core/realtime/simulationSignalShutdown.md","sourceDirName":"core/realtime","slug":"/core/realtime/simulationSignalShutdown","permalink":"/sst-docs/docs/core/realtime/simulationSignalShutdown","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/realtime/simulationSignalShutdown.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1729787241000,"frontMatter":{"title":"simulationSignalShutdown"},"sidebar":"core","previous":{"title":"simulationPrintStatus","permalink":"/sst-docs/docs/core/realtime/simulationPrintStatus"},"next":{"title":"Serialization","permalink":"/sst-docs/docs/core/serialization/overview"}}');var s=n(74848),o=n(28453);const a={title:"simulationSignalShutdown"},r=void 0,l={},c=[{value:"Parameters",id:"parameters",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function d(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"void simulationSignalShutdown(bool abnormal);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Inform the simulation that it should end when any pending actions finish executing. The ",(0,s.jsx)(t.code,{children:"abnormal"}),' parameter controls whether the shutdown is an "emergency" and SST should immediately terminate or whether it should continue to its normal complete/finish/destruction stages.']}),"\n",(0,s.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"abnormal"})," (bool) Whether to terminate immediately (true) or proceed to the end of simulation stages (false)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(t.p,{children:"The exit-after action causes SST to end simulation after a certain amount of time has passed."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'void\nExitCleanRealTimeAction::execute()\n{\n    Output   sim_output = getSimulationOutput();\n    RankInfo rank       = getRank();\n    \n    sim_output.output("EXIT-AFTER TIME REACHED; SHUTDOWN (%u,%u)!\\n", rank.rank, rank.thread);\n    sim_output.output("# Simulated time:                  %s\\n", getElapsedSimTime().toStringBestSI().c_str());\n    //highlight-next-line\n    simulationSignalShutdown(false); /* Not an abnormal shutdown */\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/realtimeAction.h>\n"})})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);