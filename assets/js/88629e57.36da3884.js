"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[70865],{10839:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/iface_stdmem_implementation_example-c73cf14c2aff50c94e6542c86ce54071.png"},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(96540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}},64688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"core/iface/StandardMem/class","title":"SST::Interfaces::StandardMem","description":"The StandardMem interface defines an interface between a core or other compute unit (i.e., \\"endpoint\\") and a memory system. A memory system library should define a SubComponent that implements the StandardMem interface. Components  can then load that StandardMem SubComponent to interface with the memory system library. As an example, in the picture below, a CPU endpoint Component loads a StandardMemInterface SubComponent. The interface has an SST::Link into the rest of the memory system.","source":"@site/../docs/core/iface/StandardMem/class.md","sourceDirName":"core/iface/StandardMem","slug":"/core/iface/StandardMem/class","permalink":"/sst-docs/docs/core/iface/StandardMem/class","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/StandardMem/class.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1702928554000,"frontMatter":{"title":"SST::Interfaces::StandardMem"},"sidebar":"core","previous":{"title":"Request","permalink":"/sst-docs/docs/core/iface/SimpleNetwork/Request"},"next":{"title":"constructor","permalink":"/sst-docs/docs/core/iface/StandardMem/constructor"}}');var a=n(74848),r=n(28453);const i={title:"SST::Interfaces::StandardMem"},o=void 0,d={},c=[{value:"Types",id:"types",level:2},{value:"Implementing a StandardMem interface",id:"implementing-a-standardmem-interface",level:2},{value:"Interfacing with a StandardMem interface",id:"interfacing-with-a-standardmem-interface",level:2},{value:"What the interface does not do",id:"what-the-interface-does-not-do",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:'The StandardMem interface defines an interface between a core or other compute unit (i.e., "endpoint") and a memory system. A memory system library should define a SubComponent that implements the StandardMem interface. Components  can then load that StandardMem SubComponent to interface with the memory system library. As an example, in the picture below, a CPU endpoint Component loads a StandardMemInterface SubComponent. The interface has an SST::Link into the rest of the memory system.'}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"StdMem implementation example",src:n(10839).A+"",width:"2378",height:"1705"})}),"\n",(0,a.jsxs)(t.p,{children:["To send requests into the memory system, the CPU uses the interface's ",(0,a.jsx)(t.a,{href:"send",children:(0,a.jsx)(t.code,{children:"send"})})," function and passes a request as one of the ",(0,a.jsx)(t.a,{href:"req/class",children:"StandardMem::Request"})," types. The interface converts incoming requests into an implementation-specific SST::Event type using converters which in turn belong to a derived instance of the ",(0,a.jsx)(t.a,{href:"reqconverter",children:"StandardMem::RequestConverter"})," class. These events can then be sent among the memory (or any other compatible) components as shown in the cloud below. As the StandardMem interface is part of the memory system component space, it should have knowledge of these library-internal event types. Finally, when the interface needs to pass an event to the CPU, it passes the event as a StandardMem::Request using a ",(0,a.jsx)(t.a,{href:"handler",children:"callback function"})," (",(0,a.jsx)(t.code,{children:"StdMemCallbackHandler"}),"). Finally, the CPU implements a class based on the StandardMem::RequestHandler class (",(0,a.jsx)(t.code,{children:"derivedRequestHandlerClassInstance"}),") that provides visitor functions for various StandardMem::Request types. In hte callback function, the CPU invokes this visitor class to allow requests to be handled according to type."]}),"\n",(0,a.jsx)(t.p,{children:"The image describes a concrete implementation of the interface and its use in a system. It is also valid for the StandardMem interface to interact with a memory system via SubComponents rather than Links, or for the endpoint to be a SubComponent rather than a Component. Likewise, the CPU in the example could be replaced by any other entity that needs to interact with a memory system."}),"\n",(0,a.jsx)(t.h2,{id:"types",children:"Types"}),"\n",(0,a.jsx)(t.p,{children:"StandardMem defines several types."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Addr"})," (uint64_t) Represents a memory address."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"req/class",children:(0,a.jsx)(t.strong,{children:"Request"})})," A class representing a memory system request or response, for example a Read, Write, or Acknowledgement. The Request class is a base class for a number of included request and response types."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"reqconverter",children:(0,a.jsx)(t.strong,{children:"RequestConverter"})})," A class to convert a Request to an SST::Event* derived type"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"reqhandler",children:(0,a.jsx)(t.strong,{children:"RequestHandler"})})," A class to handle a Request according to type"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"handler",children:(0,a.jsx)(t.strong,{children:"Handler"})})," A function to notify the endpoint when the StandardMem interface receives a response"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"implementing-a-standardmem-interface",children:"Implementing a StandardMem interface"}),"\n",(0,a.jsx)(t.p,{children:"In addition to implementing the functions described in this memory interface documentation, StandardMem interfaces must also perform the following tasks."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Respond to every Request that requires a Response"})}),"\n",(0,a.jsxs)(t.p,{children:["Each Request has a function, ",(0,a.jsx)(t.a,{href:"??",children:(0,a.jsx)(t.code,{children:"needsResponse"})})," that returns whether a Response is required. StandardMem interfaces must eventually respond to all requests that require a Response."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Additionally, the StandardMem interface supports some features that are not required to be supported but may be useful."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Trace memory requests"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"StandardMem::Request events can be tagged as traceable. Interfaces, and memory component libraries, can use these fields to generate trace information about tagged Requests."}),"\n",(0,a.jsx)(t.h2,{id:"interfacing-with-a-standardmem-interface",children:"Interfacing with a StandardMem interface"}),"\n",(0,a.jsxs)(t.p,{children:["Components that load a StandardMem SubComponent, called an ",(0,a.jsx)(t.em,{children:"endpoint"})," in the rest of this documentaiton, must support the following actions."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Facilitate SST lifecycle for the SubComponent"})}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["This means that the endpoint must call ",(0,a.jsx)(t.code,{children:"init()"}),", ",(0,a.jsx)(t.code,{children:"setup()"}),", ",(0,a.jsx)(t.code,{children:"complete()"}),", and ",(0,a.jsx)(t.code,{children:"finish()"})," on the interface during its own respective functions."]}),"\n",(0,a.jsx)(t.h2,{id:"what-the-interface-does-not-do",children:"What the interface does not do"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Make any ordering guarantee"})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"It is up to particular memory system implementations to define the ordering semantics they support with respect to the order in which requests are accepted and responses are returned. StandardMem itself does not impose any ordering."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.strong,{children:"Impose addressing or alignment restrictions"})}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["While the interface provides functions such as ",(0,a.jsx)(t.code,{children:"getLineSize"})," for convenience, the API itself does not impose any rules around access alignment, access sizes, etc. Particular implementations of the interface may have their own implementation-specific restrictions (e.g., that a cache access cannot span multiple cache lines) and should have some mechanism for notifying users of the restrictions (documentation, error-checking, etc.)."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);