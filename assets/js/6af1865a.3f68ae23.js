"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[10911],{240:(e,r,n)=>{n.d(r,{A:()=>a});const a=n.p+"assets/images/region_parameters-568ff10965ecf59a20157026aef8856a.png"},28453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var a=n(96540);const s={},t=a.createContext(s);function i(e){const r=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(t.Provider,{value:r},e.children)}},98982:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>m,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"elements/memHierarchy/addressing","title":"Addressing","description":"MemHierarchy operates on a physical address space in which components can map either contiguous memory regions or can map regions interleaved at regular intervals. When units are required, be specific with whether you intend base-10 (e.g., GB) or base-2 (e.g., GiB).","source":"@site/../docs/elements/memHierarchy/addressing.md","sourceDirName":"elements/memHierarchy","slug":"/elements/memHierarchy/addressing","permalink":"/sst-docs/docs/elements/memHierarchy/addressing","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/memHierarchy/addressing.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"Addressing"}}');var s=n(74848),t=n(28453);const i={title:"Addressing"},o=void 0,m={},d=[{value:"Example: Consecutive mapping",id:"example-consecutive-mapping",level:3},{value:"Example: Interleaved mapping",id:"example-interleaved-mapping",level:3},{value:"SI Units and base-10 vs base-2",id:"si-units-and-base-10-vs-base-2",level:2}];function l(e){const r={code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.p,{children:"MemHierarchy operates on a physical address space in which components can map either contiguous memory regions or can map regions interleaved at regular intervals. When units are required, be specific with whether you intend base-10 (e.g., GB) or base-2 (e.g., GiB)."}),"\n",(0,s.jsx)(r.p,{children:"These parameters are used across components to define memory regions:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"addr_range_start"})," The first (smallest) address that maps to this component. Default is 0."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"addr_range_end"})," The largest address that maps to this component. Default is ",(0,s.jsx)(r.code,{children:"uint64_t-1"}),"."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"interleave_size"})," The size of each interleaved chunk that is mapped to this component."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"interleave_step"})," The distance between starting addresses of consecutive chunks that are mapped to this component"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["In the picture, these parameters are shown for interleaving chunks of addresses across two components.\n",(0,s.jsx)(r.img,{alt:"Parameters to interleave memory addresses across two components",src:n(240).A+"",width:"2685",height:"728"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Restrictions:"})," For any request that arrives at a component, that component must always be able to identify a single next-level component to forward the request to.\nTherefore:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["A physical address may only map to ",(0,s.jsx)(r.em,{children:"one"})," component within a single shared level of the memory hierarchy (shared cache, directory, memory)."]}),"\n",(0,s.jsx)(r.li,{children:"Holes in address interleavings are allowed as long as the addresses are unused."}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"example-consecutive-mapping",children:"Example: Consecutive mapping"}),"\n",(0,s.jsx)(r.p,{children:"This input config snippet shows three memory controllers dividing 4GiB of memory space among them. There is no interleaving so those parameters are not used. Note that each address range is inclusive and does not overlap with the next controller's range."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-py",children:'memory0 = sst.Component("memory0", "memHierarchy.MemController")\nmemory1 = sst.Component("memory1", "memHierarchy.MemController")\nmemory2 = sst.Component("memory2", "memHierarchy.MemController")\n\n# Memory 0 addresses 0-1GiB\nmemory0.addParam("addr_range_start", 0)          # 0GiB\nmemory0.addParam("addr_range_end", 1073741823)   # 1GiB - 1\n# Memory 1 addresses 1-3GiB\nmemory1.addParam("addr_range_start", 1073741824) # 1GiB\nmemory1.addParam("addr_range_end", 3221225471)   # 3GiB - 1\n# Memory 2 addresses 3-4GiB\nmemory2.addParam("addr_range_start", 3221225472) # 3GiB\nmemory2.addParam("addr_range_end", 4294967295)   # 4GiB - 1\n'})}),"\n",(0,s.jsx)(r.h3,{id:"example-interleaved-mapping",children:"Example: Interleaved mapping"}),"\n",(0,s.jsxs)(r.p,{children:["This example shows how 4GiB of memory might be striped evenly across three memory controllers at 1MiB granularities. ",(0,s.jsx)(r.code,{children:"addr_range_end"})," is the same for all controllers because the interleaving prevents the three controllers from trying to map the same chunks of memory."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-py",children:'memory0 = sst.Component("memory0", "memHierarchy.MemController")\nmemory1 = sst.Component("memory1", "memHierarchy.MemController")\nmemory2 = sst.Component("memory2", "memHierarchy.MemController")\n\n# Memory 0 addresses 0-1GiB\nmemory0.addParam("addr_range_start", 0)        # 0MiB\nmemory0.addParam("addr_range_end", 4294967295) # End interleaving at 4GiB - 1\nmemory0.addParam("interleave_size", "1MiB")     # Each chunk mapped to this controller is 1MiB\nmemory0.addParam("interleave_step", "3MiB")     # This controller maps addresses at 3MiB intervals\n\n# Memory 1 addresses 1-3GiB\nmemory1.addParam("addr_range_start", 1048576) # 1MiB\nmemory1.addParam("addr_range_end", 4294967295)   # End interleaving at 4GiB - 1\nmemory1.addParam("interleave_size", "1MiB")     # Each chunk mapped to this controller is 1MiB\nmemory1.addParam("interleave_step", "3MiB")     # This controller maps addresses at 3MiB intervals\n\n# Memory 2 addresses 3-4GiB\nmemory2.addParam("addr_range_start", 2097152)  # 2MiB\nmemory2.addParam("addr_range_end", 4294967295) # End interleaving at 4GiB - 1\nmemory2.addParam("interleave_size", "1MiB")     # Each chunk mapped to this controller is 1MiB\nmemory2.addParam("interleave_step", "3MiB")     # This controller maps addresses at 3MiB intervals\n\n'})}),"\n",(0,s.jsxs)(r.p,{children:["For components that accept these addressing parameters, there is no requirement that addresses be striped uniformly. For example, one could stripe the first 3GiB of the address space to controllers ",(0,s.jsx)(r.code,{children:"memory0"})," and ",(0,s.jsx)(r.code,{children:"memory1"})," with 2MiB chunks mapping to ",(0,s.jsx)(r.code,{children:"memory0"})," and 1MiB chunks mapping to ",(0,s.jsx)(r.code,{children:"memory1"})," and then assign the final 1GiB chunk to ",(0,s.jsx)(r.code,{children:"memory2"})," in a contiguous mapping as shown below."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-py",children:'memory0 = sst.Component("memory0", "memHierarchy.MemController")\nmemory1 = sst.Component("memory1", "memHierarchy.MemController")\nmemory2 = sst.Component("memory2", "memHierarchy.MemController")\n\n# Divide the first 3GiB of memory space into 3MiB chunks\n# Memory 0 maps the first 2MiB of each chunk\nmemory0.addParam("addr_range_start", 0)\nmemory0.addParam("addr_range_end", 3221225471)\n# Memory 1 maps the final 1MiB of each chunk\nmemory1.addParam("addr_range_start", 1073741824) # 1GiB\nmemory1.addParam("addr_range_end", 3221225471)   # 3GiB - 1\n# Memory 2 addresses 3GiB-4GiB\nmemory2.addParam("addr_range_start", 3221225472) # 3GiB\nmemory2.addParam("addr_range_end", 4294967295)   # 4GiB - 1\n'})}),"\n",(0,s.jsx)(r.h2,{id:"si-units-and-base-10-vs-base-2",children:"SI Units and base-10 vs base-2"}),"\n",(0,s.jsx)(r.p,{children:'While "GB" and "GiB" are often used interchangeably in the context of memory, be specific in simulator input. In some cases, for legacy reasons, memHierarchy will automatically translate a base-10 SI prefix (e.g., MB) to base-2 (e.g, MiB) but it does not do so universally as sometimes base-10 is desired. If a parameter is always interpreted as base-2, that will be noted in the parameter description.'})]})}function c(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);