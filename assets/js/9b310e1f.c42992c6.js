"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[70186],{26490:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/dev/devtutorial","title":"Creating a component","description":"In this tutorial, we will create some PingPong elements based on the classic protocol where a sender sends an event (ping) and a receiver responds with another event (pong). The simulation will be very simple: one ping-pong exchange. We will create two separate component types, a \\"Sender\\" to send a \\"ping\\" event and a \\"Responder\\" that responds with a \\"pong\\" event as shown below.","source":"@site/../docs/guides/dev/devtutorial.md","sourceDirName":"guides/dev","slug":"/guides/dev/devtutorial","permalink":"/sst-docs/docs/guides/dev/devtutorial","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/guides/dev/devtutorial.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"Creating a component"},"sidebar":"guides","previous":{"title":"Development","permalink":"/sst-docs/docs/category/development"},"next":{"title":"Element Naming Conventions","permalink":"/sst-docs/docs/guides/dev/naming"}}');var s=t(74848),o=t(28453);const r={title:"Creating a component"},a=void 0,l={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Concepts covered",id:"concepts-covered",level:2},{value:"Designing SST Components",id:"designing-sst-components",level:2},{value:"What is a component?",id:"what-is-a-component",level:3},{value:"The component boilerplate",id:"the-component-boilerplate",level:3},{value:"1. The <code>SST_ELI_REGISTER_COMPONENT</code> macro (boilerplate.h, lines 17-24)",id:"1-the-sst_eli_register_component-macro-boilerplateh-lines-17-24",level:4},{value:"2. The <code>sst/core/sst_config.h</code> include at the top of boilerplate.cc",id:"2-the-sstcoresst_configh-include-at-the-top-of-boilerplatecc",level:4},{value:"Modifying the boilerplate",id:"modifying-the-boilerplate",level:3},{value:"Creating a skeleton element library",id:"creating-a-skeleton-element-library",level:2},{value:"Step 1: Create the Sender component",id:"step-1-create-the-sender-component",level:3},{value:"Step 2: Create the Responder component",id:"step-2-create-the-responder-component",level:3},{value:"Step 3: Compile and register the PingPong element library",id:"step-3-compile-and-register-the-pingpong-element-library",level:3},{value:"Exchanging SST Events",id:"exchanging-sst-events",level:2},{value:"Defining SST Events",id:"defining-sst-events",level:4},{value:"Event-driven simulation",id:"event-driven-simulation",level:4},{value:"A side note on clocks",id:"a-side-note-on-clocks",level:4},{value:"1. Create a new event type",id:"1-create-a-new-event-type",level:3},{value:"2. Add a port",id:"2-add-a-port",level:3},{value:"2. Implement event handlers",id:"2-implement-event-handlers",level:3},{value:"Sender",id:"sender",level:4},{value:"Responder",id:"responder",level:4},{value:"4. Prepare to simulate the first event",id:"4-prepare-to-simulate-the-first-event",level:3},{value:"5. Tell SST when to end simulation",id:"5-tell-sst-when-to-end-simulation",level:3},{value:"Run the simulation",id:"run-the-simulation",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:'In this tutorial, we will create some PingPong elements based on the classic protocol where a sender sends an event (ping) and a receiver responds with another event (pong). The simulation will be very simple: one ping-pong exchange. We will create two separate component types, a "Sender" to send a "ping" event and a "Responder" that responds with a "pong" event as shown below.'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"PingPong simulation",src:t(82474).A+"",width:"1077",height:"169"})}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you are not yet familiar with ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/guides/runningSST",children:"running"})," and ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/guides/configuration/configTutorial",children:"configuring"})," SST simulations, do those tutorials first."]}),"\n",(0,s.jsxs)(n.li,{children:["Install a recent version of the SST-Core. This can be from a release or from the repository. Put your SST ",(0,s.jsx)(n.code,{children:"bin/"})," directory in your ",(0,s.jsx)(n.code,{children:"PATH"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ export PATH=<SST_CORE_INSTALL_DIR>/bin:$PATH\n"})}),"\n",(0,s.jsx)(n.h2,{id:"concepts-covered",children:"Concepts covered"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"What is a component"}),"\n",(0,s.jsx)(n.li,{children:"Creating a component from SST boilerplate"}),"\n",(0,s.jsx)(n.li,{children:"Compiling an element library"}),"\n",(0,s.jsx)(n.li,{children:"Registering an element library with the SST-Core"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"designing-sst-components",children:"Designing SST Components"}),"\n",(0,s.jsx)(n.p,{children:"In this first section, we will take a look at what a component is and the basic boilerplate needed to implement one. Later, we will use this boilerplate to implement the Sender and Responder components."}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-component",children:"What is a component?"}),"\n",(0,s.jsx)(n.p,{children:"Components are the fundamental building block of simulation in SST. A component is a model - in architectural simulations, a component may be a processor, a cache or a network router. Each component is a contained unit of simulation: it executes serially and objects belonging to a component can interact through shared state, function calls, and arbitrary APIs. However, components may only interact with other components by exchanging SST Events. This restriction exists because, as a parallel framework, SST may assign components to different threads or even processes."}),"\n",(0,s.jsx)(n.h3,{id:"the-component-boilerplate",children:"The component boilerplate"}),"\n",(0,s.jsxs)(n.p,{children:["A component is created by defining a C++ class that inherits from ",(0,s.jsx)(n.code,{children:"SST::Component"})," and contains an Element Library Info (ELI) macro that registers the class as a component with SST. The basic boilerplate is shown below in a header (",(0,s.jsx)(n.code,{children:"boilerplate.h"}),") and  implementation (",(0,s.jsx)(n.code,{children:"boilerplate.cc"}),") file."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="boilerplate.h" showLineNumbers',children:'/*\n * SST Component Boilerplate.\n * Required: Update LIBRARYNAME, CLASSNAME, LibraryNamespace, CLassName, LibraryName, ElementName and Description.\n * Optional: Update  category metadata on line 23 \n */\n#ifndef _SST_LIBRARYNAME_CLASSNAME_H \n#define _SST_LIBRARYNAME_CLASSNAME_H\n\n#include <sst/core/component.h>\n\nnamespace LibraryNamespace {\n\nclass ClassName : public SST::Component\n{\npublic:\n\n    SST_ELI_REGISTER_COMPONENT(\n        ClassName,                          // Component class\n        "LibraryName",                      // Component library (for Python/library lookup)\n        "ElementName",                      // Component name (for Python/library lookup)\n        SST_ELI_ELEMENT_VERSION(1,0,0),     // Version of the component (not related to the SST version)\n        "Description",                      // Description\n        COMPONENT_CATEGORY_UNCATEGORIZED    // Category\n    )\n\n    // Constructor\n    ClassName(SST::ComponentId_t id, SST::Params& params);\n\n    // Destructor\n    ~ClassName();\n};\n\n} // namespace LibraryNamespace\n\n#endif /* _SST_LIBRARYNAME_CLASSNAME_H */\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="boilerplate.cc" showLineNumbers',children:'/*\n * SST Component Boilerplate.\n * Required: Update LibraryNamespace, boilerplate.h, and ClassName\n */\n\n// This include is REQUIRED in every SST implementation file.\n// It should NEVER be included in a header file\n#include <sst/core/sst_config.h> \n\n#include "boilerplate.h"\n\nusing namespace LibraryNamespace;\n\nClassName::ClassName(SST::ComponentId_t id, SST::Params& UNUSED(params)) : SST::Component(id) { }\n\nClassName::~ClassName() { }\n'})}),"\n",(0,s.jsx)(n.p,{children:"There are two key things to pay attention to in the boilerplate."}),"\n",(0,s.jsxs)(n.h4,{id:"1-the-sst_eli_register_component-macro-boilerplateh-lines-17-24",children:["1. The ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/eli/register/sst_eli_register_component",children:(0,s.jsx)(n.code,{children:"SST_ELI_REGISTER_COMPONENT"})})," macro (boilerplate.h, lines 17-24)"]}),"\n",(0,s.jsxs)(n.p,{children:["The first three arguments of this macro let SST set up all of the infrastructure needed for SST-Core to construct a component of type ",(0,s.jsx)(n.code,{children:"ClassName"}),' whenever it sees the name "LibraryName.ElementName" in an SST input file. The last three arguments in the macro provide information to users about the component. Once a library is registered with SST, this information can be viewed using SST\'s ',(0,s.jsx)(n.code,{children:"sst-info"})," command line utility."]}),"\n",(0,s.jsxs)(n.h4,{id:"2-the-sstcoresst_configh-include-at-the-top-of-boilerplatecc",children:["2. The ",(0,s.jsx)(n.code,{children:"sst/core/sst_config.h"})," include at the top of boilerplate.cc"]}),"\n",(0,s.jsxs)(n.p,{children:["This must be the first include in every SST implementation file. ",(0,s.jsx)(n.code,{children:"sst/core/sst_config.h"})," is a file that SST's build system generates and ",(0,s.jsx)(n.em,{children:"it does not have header guards"}),". Do not include this file in any header file and always include it at the top of every implementation file."]}),"\n",(0,s.jsx)(n.h3,{id:"modifying-the-boilerplate",children:"Modifying the boilerplate"}),"\n",(0,s.jsxs)(n.p,{children:["To create your own component, you will copy the files ",(0,s.jsx)(n.code,{children:"boilerplate.h"})," and ",(0,s.jsx)(n.code,{children:"boilerplate.cc"})," to your own components files, for example, ",(0,s.jsx)(n.code,{children:"classname.h"})," and ",(0,s.jsx)(n.code,{children:"classname.cc"}),". Then you will modify them using these guidelines."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Header"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lines 6-7, 35:"})," Header guards. Modify to match your LIBRARYNAME and CLASSNAME."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lines 11, 33"}),': Namespace for your element library. Modify "LibraryNamespace" to a unique namespace for your library.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 13"}),': Class declaration. Modify "ClassName" to the name of your class.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lines 17-24"}),": This is an Element Library Info (ELI) macro that SST uses to identify your element. It ",(0,s.jsx)(n.em,{children:"must"})," be located in a public section of your class header.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 18"}),": Modify to ",(0,s.jsx)(n.em,{children:"exactly match"})," your class name. It is not a string."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 19"}),": Modify to match your library name. This name must adhere to ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/guides/dev/naming",children:"SST's element naming conventions."})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 20"}),": Modify to the name you wish to use to lookup this component. It does not need to match the class name. This name must adhere to ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/guides/dev/naming",children:"SST's element naming conventions."})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 21"}),": This is currently unused, leave it as is."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 22"}),": Modify this to provide a brief description of this component to help a user understand what the component is for. It is reported when viewing available components through SST's query tool, ",(0,s.jsx)(n.code,{children:"sst-info"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 23"}),": Modify this to a reasonable category matching the type of your component (see ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/eli/other/sst_eli_category_info",children:"Component Categories"})," for options). You may leave this as ",(0,s.jsx)(n.code,{children:"COMPONENT_CATEGORY_UNCATEGORIZED"})," if no other option fits. The category is reported when viewing available components through SST's query tool, ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/tools/commandLine/sst-info",children:(0,s.jsx)(n.code,{children:"sst-info"})}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 27"}),": The component constructor. Modify the ClassName to match your class."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 30"}),": The component destructor. Modify the ClassName to match your class."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Implementation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 10"})," Modify the class header include to include your component header file."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 12"}),' Change "LibraryNamespace" to match your header modification']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lines 14, 16"}),' Change "ClassName" to match the name of your class.']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Line 14"})," If you use the ",(0,s.jsx)(n.code,{children:"params"}),' argument in your class constructor, remove the "UNUSED" macro around ',(0,s.jsx)(n.code,{children:"params"}),". This suppresses compiler warnings because the argument is unused in the boilerplate."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-skeleton-element-library",children:"Creating a skeleton element library"}),"\n",(0,s.jsx)(n.p,{children:"Next, we will use the boilerplate introduced above to implement a skeleton of the Sender and Responder components and compile them into a shared library. We'll then register the library with SST-Core and confirm that SST can load our library. For the time being, the components will not do anything - we will fix that in the second set of steps."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-create-the-sender-component",children:"Step 1: Create the Sender component"}),"\n",(0,s.jsxs)(n.p,{children:["Create a directory for your element library, such as ",(0,s.jsx)(n.code,{children:"$HOME/sst-tutorial"}),". We'll create all of the files we need for this tutorial in this directory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ mkdir -p $HOME/sst-tutorial\n$ cd sst-tutorial\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In your tutorial directory, create a header file named ",(0,s.jsx)(n.code,{children:"sender.h"})," and an implementation file named ",(0,s.jsx)(n.code,{children:"sender.cc"}),". Use the boilerplate shown above for both files and customize it using the following replacements:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Replace "LIBRARYNAME" with "PINGPONG"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "LibraryNamespace" and "LibraryName" with "PingPong"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "CLASSNAME" with "SENDER"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "ClassName" with "Sender"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "ElementName" with "Sender" - Note: This is the same as "ClassName" in this example but that is not required.'}),"\n",(0,s.jsx)(n.li,{children:'Replace "Description" with "Sends ping events to a responder component"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "boilerplate.h" in the implementation file with "sender.h"'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You will end up with files as shown below. The modified ELI macro tells SST that this class ",(0,s.jsx)(n.code,{children:"Sender"}),' is a component and it should be registered to the name "PingPong.Sender" (i.e., "LibraryName.ElementName"). The class doesn\'t do anything yet, but is complete so we can compile it.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.h" showLineNumbers',children:'#ifndef _SST_PINGPONG_SENDER_H\n#define _SST_PINGPONG_SENDER_H\n\n#include <sst/core/component.h>\n\nnamespace PingPong {\n\nclass Sender : public SST::Component\n{\npublic:\n\n    SST_ELI_REGISTER_COMPONENT(\n        Sender,                                         // Component class.\n        "PingPong",                                     // Component library (for Python/library lookup)\n        "Sender",                                       // Component name (for Python/library lookup)\n        SST_ELI_ELEMENT_VERSION(1,0,0),                 // Version of the component (not related to the SST version)\n        "Sends ping events to a responder component",   // Description\n        COMPONENT_CATEGORY_UNCATEGORIZED                // Category\n    )\n\n    // Constructor\n    Sender(SST::ComponentId_t id, SST::Params& params);\n\n    // Destructor\n    ~Sender();\n};\n\n} // namespace PingPong\n\n#endif /* _SST_PINGPONG_SENDER_H */\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'#include <sst/core/sst_config.h> \n\n#include "sender.h"\n\nusing namespace PingPong;\n\nSender::Sender(SST::ComponentId_t id, SST::Params& UNUSED(params)) : SST::Component(id) { }\n\nSender::~Sender() { }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-the-responder-component",children:"Step 2: Create the Responder component"}),"\n",(0,s.jsxs)(n.p,{children:["Repeat Step 2 for the Responder component to create the files ",(0,s.jsx)(n.code,{children:"responder.h"})," and ",(0,s.jsx)(n.code,{children:"responder.cc"}),". Use the following substitutions in the header boilerplate:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Replace "LIBRARYNAME" with "PINGPONG"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "LibraryNamespace" and "LibraryName" with "PingPong"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "CLASSNAME" with "RESPONDER"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "ClassName" with "Responder"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "ElementName" with "Responder" - Note: This is the same as "ClassName" in this example but that is not required.'}),"\n",(0,s.jsx)(n.li,{children:'Replace "Description" with "Responds to ping events with pong events"'}),"\n",(0,s.jsx)(n.li,{children:'Replace "boilerplate.h" in the implementation file with "responder.h"'}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["When you finish, you will have two more files, ",(0,s.jsx)(n.code,{children:"responder.h"})," and ",(0,s.jsx)(n.code,{children:"responder.cc"}),", that look like this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="responder.h" showLineNumbers',children:'#ifndef _SST_PINGPONG_RESPONDER_H\n#define _SST_PINGPONG_RESPONDER_H\n\n#include <sst/core/component.h>\n\nnamespace PingPong {\n\nclass Responder : public SST::Component\n{\npublic:\n\n    SST_ELI_REGISTER_COMPONENT(\n        Responder,                                  // Component class.\n        "PingPong",                                 // Component library (for Python/library lookup)\n        "Responder",                                // Component name (for Python/library lookup)\n        SST_ELI_ELEMENT_VERSION(1,0,0),             // Version of the component (not related to the SST version)\n        "Responds to ping events with pong events", // Description\n        COMPONENT_CATEGORY_UNCATEGORIZED            // Category\n    )\n\n    // Constructor\n    Responder(SST::ComponentId_t id, SST::Params& params);\n\n    // Destructor\n    ~Responder();\n};\n\n} // namespace PingPong\n\n#endif /* _SST_PINGPONG_RESPONDER_H */\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="responder.cc" showLineNumbers',children:'#include <sst/core/sst_config.h> \n\n#include "responder.h"\n\nusing namespace PingPong;\n\nResponder::Responder(SST::ComponentId_t id, SST::Params& UNUSED(params)) : SST::Component(id) { }\n\nResponder::~Responder() { }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Next, we will compile both components into an element library and register it with SST."}),"\n",(0,s.jsx)(n.h3,{id:"step-3-compile-and-register-the-pingpong-element-library",children:"Step 3: Compile and register the PingPong element library"}),"\n",(0,s.jsxs)(n.p,{children:["You can use the build infrastructure of your choice for your element library. SST uses Autotools but is regularly tested against libraries built with Autotools, CMake, and raw Makefiles. This tutorial library is simple so we will use a raw Makefile as shown. Create this file in in the same directory as you created your source files (e.g., ",(0,s.jsx)(n.code,{children:"$HOME/sst-tutorial"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Makefile" showLineNumbers',children:"# Acquire compile environment from sst-config utility\nCXX=$(shell sst-config --CXX)\nCXXFLAGS=$(shell sst-config --ELEMENT_CXXFLAGS)\nLDFLAGS=$(shell sst-config --ELEMENT_LDFLAGS)\n\n# make all - compile libPingPong.so and register (install) it\nall: libPingPong.so install\n\n# Compile library\nlibPingPong.so: sender.o responder.o\n\t$(CXX) $(CXXFLAGS) sender.o responder.o -o $@ $(LDFLAGS)\n\n# Install (register) library with SST-Core using sst-register utility\ninstall:\n\tsst-register PingPong PingPong_LIBDIR=$(CURDIR)\n\nclean:\n\trm -rf *.o libPingPong.so\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Lines 2-4 of the Makefile use sst-config to locate a compiler and get the correct build flags. Lines 10-11 compile the library and line 15 registers it with the SST Core using ",(0,s.jsx)(n.code,{children:"sst-register"}),". You can also run ",(0,s.jsx)(n.code,{children:"sst-register"})," from the command line."]}),"\n",(0,s.jsxs)(n.p,{children:["Run ",(0,s.jsx)(n.code,{children:"make"})," in your tutorial directory to build and register your element library. You can check that the registration succeeded using the ",(0,s.jsx)(n.code,{children:"sst-info"})," command line tool. Make sure the argument you provide to ",(0,s.jsx)(n.code,{children:"sst-info"})," matches the one you gave to your element library in line 14 of your ",(0,s.jsx)(n.code,{children:"sender.h"})," and ",(0,s.jsx)(n.code,{children:"responder.h"})," header files. It is case sensitive."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ make\n$ sst-info PingPong\n"})}),"\n",(0,s.jsx)(n.p,{children:"You will see output like this."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'PROCESSED 1 .so (SST ELEMENT) FILES FOUND IN DIRECTORY(s) /home/install/sst-core/lib/sstcore:/home/sst-tutorial\nFiltering output on Element = "PingPong"\n================================================================================\nELEMENT LIBRARY 0 = PingPong ()\nComponents (2 total)\n   Component 0: Responder\n      Description: Responds to ping events with pong events\n      ELI version: 0.9.0\n      Compiled on: Mar  4 2025 09:31:56, using file: ./responder.h\n      Category: UNCATEGORIZED COMPONENT\n      Parameters (0 total)\n      Ports (0 total)\n      SubComponent Slots (0 total)\n      Statistics (0 total)\n      Profile Points (0 total)\n      Attributes (0 total)\n\n   Component 1: Sender\n      Description: Sends ping events to a responder component\n      ELI version: 0.9.0\n      Compiled on: Mar  4 2025 09:31:54, using file: ./sender.h\n      Category: UNCATEGORIZED COMPONENT\n      Parameters (0 total)\n      Ports (0 total)\n      SubComponent Slots (0 total)\n      Statistics (0 total)\n      Profile Points (0 total)\n      Attributes (0 total)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Success! You've now registered a new element library containing two new components with SST. Next, we will add a ping and pong exchange to the components and generate a simulation with them."}),"\n",(0,s.jsx)(n.h2,{id:"exchanging-sst-events",children:"Exchanging SST Events"}),"\n",(0,s.jsx)(n.p,{children:"To enable the components to exchange events, we need to (1) define an event type, (2) add a port for sending and receiving events in each component, and (3) add an event handler to each component to handle incoming events."}),"\n",(0,s.jsx)(n.h4,{id:"defining-sst-events",children:"Defining SST Events"}),"\n",(0,s.jsxs)(n.p,{children:["In SST, an event is a message between components. Events may contain arbitrary information - whatever is needed by the exchanging components, with two restrictions: (1) an event must be a class that inherits from the ",(0,s.jsx)(n.code,{children:"SST::Event"})," class and (2) events must be ",(0,s.jsx)(n.em,{children:"serializable"})," and provide a serialization function. This is because SST is a parallel framework. When a source and destination component are not on the same process, SST will need to move the event to the destination process. This requires care for pointers in particular as the source and destination components may not share a virtual address space."]}),"\n",(0,s.jsx)(n.h4,{id:"event-driven-simulation",children:"Event-driven simulation"}),"\n",(0,s.jsxs)(n.p,{children:["As an event-driven simulator, SST progresses simulation by executing events in time order. When an event is ready to execute, SST skips to the delivery time of that event and calls an event handler on the destination component. If the destination, as a result of handling an event, sends a new event, then SST will skip to that new event's delivery time and deliver it. This is the key optimization of event driven simulators: they skip through time, only executing when there is an event to handle. A corollary is that if there are no more events to handle, SST skips to a special sentinel exit event whose 'delivery' time is the end of time. ",(0,s.jsx)(n.em,{children:"Therefore, components need to tell SST when a simulation is done."})," For the same reason, there must also be ",(0,s.jsx)(n.em,{children:"at least one event in SST's event queues at simulation time 0"}),". Otherwise, SST will skip directly to the sentinel exit event."]}),"\n",(0,s.jsx)(n.p,{children:"To recap:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simulation begin:"})," At least one event needs to be in the SST event queue at time 0 of the simulation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simulation end:"})," Simulation ends when one or more components tell SST the simulation is done."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['For our simulation, this means we need to send our first "ping" event at time 0. SST provides components an opportunity to send these initial events during a ',(0,s.jsx)(n.code,{children:"setup()"})," function provided by the ",(0,s.jsx)(n.code,{children:"SST::Component"})," API. To initiate simulation, we will implement that function and use it to send the first event."]}),"\n",(0,s.jsx)(n.p,{children:'Our simulation should also end when the Sender receives a "pong" event. We will add some function calls to tell SST that the Sender is responsible for determining the end of simulation and also let SST know when the simulation ends.'}),"\n",(0,s.jsx)(n.h4,{id:"a-side-note-on-clocks",children:"A side note on clocks"}),"\n",(0,s.jsxs)(n.p,{children:["SST treats clocks as events as well, or, strictly speaking, as ",(0,s.jsx)(n.em,{children:"Activities"}),", which refer to both Events and Clocks in SST. An Event is a single Activity that gets delivered at certain time while a Clock is a recurring Activity that is triggered on a regular time interval. Thus, ",(0,s.jsx)(n.em,{children:"if there is a clock anywhere in the simulation, the activity (event) queue will already have an event in it at time 0"}),". We do not have a clock in our component so this does not apply, but know that it is an alternate method of kicking off a simulation."]}),"\n",(0,s.jsx)(n.p,{children:"With that said, let's add event handling to our Sender and Responder components."}),"\n",(0,s.jsx)(n.h3,{id:"1-create-a-new-event-type",children:"1. Create a new event type"}),"\n",(0,s.jsx)(n.p,{children:'Begin by creating an event class called "PingPongEvent" in a new file, "pingpong_event.h" as shown below.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="pingpong_event.h" showLineNumbers',children:'#ifndef _SST_PINGPONG_EVENT_H\n#define _SST_PINGPONG_EVENT_H\n\nnamespace PingPong {\n\nclass PingPongEvent : public SST::Event\n{\npublic:\n    PingPongEvent(bool ping) : SST::Event(), is_ping(ping) { }\n    ~PingPongEvent() { }\n\n    void setPing() { is_ping = true; }\n    void setPong() { is_ping = false; }\n    bool isPing() { return is_ping; }\n    bool isPong() { return !is_ping; }\n\n    // These functions and macros are required for SST\'s serialization\n    // serialize_order and ImplementSerializable must be in a public section of the class\n    PingPongEvent() : SST::Event() { } // Default constructor \n    \n    void serialize_order(SST::Core::Serialization::serializer& ser) override {\n        Event::serialize_order(ser); // Always serialize base class first\n        SST_SER(is_ping);            // Serialize data members using SST_SER which is a macro\n    }\n\n    ImplementSerializable(PingPong::PingPongEvent); // Macro indicating this class is serializable\n\nprivate:\n    // True if a "ping", False if a "pong"\n    bool is_ping;\n};\n\n} // namespace PingPong\n\n#endif\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As with components, ",(0,s.jsx)(n.code,{children:"PingPongEvent"})," is largely a standard C++ class. It inherits from ",(0,s.jsx)(n.code,{children:"SST:Event"})," and has one data member, a boolean indicating whether the event is a ping (request) or a pong (response). Lines 17-26 show the three things needed for serialization: (1) a default constructor, (2) a ",(0,s.jsx)(n.code,{children:"serialize_order"})," function, and (3) the ",(0,s.jsx)(n.code,{children:"ImplementSerializable"})," macro with the fully qualified class name. The ",(0,s.jsx)(n.code,{children:"serialize_order"})," function should serialize every member of the event. When serializing events, SST calls this function to pack the event into a buffer and transfers it. SST then creates a new event using the default constructor and calls this function again to unpack the buffer into the newly created event. The ",(0,s.jsx)(n.code,{children:"SST_SER"})," macro accepts POD types (e.g., bool, int, char, etc.), ",(0,s.jsx)(n.code,{children:"std::string"}),", SST types such as ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", and C++ standard containers. To serialize a struct, serialize its members."]}),"\n",(0,s.jsxs)(n.p,{children:["Include this new file at the top of both ",(0,s.jsx)(n.code,{children:"sender.cc"})," and ",(0,s.jsx)(n.code,{children:"responder.cc"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'#include <sst/core/sst_config.h>\n\n#include "sender.h"\n//highlight-next-line\n#include "pingpong_event.h"\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="responder.cc" showLineNumbers',children:'#include <sst/core/sst_config.h>\n\n#include "responder.h"\n//highlight-next-line\n#include "pingpong_event.h"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-add-a-port",children:"2. Add a port"}),"\n",(0,s.jsx)(n.p,{children:"Ports are part of a component's ELI (recall: Element Library Info). Events may only be sent over Links and all Links are point-to-point and bidirectional."}),"\n",(0,s.jsxs)(n.p,{children:["Add a port to each component's ELI by adding the following documentation macro to their header files. As with the registration macro, this macro must be in a public section of the class. We can give the port any name that complies with the ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/guides/dev/naming",children:"SST naming conventions"}),'; we will use "send_port" and "response_port". The documentation macro takes a list of ports. Each port is a tuple with the port name, a description, and a comma-separated list of event types that the port sends and/or receives. The event types are not enforced by SST but they can help users ensure that connected ports are compatible.']}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, add a callback function to handle events arriving on the port and a pointer to the ",(0,s.jsx)(n.code,{children:"SST::Link"})," that will connect to the port."]}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 7"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.h" showLineNumbers',children:'class Sender : public SST::Component\n{\npublic:\n\n    SST_ELI_REGISTER_COMPONENT(\n        Sender,                                         // Component class.\n        "PingPong",                                     // Component library (for Python/library lookup)\n        "Sender",                                       // Component name (for Python/library lookup)\n        SST_ELI_ELEMENT_VERSION(1,0,0),                 // Version of the component (not related to the SST version)\n        "Sends ping events to a responder component",   // Description\n        COMPONENT_CATEGORY_UNCATEGORIZED                // Category\n    )\n\n    //highlight-start\n    SST_ELI_DOCUMENT_PORTS( \n        {"send_port", "A port for sending ping messages and receiving pong messages", {"PingPong.PingPongEvent"} } \n    )\n    //highlight-end\n\n    // Constructor\n    Sender(SST::ComponentId_t id, SST::Params& params);\n\n    //Destructor\n    ~Sender();\n\n//highlight-start\n    // Event handler\n    void handle(SST::Event* event);\n\nprivate:\n    SST::Link* link;\n//highlight-end\n};\n'})})}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 7"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="responder.h" showLineNumbers',children:'class Responder : public SST::Component\n{\npublic:\n\n    SST_ELI_REGISTER_COMPONENT(\n        Responder,                                  // Component class.\n        "PingPong",                                 // Component library (for Python/library lookup)\n        "Responder",                                // Component name (for Python/library lookup)\n        SST_ELI_ELEMENT_VERSION(1,0,0),             // Version of the component (not related to the SST version)\n        "Responds to ping events with pong events", // Description\n        COMPONENT_CATEGORY_UNCATEGORIZED            // Category\n    )\n\n    //highlight-start\n    SST_ELI_DOCUMENT_PORTS( \n        {"response_port", "A port for receiving ping messages and sending pong messages", {"PingPong.PingPongEvent"} } \n    )\n    //highlight-end\n\n    // Constructor\n    Responder(SST::ComponentId_t id, SST::Params& params);\n\n    // Destructor\n    ~Responder();\n\n//highlight-start\n    // Event handler\n    void handle(SST::Event* event);\n\nprivate:\n    SST::Link* link;\n//highlight-end\n};\n'})})}),"\n",(0,s.jsxs)(n.p,{children:["Eventually, to use these components in simulation, we will create an input configuration file for SST that connects a Sender's ",(0,s.jsx)(n.code,{children:"send_port"})," to a Responder's ",(0,s.jsx)(n.code,{children:"response_port"})," via an ",(0,s.jsx)(n.code,{children:"SST::Link"}),". The components need to query which link was connected to their port. To do this, in each component's constructor, use ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/component/link/configureLink",children:(0,s.jsx)(n.code,{children:"configureLink"})})," to get the link that was connected to the component's port. If the port was not connected in the input configuration, the ",(0,s.jsx)(n.code,{children:"configureLink"})," call returns ",(0,s.jsx)(n.code,{children:"nullptr"}),". We should check for this case and let the user know that they need to connect the port."]}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 7"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'Sender::Sender(SST::ComponentId_t id, SST::Params& UNUSED(params)) : SST::Component(id) { \n    link = configureLink("send_port", new SST::Event::Handler2<Sender, &Sender::handle>(this));\n    sst_assert( link != nullptr, CALL_INFO, -1, "Error: \'send_port\' is not connected to a link\\n");\n}\n'})})}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 7"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="responder.cc" showLineNumbers',children:'Responder::Responder(SST::ComponentId_t id, SST::Params& UNUSED(params)) : SST::Component(id) { \n    link = configureLink("response_port", new SST::Event::Handler2<Responder, &Responder::handle>(this));\n    sst_assert( link != nullptr, CALL_INFO, -1, "Error: \'response_port\' is not connected to a link\\n");\n}\n'})})}),"\n",(0,s.jsx)(n.h3,{id:"2-implement-event-handlers",children:"2. Implement event handlers"}),"\n",(0,s.jsxs)(n.p,{children:["SST event handlers are called by SST whenever an event arrives at a component. You already added the function signature to the header so all that remains is to implement it. This is the function we added. Events are delivered as an ",(0,s.jsx)(n.code,{children:"SST::Event"})," pointer and need to be cast to whatever type you expect."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void handle(SST::Event* event);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"sender",children:"Sender"}),"\n",(0,s.jsxs)(n.p,{children:["On the Sender side, the handler function should be receiving pong events so we can have the handler cast the incoming event to ",(0,s.jsx)(n.code,{children:"PingPongEvent"})," and check that ",(0,s.jsx)(n.code,{children:"isPong()"})," returns ",(0,s.jsx)(n.code,{children:"true"}),". If it doesn't, we will assert a failure. If the event is a pong then the simulation is complete and the Sender will notify SST that the simulation is done."]}),"\n",(0,s.jsxs)(n.p,{children:["Add this to the end of ",(0,s.jsx)(n.code,{children:"sender.cc"}),"."]}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 14"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'void Sender::handle(SST::Event* event) {\n    PingPongEvent* pong = static_cast<PingPongEvent*>(event);\n    sst_assert(pong->isPong(), CALL_INFO, -1, "This simulation is misconfigured. Sender did not receive a pong event.\\n");\n    delete pong; // The event handler is responsible for cleaning up incoming events!\n}\n'})})}),"\n",(0,s.jsx)(n.h4,{id:"responder",children:"Responder"}),"\n",(0,s.jsxs)(n.p,{children:['On the Responder side things are a little different. The Responder receives a ping and sends a pong in response. The handler should check that an incoming event was a "ping" and then create a new pong event and send it. Once the Responder calls ',(0,s.jsx)(n.code,{children:"send"}),", the component yields ownership of the event ",(0,s.jsx)(n.code,{children:"pong"})," to SST."]}),"\n",(0,s.jsxs)(n.p,{children:["Add this to the end of ",(0,s.jsx)(n.code,{children:"responder.cc"}),"."]}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 14"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'void Responder::handle(SST::Event* event) {\n    // Handle incoming ping event\n    PingPongEvent* ping = static_cast<PingPongEvent*>(event);\n    sst_assert(ping->isPing(), CALL_INFO, -1, "This simulation is misconfigured. Responder did not receive a ping event.\\n");\n    delete ping; // The event handler is responsible for cleaning up incoming events!\n\n    // Send outgoing pong event\n    PingPongEvent* pong = new PingPongEvent(false); // false = pong\n    link->send(pong);\n}\n'})})}),"\n",(0,s.jsxs)(n.p,{children:["For more information on event handlers, ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/events/event_handler",children:"see the SST Event handler documentation."})]}),"\n",(0,s.jsx)(n.h3,{id:"4-prepare-to-simulate-the-first-event",children:"4. Prepare to simulate the first event"}),"\n",(0,s.jsxs)(n.p,{children:["Recall that as an event-driven simulator, SST must start simulation with at least one event in its event queues. To facilitate this, SST calls the function ",(0,s.jsx)(n.code,{children:"setup()"}),' on every component in the simulation just before it begins the simulation. This is the first opportunity components have to send simulation (sometimes called "timed") events. Any event sent in ',(0,s.jsx)(n.code,{children:"setup()"})," will be sent at time 0."]}),"\n",(0,s.jsxs)(n.p,{children:["Add the ",(0,s.jsx)(n.code,{children:"setup()"})," function to ",(0,s.jsx)(n.code,{children:"sender.h"})," and ",(0,s.jsx)(n.code,{children:"sender.cc"})," as shown."]}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 30"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.h" showLineNumbers',children:"    // Event handler\n    void handle(SST::Event* event);\n\n    //highlight-next-line\n    void setup();\n\nprivate:\n"})})}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 20"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:"void Sender::setup() {\n    PingPongEvent* ping = new PingPongEvent(true); // true = ping\n    link->send(ping);\n}\n"})})}),"\n",(0,s.jsx)(n.h3,{id:"5-tell-sst-when-to-end-simulation",children:"5. Tell SST when to end simulation"}),"\n",(0,s.jsxs)(n.p,{children:["The Sender needs to let SST know that it is responsible for detecting the end of simulation. To do this, add the two lines below to the constructor in ",(0,s.jsx)(n.code,{children:"sender.cc"}),"."]}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 7"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'Sender::Sender(SST::ComponentId_t id, SST::Params& UNUSED(params)) : SST::Component(id) { \n    link = configureLink("send_port", new Event::Handler2<Sender, &Sender::handle>(this));\n    sst_assert( link != nullptr, CALL_INFO, -1, "Error: \'send_port\' is not connected to a link\\n");\n\n    //highlight-start\n    registerAsPrimaryComponent();  // This component is responsible for simulation end\n    primaryComponentDoNotEndSim(); // The simulation should not end yet\n    //highlight-end\n}\n'})})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/component/component/registerAsPrimaryComponent",children:(0,s.jsx)(n.code,{children:"registerAsPrimaryComponent()"})})," and ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/component/component/primaryComponentDoNotEndSim",children:(0,s.jsx)(n.code,{children:"primaryComponentDoNotEndSim()"})})," may be called by multiple components. Simulation will finish when ",(0,s.jsx)(n.em,{children:"all"})," primary components indicate that it is OK to exit."]}),"\n",(0,s.jsx)(n.p,{children:"Finally, when Sender receives the pong event, let SST know that simulation is done. Modify its event handler as shown."}),"\n",(0,s.jsx)("div",{style:{"counter-reset":"line-count 17"},children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="sender.cc" showLineNumbers',children:'void Sender::handle(SST::Event* event) {\n    PingPongEvent* pong = static_cast<PingPongEvent*>(event);\n    sst_assert(pong->isPong(), CALL_INFO, -1, "This simulation is misconfigured. Sender did not receive a pong event.\\n");\n    delete pong; // The event handler is responsible for cleaning up incoming events!\n\n    //highlight-next-line\n    primaryComponentOKToEndSim();\n}\n'})})}),"\n",(0,s.jsx)(n.p,{children:"That's it! The components are ready to simulate. Rebuild and re-register the library."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ make clean\n$ make\n"})}),"\n",(0,s.jsx)(n.h2,{id:"run-the-simulation",children:"Run the simulation"}),"\n",(0,s.jsx)(n.p,{children:'Create an input configuration in a new Python file, "pingpong.py", as shown below. You\'ll need to instantiate a Sender and Responder and connect them together via their ports.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",metastring:'title="pingpong.py"',children:'import sst\n\nsender = sst.Component("sender", "PingPong.Sender")\nresponder = sst.Component("responder", "PingPong.Responder")\n\nlink = sst.Link("pingpong_link")\nlink.connect( (sender, "send_port", "1ms"), (responder, "response_port", "1ms") ) \n'})}),"\n",(0,s.jsx)(n.p,{children:"Run the simulation. The only output will be the simulated time since our components don't produce any console or statistics output."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ sst pingpong.py\nSimulation is complete, simulated time: 2 ms\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because we correctly serialized the ",(0,s.jsx)(n.code,{children:"PingPongEvent"}),", the following will also work."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ sst -n 2 pingpong.py      # Put sender and responder on different threads\n$ mpirun -np 2 pingpong.py  # Put sender and responder on different ranks\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},82474:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/pingpong-cd7075b86ca5d9ed63945f8cb83792f4.png"}}]);