"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[13913],{28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var n=s(96540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}},92086:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"community/index","title":"Community","description":"Many community SST developers maintain additional element libraries and tools. We\'ve collected a list of them here.","source":"@site/../docs/community/index.md","sourceDirName":"community","slug":"/community/","permalink":"/sst-docs/docs/community/","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/community/index.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"Community"}}');var i=s(74848),r=s(28453);const o={title:"Community"},a=void 0,l={},c=[{value:"Element Libraries",id:"element-libraries",level:2},{value:"BE-SST",id:"be-sst",level:3},{value:"REV",id:"rev",level:3},{value:"SimEng",id:"simeng",level:3},{value:"SST-Spatter",id:"sst-spatter",level:3},{value:"SST-STONNE",id:"sst-stonne",level:3},{value:"Tools",id:"tools",level:2},{value:"AHP Graphs for SST",id:"ahp-graphs-for-sst",level:3},{value:"sst-containers",id:"sst-containers",level:3},{value:"sst-dbg",id:"sst-dbg",level:3},{value:"sst-viz",id:"sst-viz",level:3},{value:"Contribute",id:"contribute",level:2}];function d(e){const t={a:"a",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Many community SST developers maintain additional element libraries and tools. We've collected a list of them here."}),"\n",(0,i.jsx)(t.h2,{id:"element-libraries",children:"Element Libraries"}),"\n",(0,i.jsx)(t.h3,{id:"be-sst",children:(0,i.jsx)(t.a,{href:"https://github.com/SHREC-DOE-UF/BE-SST",title:"BE-SST Github",children:"BE-SST"})}),"\n",(0,i.jsx)(t.p,{children:"BE-SST is a coarse-grained parallel discrete-event simulator, developed at the PSAAP II Center for Compressible Multiphase Turbulence at the University of Florida, used for system-level modeling and simulation of existing and notional HPC systems."}),"\n",(0,i.jsx)(t.h3,{id:"rev",children:(0,i.jsx)(t.a,{href:"https://github.com/tactcomplabs/rev",title:"Rev GitHub",children:"REV"})}),"\n",(0,i.jsx)(t.p,{children:"The Rev SST component is designed to provide cycle-based simulation capabilities of an arbitrary RISC-V core or cores."}),"\n",(0,i.jsx)(t.h3,{id:"simeng",children:(0,i.jsx)(t.a,{href:"https://uob-hpc.github.io/SimEng/",title:"SimEng Documentation",children:"SimEng"})}),"\n",(0,i.jsxs)(t.p,{children:["The Simulation Engine (SimEng) is a fast, cycle-level, open-source simulation framework under development by the University of Bristol's High Performance Computing group. SimEng targets the design space of modern HPC processors with a current focus on AArch64 (Armv9.2-a) and RISC-V (rv64imafdc) instruction set architectures. SimEng has been configured to model a variety of existing processors (including a ThunderX2, A64FX, Apple M1, and Arm Neoverse V2) and hypothetical core designs to evaluate bleeding-edge developments in the HPC domain. SimEng currently integrates with SST to improve its simulation of a processor's memory hierarchy. Through encapsulation as an SST component, SimEng translates its memory accesses into a suitable form for use by memHierarchy. The integration has yielded significant improvements in the accuracy of modeling real-world processors, most notably when simulating the execution of memory-bound codes. ",(0,i.jsx)(t.a,{href:"https://uob-hpc.github.io/SimEng",children:"SimEng's documentation"})," offers a comprehensive overview of both itself and its integration with SST."]}),"\n",(0,i.jsx)(t.h3,{id:"sst-spatter",children:(0,i.jsx)(t.a,{href:"https://github.com/hpcgarage/sst-spatter/tree/master",children:"SST-Spatter"})}),"\n",(0,i.jsxs)(t.p,{children:["SST-Spatter is an element based on Miranda, the pattern-based memory access pattern generator included in SST-Elements. It supports all of the memory access patterns provided by the ",(0,i.jsx)(t.a,{href:"https://github.com/hpcgarage/spatter",children:"Spatter"})," memory benchmark. Users can input patterns directly in an SDL file or patterns can be read in from json files, such as the ones in the ",(0,i.jsx)(t.a,{href:"https://github.com/hpcgarage/spatter-patterns",children:"spatter-patterns"})," repository that were captured from other benchmarks. SST-Spatter includes a python script that will process SST statistics output and turn it into Spatter's output format for easy comparison."]}),"\n",(0,i.jsx)(t.h3,{id:"sst-stonne",children:(0,i.jsx)(t.a,{href:"https://github.com/stonne-simulator/sst-elements-with-stonne",title:"SST-STONNE GitHub",children:"SST-STONNE"})}),"\n",(0,i.jsx)(t.p,{children:"STONNE is a cycle-level microarchitectural simulator for flexible DNN inference accelerators. STONNE models all the major components required to build  next-generation flexible DNN accelerators like MAERI or SIGMA. All the on-chip components are interconnected by using a three-tier network fabric composed of a Distribution Network(DN), a Multiplier Network (MN), and a Reduce Network(RN), inspired by the taxonomy of on-chip communication flows within DNN accelerators. STONNE has been integrated as a component called sstStonne in SST. sstStonne connects to memHierarchy component to faithfully model the memory hierarchy of the accelerator. The STONNE-MemHierarchy integration allows to run four main operations: CONVOLUTION, GEMM (Dense matrix multiplication), sparse-sparse GEMM operation where the matrices are encoded using a bitmat format, and sparse-dense matrix multiplication (spMM) where the sparse matrix in encoded in CSR format. The simulator is configurable to support different architectural parameters and different memory hiearchy organizations. Basic installation/usage instructions can be found in the additional external elements section of the current SST release documentation."}),"\n",(0,i.jsx)(t.h2,{id:"tools",children:"Tools"}),"\n",(0,i.jsx)(t.h3,{id:"ahp-graphs-for-sst",children:(0,i.jsx)(t.a,{href:"https://github.com/lpsmodsimteam/ahp_graph",children:"AHP Graphs for SST"})}),"\n",(0,i.jsx)(t.p,{children:"Attributed Hierarchical Port Graphs for SST."}),"\n",(0,i.jsx)(t.h3,{id:"sst-containers",children:(0,i.jsx)(t.a,{href:"https://github.com/tactcomplabs/sst-containers",children:"sst-containers"})}),"\n",(0,i.jsx)(t.p,{children:"Build scripts for SST containers."}),"\n",(0,i.jsx)(t.h3,{id:"sst-dbg",children:(0,i.jsx)(t.a,{href:"https://github.com/tactcomplabs/sst-dbg",children:"sst-dbg"})}),"\n",(0,i.jsx)(t.p,{children:"A debug library for SST components."}),"\n",(0,i.jsx)(t.h3,{id:"sst-viz",children:(0,i.jsx)(t.a,{href:"https://github.com/tactcomplabs/sst-viz",children:"sst-viz"})}),"\n",(0,i.jsx)(t.p,{children:"A web-based viz tool."}),"\n",(0,i.jsx)(t.h2,{id:"contribute",children:"Contribute"}),"\n",(0,i.jsxs)(t.p,{children:["Have an SST element, tool, or other resource to share? Fork the sst-docs ",(0,i.jsx)(t.a,{href:"https://github.com/sstsimulator/sst-docs",children:"repository"})," and submit a pull request to add it.\nRequests should:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Include a link to the resource"}),"\n",(0,i.jsx)(t.li,{children:"Include a short description"}),"\n",(0,i.jsx)(t.li,{children:"Be added to the list in alphabetical order by resource name"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);