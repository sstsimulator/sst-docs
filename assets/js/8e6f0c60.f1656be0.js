"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[13427],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var o=n(96540);const c={},r=o.createContext(c);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),o.createElement(r.Provider,{value:t},e.children)}},74635:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"core/component/time/getNextClockCycle","title":"getNextClockCycle","description":"Availability: Component, SubComponent, ComponentExtension","source":"@site/../docs/core/component/time/getNextClockCycle.md","sourceDirName":"core/component/time","slug":"/core/component/time/getNextClockCycle","permalink":"/sst-docs/docs/core/component/time/getNextClockCycle","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/component/time/getNextClockCycle.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1684522150000,"frontMatter":{"title":"getNextClockCycle"},"sidebar":"core","previous":{"title":"reregisterClock","permalink":"/sst-docs/docs/core/component/time/reregisterClock"},"next":{"title":"registerTimeBase","permalink":"/sst-docs/docs/core/component/time/registerTimeBase"}}');var c=n(74848),r=n(28453);const s={title:"getNextClockCycle"},l=void 0,i={},a=[{value:"Parameters",id:"parameters",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function d(e){const t={code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-cpp",children:"Cycle_t getNextClockCycle(TimeConverter* freq);\n"})}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.em,{children:"Availability:"})," Component, SubComponent, ComponentExtension"]}),"\n",(0,c.jsx)(t.p,{children:"Return the next cycle count that a clock with the provided frequency would fire. If called prior to the simulation run loop, returns 0. If called after the simulation run loop, returns one cycle past the time that the simulation ended."}),"\n",(0,c.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,c.jsxs)(t.ul,{children:["\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"freq"})," (TimeConverter*) Frequency of the clock"]}),"\n",(0,c.jsxs)(t.li,{children:[(0,c.jsx)(t.strong,{children:"returns"})," (Cycle_t) Cycle count that the clock would next be fired at"]}),"\n"]}),"\n",(0,c.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-cpp",children:'void example::handleEvent(SST::Event* ev) {\n    \n    /** Handle event here */\n\n    output.output("Received event at cycle %" PRIu64 "\\n", getNextClockCycle());\n}\n'})}),"\n",(0,c.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/componentExtension.h>\n"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}}}]);