"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[24319],{7865:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core/sharedobj/overview","title":"Shared Objects","description":"Shared Objects are special read-only data structures that can be shared across Components. They are intended as a memory use optimization when many Components would otherwise replicate read-only data (e.g., large routing tables). In parallel simulations, the object is replicated once on each SST rank and is shared among threads. Shared objects are writeable through SST\'s construction and init stages and become read-only once the setup stage begins.","source":"@site/../docs/core/sharedobj/overview.md","sourceDirName":"core/sharedobj","slug":"/core/sharedobj/overview","permalink":"/sst-docs/docs/core/sharedobj/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/sharedobj/overview.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1729787241000,"frontMatter":{"title":"Shared Objects"},"sidebar":"core","previous":{"title":"simulationSignalShutdown","permalink":"/sst-docs/docs/core/realtime/simulationSignalShutdown"},"next":{"title":"Shared::SharedArray","permalink":"/sst-docs/docs/core/sharedobj/sharedArray"}}');var i=t(74848),r=t(28453);const s={title:"Shared Objects"},o=void 0,d={},c=[{value:"Obtaining a shared object",id:"obtaining-a-shared-object",level:2},{value:"Writing a shared object",id:"writing-a-shared-object",level:2},{value:"Resolving write conflicts",id:"resolving-write-conflicts",level:3},{value:"FE_VERIFY",id:"fe_verify",level:4},{value:"INIT_VERIFY",id:"init_verify",level:4},{value:"NO_VERIFY",id:"no_verify",level:4},{value:"Accessing shared objects during simulation",id:"accessing-shared-objects-during-simulation",level:2},{value:"Cleaning up shared objects",id:"cleaning-up-shared-objects",level:2},{value:"Example: Using a SharedArray to randomize physical address maps",id:"example-using-a-sharedarray-to-randomize-physical-address-maps",level:2},{value:"Header",id:"header",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Shared Objects are special read-only data structures that can be shared across Components. They are intended as a memory use optimization when many Components would otherwise replicate read-only data (e.g., large routing tables). In parallel simulations, the object is replicated once on each SST rank and is shared among threads. Shared objects are writeable through SST's ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/guides/concepts/lifecycle",children:"construction and init stages"})," and become read-only once the setup stage begins."]}),"\n",(0,i.jsx)(n.p,{children:"The available objects are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SharedArray<T>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SharedSet<T>"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SharedMap<K,V>"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The templated types (",(0,i.jsx)(n.code,{children:"T,K,V"}),") must be non-pointer types and must be serializable."]}),"\n",(0,i.jsx)(n.h2,{id:"obtaining-a-shared-object",children:"Obtaining a shared object"}),"\n",(0,i.jsxs)(n.p,{children:["Shared objects must be created and initialized during SST's construction and/or init stages. Objects are writeable during this time and use a well-defined policy to resolve write conflicts. To obtain an object, call ",(0,i.jsx)(n.code,{children:"object.initialize(NAME)"})," with the name of the object. A conflict resolution policy different from the default can also be specified."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",metastring:"title=\"Initializing a shared object named 'shared_set'\"",children:'SST::SharedSet<int>   set;\nset.initialize("shared_set");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"writing-a-shared-object",children:"Writing a shared object"}),"\n",(0,i.jsxs)(n.p,{children:["After initializing, components can write the object using write functions provided by the shared object class. These functions check for write conflicts and ensure atomic updates when components are writing simultaneously. Thread-safe read functions are also provided. Components may write during SST's ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/guides/concepts/lifecycle",children:"construction and init stages"}),". Once a component finishes writing, it should call ",(0,i.jsx)(n.code,{children:"object.publish()"})," to indicate it is done. A component may not write the object after publishing it, although other components may continue to write until they call ",(0,i.jsx)(n.code,{children:"publish()"}),". If a component fails to publish the object, it will be automatically published at the start of the setup stage. Writes from components on different ranks are merged and made globally available at the end of each init phase."]}),"\n",(0,i.jsx)(n.h3,{id:"resolving-write-conflicts",children:"Resolving write conflicts"}),"\n",(0,i.jsxs)(n.p,{children:["Write conflicts occur when components write to the same element in the shared object. There are three conflict resolution policies: ",(0,i.jsx)(n.code,{children:"FE_VERIFY"}),", ",(0,i.jsx)(n.code,{children:"INIT_VERIFY"}),", and ",(0,i.jsx)(n.code,{children:"NO_VERIFY"}),". Different object types have different defaults."]}),"\n",(0,i.jsx)(n.h4,{id:"fe_verify",children:"FE_VERIFY"}),"\n",(0,i.jsxs)(n.p,{children:["This policy tracks whether an element has already been written or not. An error is flagged if multiple writes with different values occur to the same element. Default for: ",(0,i.jsx)(n.code,{children:"SharedMap"}),", ",(0,i.jsx)(n.code,{children:"SharedSet"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"init_verify",children:"INIT_VERIFY"}),"\n",(0,i.jsxs)(n.p,{children:["For SharedArray which can be initialized to a non-default value, this policy tracks whether an element is uninitialized, initialized, or written by a component. An error occurs if multiple writes with different values occur but overwriting the initialized value is allowed. If the element was not given an initial value, this policy is identical to ",(0,i.jsx)(n.code,{children:"FE_VERIFY"}),". Default for: ",(0,i.jsx)(n.code,{children:"SharedArray"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"no_verify",children:"NO_VERIFY"}),"\n",(0,i.jsx)(n.p,{children:"Under this policy, elements are not checked for duplicate writes. No ordering guarantee is provided so this policy is useful when components are guaranteed to not write the same element. Default for: None."}),"\n",(0,i.jsx)(n.h2,{id:"accessing-shared-objects-during-simulation",children:"Accessing shared objects during simulation"}),"\n",(0,i.jsx)(n.p,{children:"During simulation, components may read shared objects using mutex-free accessors."}),"\n",(0,i.jsx)(n.h2,{id:"cleaning-up-shared-objects",children:"Cleaning up shared objects"}),"\n",(0,i.jsx)(n.p,{children:"No clean up is needed, shared objects are managed by SST-Core."}),"\n",(0,i.jsx)(n.h2,{id:"example-using-a-sharedarray-to-randomize-physical-address-maps",children:"Example: Using a SharedArray to randomize physical address maps"}),"\n",(0,i.jsxs)(n.p,{children:["The following example comes from the ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/elements/miranda/intro",children:"miranda"})," element library and is an example of one (or a few) components populating a shared object for consumption by all components of the same type. Miranda simulates a processor core running a workload generated by a synthetic trace. Each miranda core is a separate component and during construction, the cores generate a lookup table to control memory page mapping.\nThe page table uses a SharedArray to avoid having to replicate the same large table at each component. The table is generated using a deterministic mapping defined in the miranda parameters. At least one miranda component populates the table and the remaining ones read it to perform virtual to physical page translations during simulation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'class MirandaMemoryManager {\npublic:\n    MirandaMemoryManager(...)\n    {\n        //highlight-start\n        // Initialize the pageMap to have one entry for each page in memory (pageCount)\n        int order = pageMap.initialize("miranda_pagemap", pageCount);\n        //highlight-end\n\n        /* If order == 0, this is the first component on its rank to initialize this shared array.\n         * As an optimization, to avoid mutex contention, if another miranda component has already \n         * initialized the array, then this miranda component will not initialize it.\n         * If miranda components happen to be placed on different ranks, multiple components will \n         * populate the array. However, they generate identical mappings so no write conflict arises.\n         */\n        if (order == 0) { \n            // Generate a local array of the mappings\n            uint64_t * pageArr = (uint64_t*) malloc(pageCount * sizeof(uint64_t));\n            for (uint64_t i = 0; i < pageCount; ++i>) {\n                pageArr[i] = ... /* See sst-elements/src/sst/elements/miranda/mirandaMemMgr.h for full code */\n            }\n\n            for (int i = 0; i < pageCount; ++i) {\n                //highlight-next-line\n                pageMap.write(i, pageArr[i]);\n            }\n        }\n    }\n\n    uint64_t mapAddress(const uint64_t addrIn) const {\n        // Compute virtual page index\n        const uint64_t pageOffset = addrIn % pageSize;\n        const uint64_t virtualPageStart = (addrIn - pageOffset) / pageSize;\n\n        //highlight-start\n        // Lookup physical address for the given virtual page using the SharedArray\n        const uint64_t physAddress = pageMap[virtualPageStart] + pageOffset;\n        //highlight-end\n\n        return physAddress;\n    }\n\nprivate:\n    uint64_t pageSize;\n    uint64_t pageCount;\n    uint64_t maxMemoryAddress;\n    SST::Output* output;\n    //highlight-next-line\n    Shared::SharedArray<uint64_t> pageMap;\n};\n\n'})}),"\n",(0,i.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/sharedArray.h>\n// OR\n#include <sst/core/sharedMap.h>\n// OR\n#include <sst/core/sharedSet.h>\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(96540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);