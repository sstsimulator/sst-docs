"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[52562],{14584:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"core/serialization/overview","title":"Serialization","description":"SST uses serialization in three different contexts during simulation:","source":"@site/../docs/core/serialization/overview.md","sourceDirName":"core/serialization","slug":"/core/serialization/overview","permalink":"/sst-docs/docs/core/serialization/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/serialization/overview.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"Serialization"},"sidebar":"core","previous":{"title":"simulationSignalShutdown","permalink":"/sst-docs/docs/core/realtime/simulationSignalShutdown"},"next":{"title":"Shared Objects","permalink":"/sst-docs/docs/core/sharedobj/overview"}}');var r=n(74848),a=n(28453);const l={title:"Serialization"},o=void 0,t={},d=[{value:"When does a class need to be serializable?",id:"when-does-a-class-need-to-be-serializable",level:2},{value:"How do I make a class serializable?",id:"how-do-i-make-a-class-serializable",level:2},{value:"Serialization guide",id:"serialization-guide",level:2},{value:"<code>serialize_order</code>",id:"serialize_order",level:3},{value:"SerOption",id:"seroption",level:4},{value:"When serialization and deserialization differ",id:"when-serialization-and-deserialization-differ",level:4}];function c(e){const i={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"SST uses serialization in three different contexts during simulation:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["When transferring ",(0,r.jsx)(i.code,{children:"SST::Events"})," between parallel processes"]}),"\n",(0,r.jsx)(i.li,{children:"For checkpoint/restart"}),"\n",(0,r.jsx)(i.li,{children:"To map an object's state, for example, for introspection and modification in an interactive console"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["SST provides a serialization framework for elements, however elements need to manually specify how they should be serialized. In most cases, this is as simple as adding a special ",(0,r.jsx)(i.code,{children:"serialize_order"})," function and passing each of the class's data members to the ",(0,r.jsx)(i.code,{children:"SST_SER"})," macro as shown."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"void serialize_order(SST::Core::Serialization::serializer& ser) {\n    SST_SER(var0);\n    SST_SER(var1);\n    SST_SER(var2);\n    // ... and so on\n}\n"})}),"\n",(0,r.jsx)(i.p,{children:"While SST performs serialization slightly differently for each context, a class only needs to implement serialization once to support all three uses."}),"\n",(0,r.jsx)(i.h2,{id:"when-does-a-class-need-to-be-serializable",children:"When does a class need to be serializable?"}),"\n",(0,r.jsxs)(i.p,{children:["Will an object of your class type ever be sent over a Link between Components, either because the class inherits from ",(0,r.jsx)(i.code,{children:"SST::Event"})," or is a data member of an ",(0,r.jsx)(i.code,{children:"SST::Event"}),"? You need to support serialization."]}),"\n",(0,r.jsxs)(i.p,{children:["Do you want to enable checkpoint/restart of your simulation as a whole? ",(0,r.jsx)(i.em,{children:"Every"})," object that will be checkpointed needs to be serializable."]}),"\n",(0,r.jsx)(i.p,{children:"Do you want to enable introspection and/or modification of your class during simulation via an interactive console? The class needs to be serializable. This is the only case in which you may choose to partially serialize the class. Only serialized data members will be visible during introspection."}),"\n",(0,r.jsxs)(i.p,{children:["If the class is not an ",(0,r.jsx)(i.code,{children:"Event"}),", and you do not intend to support checkpoint or interactive introspection, then it does not need to be serializable."]}),"\n",(0,r.jsx)(i.h2,{id:"how-do-i-make-a-class-serializable",children:"How do I make a class serializable?"}),"\n",(0,r.jsx)(i.p,{children:"Provide a function that SST can use to serialize the class. The specifics depend on the class that needs to be serialized."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Case 1: Your class inherits from an SST element class or other SST type such as Event"})}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["Implement a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function in your class."]}),"\n",(0,r.jsxs)(i.li,{children:["Add a serialization macro to the class's header.","\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ImplementSerializable(class_name)"}),": For classes that are serializable"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ImplementVirtualSerializable(class_name)"}),": For abstract classes that are serializable"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"NotSerializable(class_name)"}),": If a class is not serializable, it needs to declare this macro instead of the above. You can then  skip implementing a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Case 2: Your class is not polymorphic"})}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["Implement a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function for your class."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Case 3: Your class is polymorphic and does not inherit from a serializable class"})}),"\n",(0,r.jsx)(i.p,{children:"In this case you have two options:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Inherit from ",(0,r.jsx)(i.code,{children:"SST::Core::Serialization::Serializable"}),' and follow the steps in "Case 1".']}),"\n",(0,r.jsx)(i.li,{children:"Implement a serialize_impl"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"serialization-guide",children:"Serialization guide"}),"\n",(0,r.jsxs)(i.p,{children:["This guide first describes the ",(0,r.jsx)(i.code,{children:"serialize_order"})," function and then discusses the particulars of serialization for event exchange, checkpoint/restart, and mapping."]}),"\n",(0,r.jsx)(i.h3,{id:"serialize_order",children:(0,r.jsx)(i.code,{children:"serialize_order"})}),"\n",(0,r.jsxs)(i.p,{children:["Many classes can be made serializable by adding a ",(0,r.jsx)(i.code,{children:"serialize_order"})," function. This function serializes and deserializes all data members belonging to the class using a special ",(0,r.jsx)(i.code,{children:"SST_SER"})," macro. The macro accepts data of many types including:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["All POD types (",(0,r.jsx)(i.code,{children:"bool"}),", ",(0,r.jsx)(i.code,{children:"int"}),", etc.) and ",(0,r.jsx)(i.code,{children:"std::string"})]}),"\n",(0,r.jsxs)(i.li,{children:["All standard library containers (",(0,r.jsx)(i.code,{children:"std::vector"}),", ",(0,r.jsx)(i.code,{children:"std::map"}),", ",(0,r.jsx)(i.code,{children:"std::array"}),", etc.)"]}),"\n",(0,r.jsxs)(i.li,{children:["Standard library types: ",(0,r.jsx)(i.code,{children:"std::atomic"}),", ",(0,r.jsx)(i.code,{children:"std::pair"}),", ",(0,r.jsx)(i.code,{children:"std::tuple"})]}),"\n",(0,r.jsxs)(i.li,{children:["SST types: ",(0,r.jsx)(i.code,{children:"Link"}),", ",(0,r.jsx)(i.code,{children:"TimeConverter"}),", ",(0,r.jsx)(i.code,{children:"Output"}),", ",(0,r.jsx)(i.code,{children:"RNG:Random"}),", ",(0,r.jsx)(i.code,{children:"RNG:RandomDistribution"}),", ",(0,r.jsx)(i.code,{children:"SharedArray"}),", ",(0,r.jsx)(i.code,{children:"SharedMap"}),", ",(0,r.jsx)(i.code,{children:"SharedSet"}),", ",(0,r.jsx)(i.code,{children:"UnitAlgebra"}),", ",(0,r.jsx)(i.code,{children:"Statistic"}),", ",(0,r.jsx)(i.code,{children:"StatisticOutput"})]}),"\n",(0,r.jsxs)(i.li,{children:["SST Handlers: ",(0,r.jsx)(i.code,{children:"Clock::Handler2"}),", ",(0,r.jsx)(i.code,{children:"Event::Handler2"})]}),"\n",(0,r.jsxs)(i.li,{children:["SST Interfaces: ",(0,r.jsx)(i.code,{children:"SimpleNetwork"}),", ",(0,r.jsx)(i.code,{children:"StandardMem"})]}),"\n",(0,r.jsx)(i.li,{children:"Any object type for which you have implemented serialization"}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["The serialize_order function looks like this. If your class inherits from another, it should call that class's serialize_order function ",(0,r.jsx)(i.em,{children:"before"})," it serializes its own data."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"virtual void serialize_order(SST::Core::Serialization::serializer& ser) override {\n    Base::Class:serialize_order(ser);\n    SST_SER(data0);\n    SST_SER(data1);\n    SST_SER(data2);\n    SST_SER(data3);\n    // ... and so on\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"SST_SER"})," macros have the following syntax."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"SST_SER(variable);\nSST_SER(variable, options);\nSST_SER_NAME(variable, mapping_name, options);\n"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"variable"})," is required and is the variable being serialized. ",(0,r.jsx)(i.code,{children:"options"})," may be passed if needed as described in the next section. ",(0,r.jsx)(i.code,{children:"mapping_name"})," allows providing a different (e.g., more user-friendly) name than the variable name when mapping the object."]}),"\n",(0,r.jsx)(i.admonition,{type:"warning",children:(0,r.jsxs)(i.p,{children:["Do not change the name of the serializer variable ",(0,r.jsx)(i.code,{children:"ser"})," that is passed to ",(0,r.jsx)(i.code,{children:"serialize_order"}),". The ",(0,r.jsx)(i.code,{children:"SST_SER"})," macro uses it."]})}),"\n",(0,r.jsx)(i.h4,{id:"seroption",children:"SerOption"}),"\n",(0,r.jsxs)(i.p,{children:["Depending on how a variable is used, you may need to pass options to ",(0,r.jsx)(i.code,{children:"SST_SER"})," to control serialization. Options and when to use them are as follows. Options may be combined with the ",(0,r.jsx)(i.code,{children:"|"})," operator."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.em,{children:"Note: All options are ignored during event serialization"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::as_ptr"}),"\nUse this option if you are serializing a non-pointer variable but a pointer to the variable will also be serialized. The non-pointer must be serialized ",(0,r.jsx)(i.em,{children:"before"})," the pointer."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::as_ptr_elem"}),"\nUse this to pass the ",(0,r.jsx)(i.code,{children:"as_ptr"})," option to the contents of a container"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::map_read_only"}),"\nPrevents the variable's value from being modified when mapping an object."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SerOption::no_map"}),"\nIndicates that a variable should not be included when mapping the object."]}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"when-serialization-and-deserialization-differ",children:"When serialization and deserialization differ"}),"\n",(0,r.jsxs)(i.p,{children:["In many cases, calling ",(0,r.jsx)(i.code,{children:"SST_SER"})," will be sufficient for both serialization and deserialization. However, in some instances, particularly with dynamically allocated variables, you may need to do something differently depending on whether SST is serializing or deserializing. To detect what SST is doing, query the serializer's mode. There are four modes:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"SIZER"})," Determine the size of the buffer to allocate"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"PACK"})," Serialize the data into the buffer"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"UNPACK"})," Deserialize the data"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"MAP"})," Map the object by serializing it"]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["During event serialization and checkpoint, the serializer will enter SIZER and then PACK mode. During event deserialization and restart, the serializer will enter UNPACK mode. During mapping, the serializer will enter MAP mode. Query the mode using ",(0,r.jsx)(i.code,{children:"ser.mode()"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>o});var s=n(96540);const r={},a=s.createContext(r);function l(e){const i=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(a.Provider,{value:i},e.children)}}}]);