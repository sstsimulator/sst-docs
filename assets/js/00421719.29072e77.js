"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[22287],{22557:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"elements/memHierarchy/connecting","title":"Connecting to MemHierarchy","description":"To connect a processor, MMIO device, or other component to memHierarchy, load MemHierarchy\'s memHierarchy.StandardInterface into a SubComponent Slot. Once it is loaded, you can interact with the interface using function calls to send and receive memory requests. Additionally, you may register your endpoint as an MMIO device if you wish which allows other components that are reachable from your device to interact with it via Read and Write requests.","source":"@site/../docs/elements/memHierarchy/connecting.md","sourceDirName":"elements/memHierarchy","slug":"/elements/memHierarchy/connecting","permalink":"/sst-docs/docs/elements/memHierarchy/connecting","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/memHierarchy/connecting.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"Connecting to MemHierarchy"},"sidebar":"elements","previous":{"title":"StandardMem Interface","permalink":"/sst-docs/docs/elements/memHierarchy/stdmem"},"next":{"title":"Caches","permalink":"/sst-docs/docs/elements/memHierarchy/cache"}}');var r=t(74848),a=t(28453);const s={title:"Connecting to MemHierarchy"},i=void 0,c={},d=[{value:"Direct, Bus, and Network connectivity",id:"direct-bus-and-network-connectivity",level:3},{value:"Modify your component to load <code>memeHierarchy.StandardInterface</code>",id:"modify-your-component-to-load-memehierarchystandardinterface",level:2},{value:"(OPTIONAL) Register as an MMIO device",id:"optional-register-as-an-mmio-device",level:3},{value:"Connecting to memHierarchy in your input configuration",id:"connecting-to-memhierarchy-in-your-input-configuration",level:2},{value:"Using an anonymous subcomponent (if supported)",id:"using-an-anonymous-subcomponent-if-supported",level:3},{value:"Using a user-defined subcomponent",id:"using-a-user-defined-subcomponent",level:3},{value:"To connect directly to a memHierarchy component (Cache, Bus, MemoryController, etc.)",id:"to-connect-directly-to-a-memhierarchy-component-cache-bus-memorycontroller-etc",level:4},{value:"To connect through a network to a memHierarchy component",id:"to-connect-through-a-network-to-a-memhierarchy-component",level:4}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["To connect a processor, MMIO device, or other component to memHierarchy, load MemHierarchy's ",(0,r.jsx)(n.code,{children:"memHierarchy.StandardInterface"})," into a ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/eli/document/sst_eli_document_subcomponent_slots",children:"SubComponent Slot"}),". Once it is loaded, you can interact with the interface using function calls to send and receive memory requests. Additionally, you may register your endpoint as an MMIO device if you wish which allows other components that are reachable from your device to interact with it via Read and Write requests."]}),"\n",(0,r.jsxs)(n.p,{children:["For more detail on ",(0,r.jsx)(n.code,{children:"memHierarchy.StandardInterface"}),"'s implementation of ",(0,r.jsx)(n.code,{children:"SST::Interfaces::StandardMem"})," ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/elements/memHierarchy/stdmem",children:"see the guide here."}),". For API documentation of ",(0,r.jsx)(n.code,{children:"SST::Interfaces::StandardMem"})," ",(0,r.jsx)(n.a,{href:"../../core/",children:"see the documentation page."})]}),"\n",(0,r.jsx)(n.h3,{id:"direct-bus-and-network-connectivity",children:"Direct, Bus, and Network connectivity"}),"\n",(0,r.jsxs)(n.p,{children:["The StandardInterface subcomponent needs to be connected to a memHierarchy subsystem. It can be connected directly to a memHierarchy component (Bus, Cache, MemoryController, etc) or it can be connected to a network that implements the ",(0,r.jsx)(n.code,{children:"SST::Core::SimpleNetwork"})," API and has memHierarchy components on it. The decision can be made at runtime using by configuring the StandardInterface differently in an SST input file."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recall:"})," SST subcomponents can be loaded as ",(0,r.jsx)(n.em,{children:"user subcomponents"})," that you explicitly load in an input file OR they a component can load a subcomponent ",(0,r.jsx)(n.em,{children:"anonymously"})," by instantiating the subcomponent itself. StandardInterface can be instantiated in both ways."]}),"\n",(0,r.jsxs)(n.h2,{id:"modify-your-component-to-load-memehierarchystandardinterface",children:["Modify your component to load ",(0,r.jsx)(n.code,{children:"memeHierarchy.StandardInterface"})]}),"\n",(0,r.jsxs)(n.p,{children:["For an example, take a look at miranda's ",(0,r.jsx)(n.code,{children:"RequestGenCPU"})," (sst-elements/src/sst/elements/miranda/mirandaCPU.h and mirandaCPU.cc). Miranda is a processor that uses a request generator to generate a stream of memory accesses. The variable names are slightly different from below (e.g., 'cache_link' instead of 'memory' for the pointer to a StandardInterface instance) but the process is the same. You can also look at MemHierarchy's test CPU which is located at sst-elements/src/sst/elements/memHierarchy/testcpu/standardCPU.h and standardCPU.cc. The test CPU generates a random stream of memory accesses and is used by memHierarchy tests."]}),"\n",(0,r.jsx)(n.p,{children:"The following class header snippet shows additions needed to load a subcomponent class."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lines 5-7"})," Add a new subcomponent slot using the documentation macro"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Line 10"})," This is a callback function used to deliver ",(0,r.jsx)(n.code,{children:"StandardMem::Request"})," to your component"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lines 13-16"}),' These lifecycle functions need to be added to your component. If you are loading the interface into a subcomponent, you also need to ensure that all "parent" subcomponents, including the ultimate parent component, also implement these functions and invoke them for your subcomponent. See ',(0,r.jsx)(n.a,{href:"/sst-docs/docs/guides/concepts/lifecycle",children:"SST lifecycle"})," for more information."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lines 20-34"})," This class is used by the callback function in line 10 to dispatch Requests by type. Add a ",(0,r.jsx)(n.code,{children:"handle"})," function for each ",(0,r.jsx)(n.code,{children:"StandardMem::Request"})," type your component can handle. For example, if you have a CPU that sends Reads and Writes, you would need to support ReadResponse and WriteResponse."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Line 36"})," Pointer to the loaded StandardInterface subcomponent."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Line 37"})," Pointer to an instance of the ",(0,r.jsx)(n.code,{children:"ExampleMemHandlers"})," class."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="ExampleComponent showing additions needed to support StandardInterface" showLineNumbers',children:'class ExampleComponent : public SST::Component {\npublic:\n    // Other documentation macros\n\n    SST_ELI_DOCUMENT_SUBCOMPONENT_SLOTS(\n        { "memory", "Interface to a memory hierarchy", "SST::Interfaces::StandardMem" }\n    )\n\n    // A callback that StandardMem will use to deliver incoming events\n    void memoryCallback(SST::Interfaces::StandardMem::Request* request); \n\n    // Add these SST lifecycle functions if you do not already have them\n    void init(unsigned int phase) override;\n    void setup() override;\n    void complete(unsigned int phase) override;\n    void finish() override;\n\nprivate:\n    // A class to handle StandardMem::Request by type\n    class ExampleMemHandlers : public SST::Interfaces::StandardMem::RequestHandler {\n    public:\n        friend class ExampleComponent; // Friending the component class is often useful\n\n        ExampleMemHandlers(ExampleComponent* comp, SST::Output* out) : \n                SST::Interfaces::StandardMem::RequestHandler(out), comp(comp) {}\n        \n        virtual ~ExampleMemHandlers() {}\n\n        // Add a stub for each StandardMem::Request type your component may handle\n        virtual void handle(SS::Interfaces::StandardMem::ReadResp* read_resp) override;\n        virtual void handle(SS::Interfaces::StandardMem::WriteResp* write_resp) override;\n\n        ExampleComponent* comp;\n    };\n\n    SST::Interfaces::StandardMem *memory; // Pointer to StandardMem interface\n    ExampleMemHandlers* handlers; // Pointer to an instance of the request handler class\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["There are two common ways to load ",(0,r.jsx)(n.code,{children:"memHierarchy.StandardInterface"}),". The first is to require that it be configured in the SST input file. The second is to check whether the subcomponent was configured in the input file and provide a default configuration if not. Because ",(0,r.jsx)(n.code,{children:"StandardInterface"})," needs a port, if it is not configured in the input file, your component must provide a port for ",(0,r.jsx)(n.code,{children:"StandardInterface"})," to use. If it is configured in the input file, then ",(0,r.jsx)(n.code,{children:"StandardInterface"})," can use its own port."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["Note: StandardMem needs a ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/timeconverter/class",children:(0,r.jsx)(n.code,{children:"TimeConverter"})}),". If your component registers a clock, use the TimeConverter returned by the registration call. If your component does not register a clock, create a TimeConverter to use. This is only used if you add extra latency when sending events so in many cases the value will not matter."]})}),"\n",(0,r.jsx)(n.p,{children:"To require that the subcomponent be configured in the input file, use this code snippet in your component's constructor."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Load memHierarchy.standardMem as a user subcomponent"',children:'// Acquire a timeconverter using one of these methods\n// SST::TimeConverter timeconverter = registerClock(rate, handler);\n// OR\n// SST::TimeConverter timeconverter = getTimeConverter("1ns");\n\n// Function callback for handling requests\nauto callback = new SST::StandardMem::Handler<ExampleComponent>(this, &ExampleComponent::memoryCallback);\n\nmemory = loadUserSubComponent<SST::Interfaces::StandardMem>("memory", \n        SST::ComponentInfo::SHARE_NONE, &timeconverter, callback);\n\nsst_assert(memory, CALL_INFO, -1, "Error: No subcomponent was found in the \'memory\' subcomponent slot.");\n\nhandlers = new ExampleRequestHandlers(this, &(getSimulationOutput())); // Any output object is fine\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To provide an optional default configuration, add this snippet to the constructor instead. Replace ",(0,r.jsx)(n.code,{children:"port_to_use"})," with a port provided by the loading component. That port will need to be connected to a memHierarchy component or to a network with other memHierarchy components in the SST input file."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Load memHierarchy.standardMem as a user subcomponent with a default if not declared"',children:'// Acquire a timeconverter using one of the following\n// SST::TimeConverter timeconverter = registerClock(rate, handler);\n// OR\n// SST::TimeConverter timeconverter = getTimeConverter("1ns");\n\n// Function callback for handling requests\nauto callback = new SST::StandardMem::Handler<ExampleComponent>(this, &ExampleComponent::memoryCallback);\n\nmemory = loadUserSubComponent<SST::Interfaces::StandardMem>("memory", SST::ComponentInfo::SHARE_NONE, &timeconverter, callback);\n\nif (!memory) { // Fallback path\n    Params stdmem_params;\n    stdmem_params.insert("port", "port_to_use"); // Replace port_to_use with a port belonging to this component \n\t\n    memory = loadAnonymousSubComponent<Interfaces::StandardMem>("memHierarchy.standardMem", "memory", \n            0, ComponentInfo::SHARE_PORTS, stdmem_params, &timeconverter, callback);\n\n    sst_assert(memory, CALL_INFO, -1, \n            "Error: No subcomponent was found in the \'memory\' subcomponent slot and unable to load a default.");\n}\n\nhandlers = new ExampleRequestHandlers(this, &(getSimulationOutput())); // Any output object is fine\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, implement or modify the implementation of for each of the four lifecycle functions. Additionally, implement the ",(0,r.jsx)(n.code,{children:"StandardMem::Request"})," callback and handler functions as shown."]}),"\n",(0,r.jsx)(n.admonition,{title:"Important",type:"info",children:(0,r.jsxs)(n.p,{children:["Once an event is delivered via the callback, ",(0,r.jsx)(n.em,{children:"your class owns it and is responsible for deleting it"}),"."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="ExampleComponent function implementations"',children:"\n// Modify and/or implement the four lifecycle functions\nvoid ExampleComponent::init(unsigned int phase) {\n    memory->init(phase);\n}\n\nvoid ExampleComponent::setup() {\n    memory->setup();\n}\n\nvoid ExampleComponent::complete(unsigned int phase) {\n    memory->complete(phase);\n}\n\nvoid ExampleComponent::finish() {\n    memory->finish();\n}\n\n// Use callback to dispatch event to handlers\nvoid ExampleComponent::memoryCallback(StandardMem::Request* req) {\n    req->handle(handlers);\n    delete req;\n}\n\n// Implement handler for each StandardMem::Request type as needed\nvoid ExampleComponent::ExampleMemHandlers::handle(SST::Interfaces::StandardMem::ReadResp* read_resp) {\n    /* Do whatever processing of the read response that you need */\n}\n\nvoid ExampleComponent::ExampleMemHandlers::handle(SST::Interfaces::StandardMem::WriteResp* write_resp) {\n    /* Do whatever processing of the write response that you need */\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"optional-register-as-an-mmio-device",children:"(OPTIONAL) Register as an MMIO device"}),"\n",(0,r.jsxs)(n.p,{children:["You can optionally register your component as an MMIO device using the interface's ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/iface/StandardMem/setMemoryMappedAddressRegion",children:(0,r.jsx)(n.code,{children:"setMemoryMappedAddressRegion()"})}),". This must be called in your component's constructor. The address you give to your device must not overlap with any other mapped address, including memories and MMIO devices. MemHierarchy will always treat accesses to MMIO addresses as noncacheable."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Map 8 bytes starting at address 0 to this device\nmemory->setMemoryMappedAddressRegion(0, 8);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"connecting-to-memhierarchy-in-your-input-configuration",children:"Connecting to memHierarchy in your input configuration"}),"\n",(0,r.jsx)(n.h3,{id:"using-an-anonymous-subcomponent-if-supported",children:"Using an anonymous subcomponent (if supported)"}),"\n",(0,r.jsx)(n.admonition,{title:"Important",type:"info",children:(0,r.jsx)(n.p,{children:"You cannot use this approach to connect to a network. Use user-defined subcomponents instead."})}),"\n",(0,r.jsxs)(n.p,{children:['If you are loading the subcomponent using the default "fallback" path described earlier, connect a port belonging to your component to a memHierarchy component as shown in the example. Ensure this is the same port you pass in the parameter object given to the ',(0,r.jsx)(n.code,{children:"loadAnonymousSubComponent"})," call in your component's constructor."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'cpu = sst.Component("ExampleComponent", "alibrary.ExampleComponent")\n\ncache = sst.Component("L1Cache", "memHierarchy.Cache")\n\nlink = sst.Link("link")\n# Replace port_to_connect with the SAME port name that you used\n# to configure the StandardInterface in your component\'s constructor\n#highlight-next-line\nlink.connect( (cpu, "port_to_connect", "1ns"), (cache, "highlink", "1ns") )\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-a-user-defined-subcomponent",children:"Using a user-defined subcomponent"}),"\n",(0,r.jsxs)(n.p,{children:["User-defined subcomponents are configured in the SST input file using ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/config/component/setSubComponent",children:(0,r.jsx)(n.code,{children:"setSubComponent()"})}),". Declaring the subcomponent in the input allows its port to be used and allows you to pass parameters to the interface if you wish."]}),"\n",(0,r.jsx)(n.h4,{id:"to-connect-directly-to-a-memhierarchy-component-cache-bus-memorycontroller-etc",children:"To connect directly to a memHierarchy component (Cache, Bus, MemoryController, etc.)"}),"\n",(0,r.jsxs)(n.p,{children:["Load the interface into your component and then connect the interface's ",(0,r.jsx)(n.code,{children:"lowlink"})," port to a memHierarchy component."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'cpu = sst.Component("ExampleComponent", "alibrary.ExampleComponent")\n#highlight-next-line\niface = cpu.setSubComponent("memory", "memHierarchy.standardInterface")\n\ncache = sst.Component("L1Cache", "memHierarchy.Cache")\n\nlink = sst.Link("link")\n#highlight-next-line\nlink.connect( (iface, "lowlink", "1ns"), (cache, "highlink", "1ns") ) \n'})}),"\n",(0,r.jsx)(n.h4,{id:"to-connect-through-a-network-to-a-memhierarchy-component",children:"To connect through a network to a memHierarchy component"}),"\n",(0,r.jsxs)(n.p,{children:["Any memHierarchy element (component or subcomponent) that connects to a network needs to use a MemNIC to manage the translation between memHierarchy events and SimpleNetwork events. You will need to load the ",(0,r.jsx)(n.code,{children:"StandardInterface"})," into your component and then load ",(0,r.jsx)(n.code,{children:"memHierarchy.MemNIC"})," into the ",(0,r.jsx)(n.code,{children:"StandardInterface"})," subcomponent. Connect the MemNIC's port to the network."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'cpu = sst.Component("ExampleComponent", "aLibrary.ExampleComponent")\niface = cpu.setSubComponent("memory", "memHierarchy.standardInterface")\n#highlight-start\ncpu_nic = iface.setSubComponent("lowlink", "memHierarchy.MemNIC")\ncpu_nic.addParams( ..params.. )\n#highlight-end\n\nrtr = sst.Component("router", "merlin.hr_router")\nrtr.addParams( ..params.. )\n\nlink = sst.Link("link")\n#highlight-next-line\nlink.connect( (cpu_nic, "port", "1ns"), (rtr, "port0", "1ns") )\n'})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var o=t(96540);const r={},a=o.createContext(r);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);