"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[77192],{28453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var r=n(96540);const i={},d=r.createContext(i);function t(e){const s=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(d.Provider,{value:s},e.children)}},29057:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"core/iface/StandardMem/req/writeunlock","title":"WriteUnlock","description":"Response Type StandardMem::WriteResp  &nbsp;","source":"@site/../docs/core/iface/StandardMem/req/writeunlock.md","sourceDirName":"core/iface/StandardMem/req","slug":"/core/iface/StandardMem/req/writeunlock","permalink":"/sst-docs/docs/core/iface/StandardMem/req/writeunlock","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/StandardMem/req/writeunlock.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1702928554000,"frontMatter":{"title":"WriteUnlock"},"sidebar":"core","previous":{"title":"ReadLock","permalink":"/sst-docs/docs/core/iface/StandardMem/req/readlock"},"next":{"title":"LoadLink","permalink":"/sst-docs/docs/core/iface/StandardMem/req/loadlink"}}');var i=n(74848),d=n(28453);const t={title:"WriteUnlock"},l=void 0,c={},a=[{value:"Member variables",id:"member-variables",level:2},{value:"Member functions",id:"member-functions",level:2},{value:"Defined in <code>Request</code> base class",id:"defined-in-request-base-class",level:3},{value:"Virtual functions inherited from the <code>Request</code> base class",id:"virtual-functions-inherited-from-the-request-base-class",level:3},{value:"makeResponse",id:"makeresponse",level:4},{value:"needsResponse",id:"needsresponse",level:4},{value:"convert",id:"convert",level:4},{value:"handle",id:"handle",level:4},{value:"getString",id:"getstring",level:4},{value:"Header",id:"header",level:2}];function o(e){const s={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"// Constructor\nSST::Interfaces::StandardMem::WriteUnlock(Addr pAddr, uint64_t size, std::vector<uint8_t> data, \n    bool posted = false, flags_t flags = 0, Addr vAddr = 0, Addr iPtr = 0, uint32_t tid = 0);\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Response Type"})," ",(0,i.jsx)(s.a,{href:"writeresp",children:"StandardMem::WriteResp"}),"  \xa0",(0,i.jsx)(s.br,{}),"\n",(0,i.jsx)(s.strong,{children:"Needs Response"})," Depends on the value of the ",(0,i.jsx)(s.code,{children:"posted"})," variable"]}),"\n",(0,i.jsxs)(s.p,{children:["The StandardMem::WriteUnlock request class defines a memory write that also unlocks an address. This request should always follow a ",(0,i.jsx)(s.a,{href:"readlock",children:"StandardMem::ReadLock"}),". Issuing a StandardMem::WriteUnlock without first issuing a StandardMem::ReadLock is incorrect behavior and particular StandardMem implementations may return a fatal error or ignore it, resulting in undefined behavior. An interface that receives this request should return a WriteResp response acknowledging the write completion if the request's ",(0,i.jsx)(s.code,{children:"posted"})," field is ",(0,i.jsx)(s.code,{children:"false"}),". Otherwise, no response is expected. The interface should also unlock the address. Fields for both a virtual and physical address are available, the interpretation of those fields is up to the underlying memory system model. ",(0,i.jsx)(s.code,{children:"physAddr"})," is however required in the constructor."]}),"\n",(0,i.jsx)(s.h2,{id:"member-variables",children:"Member variables"}),"\n",(0,i.jsxs)(s.p,{children:["Including those inherited from the ",(0,i.jsx)(s.code,{children:"StandardMem::Request"})," base class, ",(0,i.jsx)(s.code,{children:"StandardMem::WriteUnlock"})," includes the following member variables."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"id"})," (id_t) A request or response identifier. A request and its response contain the same identifier."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"flags"})," (flags_t) A 32-bit vector indicating any special flags added to the request"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"pAddr"})," (Addr) The physical starting byte address to write to"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"vAddr"})," (Addr) The virtual (if any) starting byte address to write the data to"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"size"})," (uint64_t) The number of bytes to write (same as size of data vector)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"data"})," (std::vector<uint8_t>) Bytes to write"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"posted"})," (bool) Whether the write is posted (does not require a response)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"iPtr"})," (Addr) An instruction pointer. This is optional metadata."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"tid"})," (uint32_t) An optional thread ID, can be used by memory systems if needed"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"member-functions",children:"Member functions"}),"\n",(0,i.jsxs)(s.h3,{id:"defined-in-request-base-class",children:["Defined in ",(0,i.jsx)(s.a,{href:"class",children:(0,i.jsx)(s.code,{children:"Request"})})," base class"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getId"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"setNoncacheable"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"unsetNoncacheable"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getNoncacheable"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"setSuccess"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"unsetSuccess"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getSuccess"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"setFail"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"unsetFail"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getFail"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"setTrace"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"unsetTrace"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getTrace"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"setFlag"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"unsetFlag"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getFlag"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"clearAllFlags"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getAllFlags"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"getFlagString"})}),"\n"]}),"\n",(0,i.jsxs)(s.h3,{id:"virtual-functions-inherited-from-the-request-base-class",children:["Virtual functions inherited from the ",(0,i.jsx)(s.a,{href:"class",children:(0,i.jsx)(s.code,{children:"Request"})})," base class"]}),"\n",(0,i.jsx)(s.h4,{id:"makeresponse",children:"makeResponse"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"Request* makeResponse();\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Creates a ",(0,i.jsx)(s.a,{href:"writeresp",children:"WriteResp"})," initialized as a response to this write request."]}),"\n",(0,i.jsx)(s.h4,{id:"needsresponse",children:"needsResponse"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"bool needsResponse();\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Returns ",(0,i.jsx)(s.code,{children:"false"})," if the ",(0,i.jsx)(s.code,{children:"posted"})," field is set to ",(0,i.jsx)(s.code,{children:"true"}),", other ",(0,i.jsx)(s.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(s.h4,{id:"convert",children:"convert"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"SST::Event* convert(RequestConverter* converter);\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Invokes ",(0,i.jsx)(s.code,{children:"convert()"})," on the supplied ",(0,i.jsx)(s.code,{children:"converter"})," visitor class to return an SST::Event in an implementation-specific format."]}),"\n",(0,i.jsx)(s.h4,{id:"handle",children:"handle"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"virtual void handle(RequestHandler* handler) =0;\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Invokes ",(0,i.jsx)(s.code,{children:"handle()"})," on the supplied ",(0,i.jsx)(s.code,{children:"handler"})," visitor class to handle the event according to type."]}),"\n",(0,i.jsx)(s.h4,{id:"getstring",children:"getString"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"virtual std::string getString() =0;\n"})}),"\n",(0,i.jsx)(s.p,{children:"Returns a formatted string listing all fields of the WriteUnlock."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sh",children:"Example Output:\nID: 817, Type: WriteUnlock, Flags: [], PhysAddr: 0x13240, VirtAddr: 0x13240, Size: 4, Posted: F, InstPtr: 0x10ed8, ThreadID: 0, Payload: 0x48656c6c\n"})}),"\n",(0,i.jsx)(s.h2,{id:"header",children:"Header"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-cpp",children:"#include <sst/core/interfaces/stdMem.h>\n"})})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);