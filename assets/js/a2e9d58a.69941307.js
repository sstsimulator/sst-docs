"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[85372],{5004:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"core/iface/StandardMem/send","title":"send","description":"Send a Request to the interface.","source":"@site/../docs/core/iface/StandardMem/send.md","sourceDirName":"core/iface/StandardMem","slug":"/core/iface/StandardMem/send","permalink":"/sst-docs/docs/core/iface/StandardMem/send","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/StandardMem/send.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1684522150000,"frontMatter":{"title":"send"},"sidebar":"core","previous":{"title":"recvUntimedData","permalink":"/sst-docs/docs/core/iface/StandardMem/recvUntimedData"},"next":{"title":"sendUntimedData","permalink":"/sst-docs/docs/core/iface/StandardMem/sendUntimedData"}}');var r=t(74848),a=t(28453);const d={title:"send"},i=void 0,c={},o=[{value:"Requirements",id:"requirements",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1: Implementing send() in a StandardMem interface",id:"example-1-implementing-send-in-a-standardmem-interface",level:3},{value:"Example 2: Using send() from an endpoint",id:"example-2-using-send-from-an-endpoint",level:3},{value:"Header",id:"header",level:2}];function l(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"virtual void send(Request* req) = 0;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Send a Request to the interface."}),"\n",(0,r.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Memory interface"})," \xa0",(0,r.jsx)(n.br,{}),"\n","Accept requests through this call. Requests cannot be refused so the interface must handle overflow internally."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Endpoint"})," \xa0",(0,r.jsx)(n.br,{}),"\n","Use this function to send requests to the memory system via the interface."]}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"req"})," (Request*) A Request to send to the memory system"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-1-implementing-send-in-a-standardmem-interface",children:"Example 1: Implementing send() in a StandardMem interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'"Excerpt from sst-elements/src/sst/elements/memHierarchy/standardInterface.cc"',children:"void StandardInterface::send(StandardMem::Request* req)\n{\n    // Convert req to memHierarchy's internal event type, 'MemEventBase'\n    MemEventBase* me = static_cast<MemEventBase*>(req->convert(converter_));\n    if (req->needsResponse())\n    {\n        requests_[me->getID()] = std::make_pair(req, me->getCmd()); /* Save the request so we can use it to generate a response later */\n    } else \n    {\n        delete req;\n    }\n\n    link_->send(me);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-2-using-send-from-an-endpoint",children:"Example 2: Using send() from an endpoint"}),"\n",(0,r.jsx)(n.p,{children:"StandardCPU issues memory transactions during its clock function, excerpted here."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/memHierarchy/testcpu/standardCPU.cc"',children:"bool standardCPU::clockTic ( Cycle_t )\n{\n    /* Bookkeeping here */\n\n    /* Generate a request if possible - pseudocode for brevity */\n    if ( /* conditions are right to generate a new request */ )\n    {\n        /* Randomly generate an address */\n        StandardMem::Addr addr = rng.generateNextUInt64();\n\n        uint32_t instNum = /* Randomly selected instruction type */\n        Interfaces::StandardMem::Request* req = create(/* Instruction with type instNum and address addr */);\n\n        memory->send(req);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/interfaces/stdMem.h>\n"})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>i});var s=t(96540);const r={},a=s.createContext(r);function d(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);