"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[84536],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var a=n(96540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}},84445:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"elements/balar/BalarInDepth","title":"Balar In Depth","description":"This doc provide some high level views on various aspects of balar.","source":"@site/../docs/elements/balar/BalarInDepth.md","sourceDirName":"elements/balar","slug":"/elements/balar/BalarInDepth","permalink":"/sst-docs/docs/elements/balar/BalarInDepth","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/balar/BalarInDepth.md","tags":[],"version":"current","lastUpdatedBy":"William-An","lastUpdatedAt":1728165658000,"frontMatter":{"title":"Balar In Depth"},"sidebar":"elements","previous":{"title":"Compiling RISCV + CUDA","permalink":"/sst-docs/docs/elements/balar/CompilingRISCVCUDA"},"next":{"title":"cacheTracer","permalink":"/sst-docs/docs/elements/cacheTracer/intro"}}');var r=n(74848),i=n(28453);const s={title:"Balar In Depth"},c=void 0,o={},l=[{value:"balar CUDA calls dispatch mechanism",id:"balar-cuda-calls-dispatch-mechanism",level:2},{value:"Custom CUDA runtime library",id:"custom-cuda-runtime-library",level:2},{value:"Trace-driven mode component setup",id:"trace-driven-mode-component-setup",level:2},{value:"Direct-execution mode component setup",id:"direct-execution-mode-component-setup",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",mermaid:"mermaid",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["This doc provide some high level views on various aspects of ",(0,r.jsx)(t.em,{children:"balar"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"balar-cuda-calls-dispatch-mechanism",children:"balar CUDA calls dispatch mechanism"}),"\n",(0,r.jsxs)(t.p,{children:["In ",(0,r.jsx)(t.em,{children:"balar"}),", every CUDA API call and return are represented by ",(0,r.jsx)(t.code,{children:"SST::BalarComponent::BalarCudaCallPacket_t"})," and ",(0,r.jsx)(t.code,{children:"SST::BalarComponent::BalarCudaCallReturnPacket_t"}),". These two structures contain necessary arguments for CUDA function calls and return values."]}),"\n",(0,r.jsxs)(t.p,{children:["Since ",(0,r.jsx)(t.em,{children:"balar"})," is a ",(0,r.jsx)(t.a,{href:"https://sst-simulator.org/sst-docs/docs/elements/memHierarchy/stdmem#mmio",children:"MMIO"})," (memory mapped IO) device, it receives CUDA call packets via incoming writes to its mapped address. Specifically, it follows the dispatch sequence as follow:"]}),"\n",(0,r.jsx)(t.mermaid,{value:"sequenceDiagram\n    autonumber\n    participant dmaEngine\n    participant balarMMIO\n    participant balarTestCPU\n    participant memory\n    balarTestCPU->>memory: Write CUDA API packet to<br/>scratch memory location\n    balarTestCPU->>balarMMIO: Write pointer to<br/>scratch memory location\n    balarMMIO->>dmaEngine: Issue a Read to<br/>retrieve the CUDA packet\n    dmaEngine->>balarMMIO: Return packet\n    balarMMIO->>balarMMIO: Call GPGPU-Sim functions\n    balarMMIO->>memory: Write CUDA return packet to pointer\n    balarMMIO->>balarTestCPU: Send response to the initial write "}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"BalarTestCPU"})," writes the pointer to the CUDA packet into ",(0,r.jsx)(t.em,{children:"balar"}),"'s MMIO address range, which ",(0,r.jsx)(t.em,{children:"balar"})," will use this to copy the actual packet content into simulator memory space."]})}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["With direct-execution, there are some differences with ",(0,r.jsx)(t.code,{children:"cudaMemcpy()"})," function calls. Specifically, ",(0,r.jsx)(t.em,{children:"balar"})," will need to copy data from SST memory system with ",(0,r.jsx)(t.code,{children:"cudaMemcpyHostToDevice"})," and copy data from simulator memory space into SST memory with ",(0,r.jsx)(t.code,{children:"cudaMemcpyDeviceToHost"})," using ",(0,r.jsx)(t.em,{children:"dmaEngine"}),"."]})}),"\n",(0,r.jsx)(t.h2,{id:"custom-cuda-runtime-library",children:"Custom CUDA runtime library"}),"\n",(0,r.jsxs)(t.p,{children:["Located in ",(0,r.jsx)(t.code,{children:"src/sst/elements/balar/tests/vanadisLLVMRISCV"}),", the custom runtime lib ",(0,r.jsx)(t.code,{children:"cuda_runtime_api_vanadis.cc"})," will be linked with CUDA programs. For most CUDA APIs, it will create ",(0,r.jsx)(t.code,{children:"SST::BalarComponent::BalarCudaCallPacket_t"})," packets and send pointers to the packets to ",(0,r.jsx)(t.em,{children:"balar"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["For each CUDA call using ",(0,r.jsx)(t.code,{children:"makeCudaCall()"}),", ",(0,r.jsx)(t.em,{children:"balar"})," will first map its MMIO into ",(0,r.jsx)(t.em,{children:"vanadis"}),"'s virtual memory with memory fencing ops first. The actual ",(0,r.jsx)(t.code,{children:"mmap"})," call is performed via inline assembly code to avoid invalid accesses into ",(0,r.jsx)(t.em,{children:"balar"}),"'s MMIO address due to OoO execution. ",(0,r.jsx)(t.em,{children:"Balar"})," will unmap immediately after pointer is written for the same reason."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["For blocking CUDA calls, ",(0,r.jsx)(t.em,{children:"balar"})," will poll on the last CUDA API return status via ",(0,r.jsx)(t.code,{children:"readLastCudaStatus()"})," until the operation is completed."]}),"\n",(0,r.jsxs)(t.li,{children:["For non-blocking CUDA calls, ",(0,r.jsx)(t.em,{children:"balar"})," will return immediately."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"trace-driven-mode-component-setup",children:"Trace-driven mode component setup"}),"\n",(0,r.jsxs)(t.p,{children:["We provided a config script ",(0,r.jsx)(t.code,{children:"src/sst/elements/balar/tests/testBalar-testcpu.py"})," to run with trace information. The configuration graph roughly looks like this:"]}),"\n",(0,r.jsx)(t.mermaid,{value:"flowchart TD\n\tbalarTestCPU\n\tbalarMMIO\n\tdmaEngine\n\tmemory\n\trouter\n\tbalarTestCPU <--\x3e router\n\tbalarMMIO <--mmio_iface--\x3e router\n\tdmaEngine <--mem_iface--\x3e router\n\tdmaEngine <--mmio_iface--\x3e router\n\tmemory <--\x3e router"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"dmaEngine"})," has two memory interfaces. One for receiving commands (",(0,r.jsx)(t.code,{children:"mmio_iface"}),") and the other is used to access data (",(0,r.jsx)(t.code,{children:"mem_iface"}),")."]}),"\n",(0,r.jsx)(t.h2,{id:"direct-execution-mode-component-setup",children:"Direct-execution mode component setup"}),"\n",(0,r.jsxs)(t.p,{children:["For direct-execution with ",(0,r.jsx)(t.em,{children:"vanadis"}),", the config script is at ",(0,r.jsx)(t.code,{children:"src/sst/elements/balar/tests/testBalar-vanadis.py"}),", with configuration graph:"]}),"\n",(0,r.jsx)(t.mermaid,{value:'flowchart TD\n\tvanadisCore\n\tcoreTLB\n\tcoreCache\n\tvanadisOS\n\tosMMU\n\tbalar\n\tbalarTLB\n\tdmaEngine\n\tmemory\n\trouter\n\tcoreCacheBus{{coreCacheBus}}\n\n\tsubgraph " "\n\t\tdirection LR\n\t\tsubgraph VanadisCPU\n\t\t\tdirection TB\n\t\t\tvanadisCore <--\x3e coreTLB\n\t\t\tcoreTLB <--\x3e coreCacheBus\n\t\t\tcoreCacheBus <--\x3e coreCache\n\t\tend\n\t\t\n\t\tsubgraph OS\n\t\t\tdirection TB\n\t\t\tvanadisOS <--\x3e osMMU\n\t\tend\n\t\tbalarTLB <--\x3e coreCacheBus\n\t\tbalarTLB <--MMU::m_nicTlbLink--\x3e osMMU\n\t\tvanadisCore <--\x3e vanadisOS\n\t\tcoreTLB <--MMU::m_coreLinks--\x3e osMMU\n\t\tsubgraph Balar\n\t\t\tdirection TB\n\t\t\tdmaEngine <--\x3e balarTLB\n\t\t\tbalar\n\t\tend\n\tend\n\tbalar <--mmio interface--\x3e router\n\tcoreCache <--\x3e router\n\tdmaEngine <--mmio interface--\x3e router\n\trouter <--\x3e memory'}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"Some details are omitted for simplicity."})}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"balar"})," needs a TLB as ",(0,r.jsx)(t.em,{children:"vanadis"})," works in virtual memory space. That part of the configuration script is based on the test example for ",(0,r.jsx)(t.a,{href:"/sst-docs/docs/elements/rdmaNic/intro",children:(0,r.jsx)(t.em,{children:"rdmaNic"})}),"."]})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);