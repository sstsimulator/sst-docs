"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[12441],{28453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>l});var r=s(96540);const n={},o=r.createContext(n);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(o.Provider,{value:t},e.children)}},54249:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"core/output/verbose","title":"verbose","description":"Output the verbose message with formatting as specified by the format parameter. Output will only occur if specified outputlevel and outputbits satisfy the verboselevel and verbosemask of the Output object. The output will be prepended with the expanded prefix set in either the constructor or init() function.","source":"@site/../docs/core/output/verbose.md","sourceDirName":"core/output","slug":"/core/output/verbose","permalink":"/sst-docs/docs/core/output/verbose","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/output/verbose.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1695940750000,"frontMatter":{"title":"verbose"},"sidebar":"core","previous":{"title":"output","permalink":"/sst-docs/docs/core/output/"},"next":{"title":"verbosePrefix","permalink":"/sst-docs/docs/core/output/verbosePrefix"}}');var n=s(74848),o=s(28453);const i={title:"verbose"},l=void 0,c={},u=[{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Header",id:"header",level:2}];function a(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"void verbose(uint32_t line, const char* file, const char* func, uint32_t output_level, \n             uint32_t output_bits, const char* format, ...) const;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Output the verbose message with formatting as specified by the format parameter. Output will only occur if specified output_level and output_bits satisfy the verbose_level and verbose_mask of the Output object. The output will be prepended with the expanded prefix set in either the ",(0,n.jsx)(t.a,{href:"constructor",children:"constructor"})," or ",(0,n.jsx)(t.a,{href:"init",children:"init()"})," function."]}),"\n",(0,n.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"line"})," (uint32_t) Line number of calling function (use CALL_INFO macro)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"file"})," (const char*) File name of calling function (use CALL_INFO macro)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"func"})," (const char*) Name of calling function (use CALL_INFO macro)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"output_level"})," (uint32_t) For output to occur, output_level must be less than or equal to the Output's verbose_level"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"output_bits"})," (uint32_t) For output to occur, all bits set in this parameter must also be set in the Output's verbose_mask. It uses this logic: if (",(0,n.jsx)(t.code,{children:"~verbose_mask & output_bits == 0"}),"), then output is enabled."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"format"})," (const char*) Format string. All valid formats for printf are available"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"..."})," (variable) Arguments for format string"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(t.h3,{id:"example-1",children:"Example 1"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'// print message if out\'s verbose_level >= 16\nout->verbose(CALL_INFO, 16, 0, "Configured to print rank to block maps\\n");\n'})}),"\n",(0,n.jsx)(t.h3,{id:"example-2",children:"Example 2"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'// print message if output\'s verbose_level >= 1\noutput->verbose(CALL_INFO, 1, 0, "Configuring for %" PRIu32 " memory levels; default level is %" PRIu32 ".\\n", memoryLevels, defaultLevel);\n'})}),"\n",(0,n.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/output.h>\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}}}]);