"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[69455],{28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>l});var n=s(96540);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},49136:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"core/iface/SimpleNetwork/Request","title":"Request","description":"The Request class defines the data structure used to send and receives events via a network. Each Request includes a number of metadata fields used by networks (e.g., source and destination information) as well as payload. The payload is an SST::Event pointer so that any event can be wrapped in the Request type and the payload delivered to the other side of the network. Requests are serializable and may be passed over SST Links.","source":"@site/../docs/core/iface/SimpleNetwork/Request.md","sourceDirName":"core/iface/SimpleNetwork","slug":"/core/iface/SimpleNetwork/Request","permalink":"/sst-docs/docs/core/iface/SimpleNetwork/Request","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/SimpleNetwork/Request.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1684522150000,"frontMatter":{"title":"Request"},"sidebar":"core","previous":{"title":"NetworkInspector","permalink":"/sst-docs/docs/core/iface/SimpleNetwork/NetworkInspector"},"next":{"title":"SST::Interfaces::StandardMem","permalink":"/sst-docs/docs/core/iface/StandardMem/class"}}');var a=s(74848),i=s(28453);const r={title:"Request"},l=void 0,o={},d=[{value:"Request Metadata",id:"request-metadata",level:2},{value:"Payloads",id:"payloads",level:2},{value:"givePayload",id:"givepayload",level:3},{value:"takePayload",id:"takepayload",level:3},{value:"inspectPayload",id:"inspectpayload",level:3},{value:"Debug and Tracing",id:"debug-and-tracing",level:2},{value:"Trace ID",id:"trace-id",level:3},{value:"Trace Type",id:"trace-type",level:3},{value:"Creating Requests",id:"creating-requests",level:2},{value:"Examples",id:"examples",level:3},{value:"Deleting Requests",id:"deleting-requests",level:2},{value:"Cloning Requests",id:"cloning-requests",level:2},{value:"Header",id:"header",level:2}];function c(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["The Request class defines the data structure used to send and receives events via a network. Each Request includes a number of metadata fields used by networks (e.g., source and destination information) as well as ",(0,a.jsx)(t.em,{children:"payload"}),". The payload is an SST::Event pointer so that any event can be wrapped in the Request type and the payload delivered to the other side of the network. Requests are serializable and may be passed over SST Links."]}),"\n",(0,a.jsx)(t.h2,{id:"request-metadata",children:"Request Metadata"}),"\n",(0,a.jsx)(t.p,{children:"Each Request has several metadata fields. These are public and may be manipulated directly."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"dest"})," (nid_t) The ID for the destination"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"src"})," (nid_t) The ID of the source"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"vn"})," (int) Which virtual network the Request belongs to"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"size_in_bits"})," (size_t) The number of bits that a Request should consume on the network."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"head"})," (bool) True if this packet is the head of a stream"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"tail"})," (bool) True if this packet is the tail of a stream"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"allow_adaptive"})," (bool) True if this packet can be adaptively routed. Individual networks may or may not implement adaptive routing; SimpleNetwork does not require it."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"payloads",children:"Payloads"}),"\n",(0,a.jsx)(t.p,{children:"Each Request has a payload, which is a pointer to an SST::Event. The payload is private and must be manipulated via the following accessors. When a payload is given to a Request, the Request takes ownership and deleting the Request will also delete the payload."}),"\n",(0,a.jsx)(t.h3,{id:"givepayload",children:"givePayload"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"void givePayload(Event* event);\n"})}),"\n",(0,a.jsx)(t.p,{children:"Set the Request's payload to the SST Event. The Request takes ownership of the Event."}),"\n",(0,a.jsx)(t.h3,{id:"takepayload",children:"takePayload"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"Event* takePayload();\n"})}),"\n",(0,a.jsx)(t.p,{children:"Return the payload that the Request is carrying. The caller takes ownership of the Event and the Request discards its pointer to the event. The caller is responsible for deleting the Event in the future."}),"\n",(0,a.jsx)(t.h3,{id:"inspectpayload",children:"inspectPayload"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"Event* inspectPayload();\n"})}),"\n",(0,a.jsx)(t.p,{children:"Return the payload that the Request is carrying, but do not transfer ownership. The Request retains its pointer to the event."}),"\n",(0,a.jsx)(t.h2,{id:"debug-and-tracing",children:"Debug and Tracing"}),"\n",(0,a.jsx)(t.p,{children:"SimpleNetwork provides functions to enable tracing a Request through a network. These functions can be called on a Request to trace a request. The tracing data fields are protected members of the Request class. Individual networks are not required to implement tracing; they can ignore these fields. However, it is a useful functionality for debugging as well as introspecting the network."}),"\n",(0,a.jsx)(t.h3,{id:"trace-id",children:"Trace ID"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"protected:\n    int traceID;\npublic:\n    void setTraceID(int id); // Set the Request's ID to id\n    int getTraceID(); // Get the trace ID assigned to a Request\n"})}),"\n",(0,a.jsx)(t.h3,{id:"trace-type",children:"Trace Type"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"/* Types of traces supported by SimpleNetwork */\ntypedef enum {\n    NONE,   /* No tracing enabled */\n    ROUTE,  /* Trace route information only */\n    FULL    /* Trace all movements of packets through network */\n} TraceType;\n\nprotected:\n    TraceType trace;\npublic:\n    void setTraceType(TraceType type); // Set the Request's trace type to `type`\n    TraceType getTraceType(); // Return the Request's trace type\n"})}),"\n",(0,a.jsx)(t.h2,{id:"creating-requests",children:"Creating Requests"}),"\n",(0,a.jsx)(t.p,{children:"Requests can be created via the following constructors. Note the default values of the metadata fields. Trace fields must be set using the accessors described above."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"/* Default constructor */\nRequest() : \n    dest(0), src(0), size_in_bits(0), \n    head(false), tail(false), allow_adaptive(true), \n    payload(nullptr), \n    trace(NONE), traceID(0) \n{ }\n\nRequest(nid_t dest, nid_t src, size_t size_in_bits, bool head, bool tail, Event* payload = nullptr) :\n    dest(dest), src(src), size_in_bits(size_in_bits),\n    head(head), tail(tail), allow_adaptive(true),\n    payload(payload),\n    trace(NONE), traceID(0)\n{ }\n"})}),"\n",(0,a.jsx)(t.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/memHierarchy/memNIC.cc"',children:"void MemNIC::send(MemEventBase* ev) {\n    SimpleNetwork::Request *req = new SimpleNetwork::Request();\n    MemRtrEvent *mre = new MemRtrEvent(ev); // Wrap the ev in a MemHierarchy event type\n    req->src = info.addr; // Set the source to the MemNIC's ID\n    req->dest = lookupNetworkAddress(ev->getDst()); // Lookup the network address for the destination\n    req->size_in_bits = getSizeInBits(ev); // Calculate the size of the event\n    req->vn = 0; // Not using virtual networks\n    req->givePayload(mre); // Give the wrapped 'ev' to the req\n    sendQueue.push(req); // Enqueue this request to send it over the network\n    /* Rest of function to manage MemNIC's send queues */\n}\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/merlin/test/simple_patterns/incast.cc"',children:"SimpleNetwork::Request* req = new SimpleNetwork::Request();\nreq->dest = targets[curr_packets % targets.size()]; // Pick a new dest\nreq->src = id;\nreq->vn = 0;\nreq->size_in_bits = packet_size_in_bits;\nlink_control->send(req, 0); // Send the Request to the SimpleNetwork interface on vn=0\n"})}),"\n",(0,a.jsx)(t.h2,{id:"deleting-requests",children:"Deleting Requests"}),"\n",(0,a.jsx)(t.p,{children:"Deleting a Request will also delete the Request's payload if it currently has one."}),"\n",(0,a.jsx)(t.h2,{id:"cloning-requests",children:"Cloning Requests"}),"\n",(0,a.jsxs)(t.p,{children:["Requests, and many events in general, implement a ",(0,a.jsx)(t.code,{children:"clone()"})," function to enable deep copies of the data structures. A Request's clone() function duplicates the Request and does a deep copy of the payload if the Request has one."]}),"\n",(0,a.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/interfaces/simpleNetwork.h>\n"})})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);