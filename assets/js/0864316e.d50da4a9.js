"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[72486],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(96540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}},29064:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"core/params/find_array","title":"find_array","description":"Search for the specified key and return its value as a vector in the provided argument vec. The vector will be empty if the key is not found. The function is parameterized on a type, T , which must be a valid params parameter type (e.g., numeric including bool, string, or other class with a constructor that accepts a single string).","source":"@site/../docs/core/params/find_array.md","sourceDirName":"core/params","slug":"/core/params/find_array","permalink":"/sst-docs/docs/core/params/find_array","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/params/find_array.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1702928554000,"frontMatter":{"title":"find_array"},"sidebar":"core","previous":{"title":"find","permalink":"/sst-docs/docs/core/params/find"},"next":{"title":"find_map","permalink":"/sst-docs/docs/core/params/find_map"}}');var a=n(74848),r=n(28453);const i={title:"find_array"},o=void 0,c={},d=[{value:"Parameters",id:"parameters",level:2},{value:"Example",id:"example",level:2},{value:"Additional information on parsing",id:"additional-information-on-parsing",level:2},{value:"Header",id:"header",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"template <class T>\nvoid find_array(const std::string& key, std::vector<T>& vec) const;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Search for the specified key and return its value as a vector in the provided argument ",(0,a.jsx)(t.code,{children:"vec"}),". The vector will be empty if the key is not found. The function is parameterized on a type, ",(0,a.jsx)(t.code,{children:"T"})," , which must be a valid params parameter type (e.g., numeric including bool, string, or other class with a constructor that accepts a single string)."]}),"\n",(0,a.jsxs)(t.p,{children:['To be interpreted as an array, an array string must adhere to a specific format. The array must be enclosed in square brackets ([]). The array values should be comma separated (commas inside single or double quotes are assumed to be a value not a delimiter). Array values themselves must be valid parameter template types. If square brackets are not used, the entire string will be assumed to be a single array value. The function is designed to accept the string that is generated when a Python list is passed as a parameter value in the input configuration file. The function will then call the appropriate conversion function on the string to the templated type requested by the vector. If a conversion does not exist (e.g., attempting to convert the string "hi" to an int), the function will throw an ',(0,a.jsx)(t.code,{children:"invalid_argument"})," exception. Similarly, because C++ vectors do not support mixed types, the Python array string should not mix types."]}),"\n",(0,a.jsx)(t.p,{children:"Examples of valid array strings:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"[1, 2, 3, 4, 5]"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"['1', '2', '3', '4', '5']"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"key"})," (std::string) Parameter key to search for"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"vec"})," (std::vector<T>) Vector with type ",(0,a.jsx)(t.code,{children:"T"})," to populate from the parameter's value."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/simpleElementExample/basicParams.cc"',children:'basicParams::basicParams(ComponentId_t id, Params& params) : Component(id)\n{\n    out = new Output("", 1, 0, Output::STDOUT);\n\n    /* Some other constructor stuff */\n\n    std::vector<int> intArray;\n    //highlight-next-line\n    params.find_array<int>("array_param", intArray);\n\n    out->output("Read an array from array_param. Elements are: \\n");\n    for (std::vector<int>::iterator it = intArray.begin(); it != intArray.end(); it++)\n    {\n        out->output("%d, ", *it);\n    }\n    out->output("\\n");\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"additional-information-on-parsing",children:"Additional information on parsing"}),"\n",(0,a.jsxs)(t.p,{children:["For those interested in a more detailed description of how this function parses a string into an array of tokens, read on. The function is tailored to the type strings you get when passing a Python list as the param string. When you call ",(0,a.jsx)(t.a,{href:"../../config/component/addParam",children:(0,a.jsx)(t.code,{children:"addParam()"})})," on a Python list in the input file, it will call the ",(0,a.jsx)(t.code,{children:"str()"})," function on the list, which creates a string with the format: ",(0,a.jsx)(t.code,{children:"[item1, item2, item3]"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["The format of the items depends on where they came from. The string for each item is generated by calling the ",(0,a.jsx)(t.code,{children:"repr()"})," function on it. For strings, this means they will typically be enclosed in single quotes. It is possible that they end up enclosed in double quotes if the string itself contains a single quote. For strings which contain both single and double quotes, the ",(0,a.jsx)(t.code,{children:"repr()"})," will create a single quoted string with all internal single quotes escaped with ''. Most other items used in SST do not enclose the string in quotes, though any string that contains a comma would need to be enclosed in quotes, since the comma is the delimiter character used. This is not done automatically, so if you have something that generates a comma in the string created by ",(0,a.jsx)(t.code,{children:"repr()"}),", you may need to create an array string manually. Also, any string that starts with a quote character, must end with the same quote character."]}),"\n",(0,a.jsx)(t.p,{children:"Tokens are generated by splitting the string on commas that are not within quotes (double or single). All whitespace at the beginning and end of a token is ignored (unless inside quotes). Once the tokens are generated, any quoted string will have the front and back quotes removed. The '' for any escaped quote of the same type as the front and back is also removed."}),"\n",(0,a.jsx)(t.p,{children:"Examples of parsing strings using double and/or single quotes:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'\'This is "a" test\' -> This is "a" test'}),"\n",(0,a.jsx)(t.li,{children:"\"This is 'a' test\" -> This is 'a' test"}),"\n",(0,a.jsx)(t.li,{children:"'This \"is 'a'\" test' -> This \"is 'a''\" test"}),"\n",(0,a.jsx)(t.li,{children:'\'This "is "a"" test\' -> This "is "a"" test'}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,a.jsx)(t.p,{children:"The Params header file is included with any SST object that supports Params."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/componentExtension.h> // or\n#include <sst/core/params.h> // if not included in base class\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);