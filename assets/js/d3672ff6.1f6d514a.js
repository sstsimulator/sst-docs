"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[65457],{23582:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"elements/cacheTracer/intro","title":"cacheTracer","description":"The cacheTracer can be used to generate a trace of events between any CPU and memHierarchy components. It has two ports, \'northBus\' (connects to the CPU component) and \'southBus\' (memory system component). CacheTracer also keeps track of the addresses of the messages passing through from its one port to another. It performs following tasks:","source":"@site/../docs/elements/cacheTracer/intro.md","sourceDirName":"elements/cacheTracer","slug":"/elements/cacheTracer/intro","permalink":"/sst-docs/docs/elements/cacheTracer/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/cacheTracer/intro.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"cacheTracer"},"sidebar":"elements","previous":{"title":"Balar In Depth","permalink":"/sst-docs/docs/elements/balar/BalarInDepth"},"next":{"title":"cassini","permalink":"/sst-docs/docs/elements/cassini/intro"}}');var r=t(74848),a=t(28453);const i={title:"cacheTracer"},o=void 0,c={},l=[{value:"Required dependencies",id:"required-dependencies",level:3},{value:"Optional dependencies",id:"optional-dependencies",level:3},{value:"Parameters",id:"parameters",level:3}];function d(e){const s={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.em,{children:"cacheTracer"})," can be used to generate a trace of events between any CPU and memHierarchy components. It has two ports, 'northBus' (connects to the CPU component) and 'southBus' (memory system component). CacheTracer also keeps track of the addresses of the messages passing through from its one port to another. It performs following tasks:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Count number of events occurring from one port to another."}),"\n",(0,r.jsx)(s.li,{children:"Generates a histogram of request addresses of events passing through it."}),"\n",(0,r.jsx)(s.li,{children:'Note: cacheTracer assumes the first message with a given event-ID will pass from the northBus to the southBus and response messages will flow the other way. With this assumption, for every event-ID, cacheTracer calculates the time between when the event-ID appears on northBus and its response on southBus. The difference time is defined as "Access Latency". The access latencies are recorded in nanoseconds(ns). At the end of the simulation, a histogram is built capturing these latencies.'}),"\n"]}),"\n",(0,r.jsx)(s.admonition,{title:"At a Glance",type:"note",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Source Code:"})," ",(0,r.jsx)(s.a,{href:"https://github.com/sstsimulator/sst-elements/tree/master/src/sst/elements/cacheTracer",children:"sst-elements/.../cacheTracer"})," \xa0",(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.strong,{children:"SST Name:"})," ",(0,r.jsx)(s.code,{children:"cacheTracer"})," \xa0",(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.strong,{children:"Maturity Level:"})," Early Development (1) \xa0",(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.strong,{children:"Development Path:"})," Maintenance \xa0",(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.strong,{children:"Last Released:"})," SST 15.0"]})}),"\n",(0,r.jsx)(s.h3,{id:"required-dependencies",children:"Required dependencies"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.em,{children:"None"})}),"\n",(0,r.jsx)(s.h3,{id:"optional-dependencies",children:"Optional dependencies"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.em,{children:"None"})}),"\n",(0,r.jsx)(s.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"cacheTracer"})," accepts the following parameters."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"clock"})," Frequency for port (should be set to be same as CPU frequency)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"debug"})," Print out debug info with increasing verbosity. To generate an address trace of events, set debug=8 and provide filename in tracePrefix."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"tracePrefix"})," Filename for output trace-file generated when debug=8 is set. If no value is set, a trace will NOT be written."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"statistics"})," Flag indicating whether to print stats at the end of the execution. 1= print stats, 0-don't print stats."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"statsPrefix"}),' Filename for output file where statistics will be dumped if "statistics" is set. If filename is NOT provided and "statistics" is set, stats will be printed to stdout.']}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"pageSize"})," This value is used to set size of an individual bin in address histogram. Default value is 4096 (4k)."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"accessLatencyBins"})," This value is used to set total number of bins for access-latency histogram. Default value is 10."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>o});var n=t(96540);const r={},a=n.createContext(r);function i(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);