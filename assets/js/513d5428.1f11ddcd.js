"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[65629],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}},74600:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"core/portmodule/class","title":"PortModule","description":"The PortModule API has not been finalized and may be changed without notice in subsequent versions of SST.","source":"@site/../docs/core/portmodule/class.md","sourceDirName":"core/portmodule","slug":"/core/portmodule/class","permalink":"/sst-docs/docs/core/portmodule/class","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/portmodule/class.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"PortModule"},"sidebar":"core","previous":{"title":"print_all_params","permalink":"/sst-docs/docs/core/params/print_all_params"},"next":{"title":"constructor","permalink":"/sst-docs/docs/core/portmodule/constructor"}}');var r=t(74848),s=t(28453);const i={title:"PortModule"},d=void 0,l={},c=[{value:"PortModule Implementation",id:"portmodule-implementation",level:2},{value:"Access to SST-Core APIs",id:"access-to-sst-core-apis",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"API Not Final",type:"info",children:(0,r.jsx)(n.p,{children:"The PortModule API has not been finalized and may be changed without notice in subsequent versions of SST."})}),"\n",(0,r.jsxs)(n.p,{children:["PortModules can be attached to the send and/or receive side of a port. The module intercepts the event stream through that port and can monitor, modify, replace, and delete events. A PortModule is always co-located with the Component whose port it is attached to. PortModules have limited access to SST APIs although the API is evolving and some extension (e.g., adding access to Statistics) is planned. For more complex needs, consider using a ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/component/subcomponent/class",children:"SubComponent"})," instead."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"Attaching a PortModule to a port on the send side (i.e., to monitor outgoing traffic) has known performance issues. We recommend attaching to the receive side (input port) when possible or using a SubComponent instead to avoid perturbing the SST::Link send path."})}),"\n",(0,r.jsx)(n.h2,{id:"portmodule-implementation",children:"PortModule Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["PortModules inherit the following functions from the base PortModule and ",(0,r.jsx)(n.em,{children:"must"})," override them."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/constructor",children:"Constructor"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/destructor",children:"Destructor"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/eventSent",children:(0,r.jsx)(n.code,{children:"eventSent"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/interceptHandler",children:(0,r.jsx)(n.code,{children:"interceptHandler"})})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"PortModules inherit the following functions from the base PortModule and should override them as needed."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/installOnReceive",children:(0,r.jsx)(n.code,{children:"installOnReceive"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/installOnSend",children:(0,r.jsx)(n.code,{children:"installOnSend"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/serialize_order",children:(0,r.jsx)(n.code,{children:"serialize_order"})})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'PortModules share base APIs with other tools that attach to various places ("AttachPoints") in SST. However, PortModules cover a narrower use case (tools that attach only to ports) and therefore PortModules can override these inherited functions as well but are unlikely to need to do so.'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/registerHandlerIntercept",children:(0,r.jsx)(n.code,{children:"registerHandlerIntercept"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/registerLinkAttachTool",children:(0,r.jsx)(n.code,{children:"registerLinkAttachTool"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/serializeEventAttachPointKey",children:(0,r.jsx)(n.code,{children:"serializeEventAttachPointKey"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/serializeHandlerInterceptPointKey",children:(0,r.jsx)(n.code,{children:"serializeHandlerInterceptPointKey"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"access-to-sst-core-apis",children:"Access to SST-Core APIs"}),"\n",(0,r.jsx)(n.p,{children:"PortModules also have the following functions available to access SST-Core state."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCoreTimeBase",children:(0,r.jsx)(n.code,{children:"getCoreTimeBase"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimCycle",children:(0,r.jsx)(n.code,{children:"getCurrentSimCycle"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentPriority",children:(0,r.jsx)(n.code,{children:"getCurrentPriority"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getElapsedSimTime",children:(0,r.jsx)(n.code,{children:"getElapsedSimTime"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getSimulationOutput",children:(0,r.jsx)(n.code,{children:"getSimulationOutput"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTime",children:(0,r.jsx)(n.code,{children:"getCurrentSimTime"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTimeNano",children:(0,r.jsx)(n.code,{children:"getCurrentSimTimeNano"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTimeMicro",children:(0,r.jsx)(n.code,{children:"getCurrentSimTimeMicro"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTimeMilli",children:(0,r.jsx)(n.code,{children:"getCurrentSimTimeMilli"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Example PortModule that randomly drops events; header file"',children:'class DropEvent : public SST::PortModule\n{\npublic:\n    SST_ELI_REGISTER_PORTMODULE(\n        DropEvent,                      // Class name\n        "example",                      // Library name, the \'lib\' in SST\'s lib.name format\n        "drop",                         // Name used to refer to this port module, the \'name\' in SST\'s lib.name format\n        SST_ELI_ELEMENT_VERSION(1,0,0), // A version number\n        "Randomly drops events")        // Description\n\n    SST_ELI_DOCUMENT_PARAMS(\n        { "drop_probability", "Set the probability of a dropped event between 0\\% and 100\\%", "10",},\n        { "seed", "Seed to use for random number generation", "1" }\n    )\n\n    DropEvent(Params& params);\n    ~DropEvent();\n\n    void eventSend(uintptr_t key, Event*& ev) override;\n    void interceptHandler(uintptr_t key, Event*& ev, bool& cancel) override;\n\n    bool installOnReceive() override { return true; }\n    bool installOnSend() override { return false; }\n\nprivate:\n    SST::RNG::MersenneRNG * rng;\n    uint32_t probability;\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Example PortModule that randomly drops events; implementation file"',children:'#include "drop_event.h"\n\nDropEvent::DropEvent(Params& params) : PortModule()\n{\n    rng = new SST::RNG::MersenneRNG(params.find<unsigned>("seed", 1));\n    probability = params.find<uint32_t>("drop_probability", 10);\n}\n\n~DropEvent::DropEvent() \n{\n    delete rng;\n}\n\nvoid DropEvent::eventSent(uintptr_t key, Event*& ev)\n{\n    uint32_t prob = (rng->getNextUInt32() % 100);\n    if (prob <= probability) {\n        delete ev;\n        ev = nullptr;\n    }\n}\n\nvoid DropEvent::interceptHandler(uintptr_t key, Event*& ev, bool& cancel)\n{\n    uint32_t prob = (rng->getNextUInt32() % 100);\n    if (prob <= probability) {\n        delete ev;\n        ev = nullptr;\n        cancel = true;\n    } else {\n        cancel = false;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/portModule.h>\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);