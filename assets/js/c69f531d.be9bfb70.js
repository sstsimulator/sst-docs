"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[11754],{13276:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core/events/event_handler","title":"SST::Event::Handler","description":"Event handlers are used by Links when an event arrives on the Link. The handler passes in the event as well as optional data if the handler was registered with an extra field. The handler does not return anything.","source":"@site/../docs/core/events/event_handler.md","sourceDirName":"core/events","slug":"/core/events/event_handler","permalink":"/sst-docs/docs/core/events/event_handler","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/events/event_handler.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1716583959000,"frontMatter":{"title":"SST::Event::Handler"},"sidebar":"core","previous":{"title":"SST::Event","permalink":"/sst-docs/docs/core/events/class"},"next":{"title":"constructor","permalink":"/sst-docs/docs/core/events/constructor"}}');var s=t(74848),r=t(28453);const l={title:"SST::Event::Handler"},d=void 0,i={},c=[{value:"Parameters",id:"parameters",level:2},{value:"Constructing Handlers",id:"constructing-handlers",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function o(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void handler(SST::Event* event);\nvoid handler(SST::Event* event, dataT data);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Event handlers are used by Links when an event arrives on the Link. The handler passes in the event as well as optional data if the handler was registered with an extra field. The handler does not return anything."}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"event"})," (SST::Event) The event to be handled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"data"})," (dataT) Optional, data that the handler was created with."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"constructing-handlers",children:"Constructing Handlers"}),"\n",(0,s.jsxs)(n.p,{children:["An event handler belonging to class ",(0,s.jsx)(n.code,{children:"class"})," and pointing to function ",(0,s.jsx)(n.code,{children:"func"})," is constructed as follows. The second line demonstrates a handler with metadata of type ",(0,s.jsx)(n.code,{children:"dataT"})," and a value of ",(0,s.jsx)(n.code,{children:"data"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"SST::Handler* handler = new Event::Handler2<class, &class::func>(this);\nSST::Handler* handler = new Event::Handler2<class, &class::func, dataT>(this, data);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This definition has changed as of SST 14.0 due to the reintroduction of checkpointing support. The old style handler was named ",(0,s.jsx)(n.code,{children:"Handler"})," instead of ",(0,s.jsx)(n.code,{children:"Handler2"})," and passed the handler function pointer to the constructor as a function parameter rather than a template parameter. The ",(0,s.jsx)(n.code,{children:"Handler"})," type is not checkpointable. ",(0,s.jsx)(n.code,{children:"Handler"})," is deprecated in SST 14.0 and the name will be reintroduced in SST 15.0 with the same syntax as ",(0,s.jsx)(n.code,{children:"Handler2"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="Handler construction in different versions of SST"',children:"/* Pre-SST 14.0 handler - not checkpointable */\nSST::Handler* handler = new Event::Handler<class>(this, &class::func);\nSST::Handler* handler = new Event::Handler<class, metaT>(this, &class::func, data);\n\n/* SST 14.0 - old and new style supported */\n// Old style, deprecated and not checkpointable - update to Handler2 style instead\nSST::Handler* handler = new Event::Handler<class>(this, &class::func);\nSST::Handler* handler = new Event::Handler<class, dataT>(this, &class::func, data);\n// New style, checkpointable\nSST::Handler* handler = new Event::Handler2<class, &class::func>(this);\nSST::Handler* handler = new Event::Handler2<class, &class::func, dataT>(this, data);\n\n/* SST 15.0+ - old and new type name both use new style. Eventually the name 'Handler2' will be deprecated. */\nSST::Handler* handler = new Event::Handler<class, &class::func>(this);\nSST::Handler* handler = new Event::Handler<class, &class::func, dataT>(this, data);\nSST::Handler* handler = new Event::Handler2<class, &class::func>(this);\nSST::Handler* handler = new Event::Handler2<class, &class::func, dataT>(this, data);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/simpleElementExample/basicLinks.h"',children:"class basicLinks : public SST::Component\n{\npublic:\n    /* ELI and unrelated functions omitted for brevity */\n    basicLinks(SST::ComponentId_t id, SST::Params& params);\nprivate:\n    // An event handler\n    void handleEvent(SST::Event* ev);\n\n    // An event handler with an ID that indicates\n    // which link sent the event\n    void handleEventWithID(SST::Event* ev, int linknum);\n} \n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/simpleElementExample/basicLinks.cc"',children:'basicLinks::basicLinks(ComponentId_t id, Params& params) : Component(id)\n{\n    // Configure the link connected to our \'port_handler\' port to call handleEvent when an event arrives\n    configureLink("port_handler", new Event::Handler<basicLinks>, this, &basicLinks::handleEvent));\n\n    std::string linkname = "port_vector0";\n    int portnum = 0;\n    while (isPortConnected(linkname)) {\n        // Configure links connected to port_vector* to call handleEventWithID when an event arrives\n        // Also pass the index of the port/link that received the event\n        configureLink(linkname, new Event::Handler2<basicLinks, &basicLinks::handleEventWithID, int>(this, portnum));\n\n        portnum++;\n        linkname = "port_vector" + std::to_string(portnum);\n    }\n\n    /* Rest of configuration */\n}\n\n// Just count how many events arrive\nvoid basicLinks::handleEvent(SST::Event* event)\n{\n    events_received++;\n    delete event;\n}\n\n// Count how many events arrive on each port\nvoid basicLinks::handleEventWithID(SST::Event *event, int id)\n{\n    events_received_vector[i]++;\n    delete event;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/componentextension.h> // or\n#include <sst/core/event.h>\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>d});var a=t(96540);const s={},r=a.createContext(s);function l(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);