"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2709],{47683:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var o=i(74848),r=i(28453);const t={title:"Running Motifs"},s=void 0,l={id:"elements/ember/RunningMotifs",title:"Running Motifs",description:"Ember Python Configuration",source:"@site/../docs/elements/ember/RunningMotifs.md",sourceDirName:"elements/ember",slug:"/elements/ember/RunningMotifs",permalink:"/sst-docs/docs/elements/ember/RunningMotifs",draft:!1,unlisted:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/ember/RunningMotifs.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1678138197e3,frontMatter:{title:"Running Motifs"},sidebar:"elements",previous:{title:"Creating Motifs",permalink:"/sst-docs/docs/elements/ember/CreatingMotifs"},next:{title:"firefly",permalink:"/sst-docs/docs/elements/firefly/intro"}},d={},c=[{value:"Ember Python Configuration",id:"ember-python-configuration",level:2},{value:"Running Ember",id:"running-ember",level:2},{value:"Key Components",id:"key-components",level:2},{value:"Topologies",id:"topologies",level:2},{value:"Creating a Router",id:"creating-a-router",level:2},{value:"Specifying Computation",id:"specifying-computation",level:2},{value:"Running the simulation",id:"running-the-simulation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"ember-python-configuration",children:"Ember Python Configuration"}),"\n",(0,o.jsx)(n.p,{children:"The Python file in Ember specifies:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"How to set up the SST simulation"}),"\n",(0,o.jsx)(n.li,{children:"Allows multiple configurations to be specified and run"}),"\n",(0,o.jsx)(n.li,{children:"Loads Motifs into the simulation to be performed."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"running-ember",children:"Running Ember"}),"\n",(0,o.jsxs)(n.p,{children:["Ember uses a python interpreter built into the SST compiler.\n",(0,o.jsx)(n.code,{children:"sst python-file.py"})," executes the python script."]}),"\n",(0,o.jsx)(n.h2,{id:"key-components",children:"Key Components"}),"\n",(0,o.jsx)(n.p,{children:"The python file specifies the format of the SST simulation. The python file specifies components of our simulation such as network Topology, Routers, NetworkInterface and the computation to be performed in the form of Motifs."}),"\n",(0,o.jsx)(n.p,{children:"First, we import the necessary components of merlin and set the Platform to firefly defaults."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",children:'    import sst\n    from sst.merlin.base import *\n    from sst.merlin.endpoint import *\n    from sst.merlin.interface import *\n    from sst.merlin.topology import *\n\n    from sst.ember import *\n\n    if __name__ == "__main__":\n\n        PlatformDefinition.setCurrentPlatform("firefly-defaults")\n'})}),"\n",(0,o.jsx)(n.p,{children:"Next, we create a topology that our experiment will run on."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"topo = topoDragonFly()"}),"\nCreates a dragonfly topology.\nWe can then specify parameters about the topology using a dot-operator. e.g.,\n",(0,o.jsx)(n.code,{children:"topo.num_groups = 4"})]}),"\n",(0,o.jsx)(n.h2,{id:"topologies",children:"Topologies"}),"\n",(0,o.jsx)(n.p,{children:"The python file allows the user to specify comparable hardware configurations.\nFour different topologies can be specified with different routing algorithms.\nHere we give a comprehensive list of the topologies and how they can be initialized."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["HyperX ",(0,o.jsx)(n.code,{children:"topoHyperX"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"shape"}),"\nSpecifies the shape of the mesh. i.e. topo.shape=4x4 or topo.shape=4x4x4. Any number of dimensions is supported."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"width"}),"\nThe number of links between routers in each dimension is specified in the same manner as shape."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"local_ports"}),"\nNumber of endpoints attached to each router"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"algorithm"}),"\nRouting algorithm to use.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"DOAL"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"DOR"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"DOR-ND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"MIN-A"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"VDAL"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"valiant"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Torus ",(0,o.jsx)(n.code,{children:"topoTorus"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Shape\nSpecifies the mesh grid size, i.e., topo.shape=4x4 or topo.shape=4x4x4. Any number of dimensions is supported."}),"\n",(0,o.jsx)(n.li,{children:"Width\nNumber of links between routers in each dimension, specified in the same way as shape."}),"\n",(0,o.jsx)(n.li,{children:"local_ports\nNumber of endpoints attached to each router"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Fat Tree ",(0,o.jsx)(n.code,{children:"topoFatTree"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"shape"}),'\nThe shape of the fat tree. Specified as pair of downlinks and uplinks per level separated by a colon. i.e., topo.shape="4,2:3,5" specifies the first level has 4 down and 2 up, and the following level has 3 down and 5 up.\nIf only one number is given, it is interpreted as the number of downlinks and up is set to 0.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"routing_alg"})," Routing algorithm to use","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"deterministic"})," (default)"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"adaptive"})}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"adaptive threshold."}),"\nThe threshold is used to determine if a packet will adaptively route."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Dragonfly ",(0,o.jsx)(n.code,{children:"topoDragonFly"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"hosts_per_router"}),"\nNumber of hosts connected to each router"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"routers_per_group"}),"\nThe number of links used to connect to routers in the same group."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"intergroup_per_router"}),"\nThe number of links per router connected to other groups."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"intergroup_links"}),"\nThe number of links between each pair of groups."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"num_groups"}),"\nNumber of groups in a network"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"intergroup_links"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"algorithm"}),'\nSpecifies how each virtual network routes messages.\nSpecified for each router.vn. i.e., if router.vn=2, than topo.algorithm=["minimal", "adaptive-local"], the first router uses minimal, and the second will use adaptive-local.',"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"minimal"})," (default)\\"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"adaptive_local"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"ugal"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"min-a"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"valiant"}),"\nValiant only operates if there are more than two num_groups. Otherwise, there is no point in using valiant routing."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"adaptive_threshold"}),"\nThreshold when making adaptive routing decisions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"global_link_map"}),"\nAn array specifying connectivity of global links in each dragonfly group"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"global_route_mode"}),"\nMode for interpreting global link map","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"absolute"})," (default)"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"relative"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-router",children:"Creating a Router"}),"\n",(0,o.jsx)(n.p,{children:"Once the router has been created, the topology needs to be linked to the router. Additionally, the link_latency can be set in the topology at this point."}),"\n",(0,o.jsx)(n.p,{children:'topo.router = router\ntopo.link_latency = "20ns"'}),"\n",(0,o.jsxs)(n.p,{children:["Parameters for a high radix router or  ",(0,o.jsx)(n.code,{children:"hr_routers"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"id"}),"\nThe ID of the router"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"num_ports"}),"\nNumber of ports the router has"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"topology"}),"\nName of the topology subcomponent loaded to control routing"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"xbar_arb"}),"\nArbitration unit used for the crossbar. Default is ",(0,o.jsx)(n.code,{children:"merlin.xbar_arb_lru"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"merlin.xbar_arb_lru"}),"\nUses Least recently used arbitration for ",(0,o.jsx)(n.code,{children:"hr_router."})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"merlin.xbar_arb_age"}),"\nAge-based arbitration unit for ",(0,o.jsx)(n.code,{children:"hr_router"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"merlin.xbar_arb_lru"}),"\nLeast recently used arbitration unit with infinite crossbar for ",(0,o.jsx)(n.code,{children:"hr_router"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"merlin.xbar_arb_rand"}),"\nRandom arbitration unit for ",(0,o.jsx)(n.code,{children:"hr_router"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"merlin.xbar_arb_rr"}),"\nRound-robin arbitration unit for ",(0,o.jsx)(n.code,{children:"hr_router"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"link_bw"}),"\nBandwidth of the links specified in either b/s or B/s (can include SI prefix)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"flit_size"}),"\nFlit size specified in either b or B"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"xbar_bw"}),"\nBandwidth of the crossbar specified in either b/s or B/s"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"input_latency"}),"\nLatency of packets entering switch into input buffers. Specified in s."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"output_latency"}),"\nLatency of packets exiting switch from output buffers. Specified in s."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"network_inspectors"}),"\nComma-separated list of network inspectors to put on output ports"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"oql_track_port"}),"\nSet to true track output queue length for an entire port. False tracks per VC (default)."]}),"\n"]}),"\n",(0,o.jsx)(n.h1,{id:"creating-network-interface",children:"Creating Network Interface"}),"\n",(0,o.jsx)(n.p,{children:"Create the network interface:"}),"\n",(0,o.jsx)(n.p,{children:"networkif = ReorderLinkControl()"}),"\n",(0,o.jsx)(n.p,{children:"The ReorderLinkControl() creates a network interface that can handle out-of-order packet arrival. Events are sequenced, and order is reconstructed on receive."}),"\n",(0,o.jsx)(n.h2,{id:"specifying-computation",children:"Specifying Computation"}),"\n",(0,o.jsx)(n.p,{children:"Initialize the MPIJob to use all the nodes in our topology:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"ep = EmberMPIJob(0, topo.getNumNodes())"}),"\nThe network interface then needs to be linked to the ",(0,o.jsx)(n.code,{children:"ep"})," variable\n",(0,o.jsx)(n.code,{children:"ep.network_interface = networkif()"}),"\nThen a series of Motifs can be queued for computation."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",children:'    ep.addMotif("Init")\n    ep.addMotif("Allreduce")\n    ep.addMotif("Fini")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"addMotif"})," function adds the specified Motif to a queue. The Motif is named through an ",(0,o.jsx)(n.a,{href:"../../core/eli/register/sst_eli_register_subcomponent",children:(0,o.jsx)(n.code,{children:"SST\\_ELI\\_REGISTER\\_SUBCOMPONENT"})})," command in the C++ Motif definition. The ",(0,o.jsx)(n.code,{children:"SST\\_ELI\\_REGISTER\\_SUBCOMPONENT"}),' parameter follows the naming convention "ExampleMotif", and to add the Motif to ',(0,o.jsx)(n.code,{children:"ep"})," using ",(0,o.jsx)(n.code,{children:'ep.addMotif("Example")'})," The \"Motif\" portion is implied in the naming.\nParameters can be passed to motifs through the string. The parameters are read as a list of assignments, separated by whitespace. For example, a motif 'Sum' that takes three integers as a parameter named x, y, and z\nThe Motif would be invoked ",(0,o.jsx)(n.code,{children:'ep.addMotif("Sum x=4 y=5 z=6")'})," would pass the arguments as args.x, args.y, and args.z with assigned values 4, 5, and 6, respectively. The arguments are passed in a Param object to the motif generator to be parsed."]}),"\n",(0,o.jsxs)(n.p,{children:["Some additional functions that can be called on an endpoint or the ",(0,o.jsx)(n.code,{children:"ep"})," variable:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"getName()"}),'\nReturns the name of the ep. i.e., it will return "EmberMPIJob"']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"enableMotifLog()"}),"\nStarts logging the Motifs as they are executed."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Some common MPI-function call motifs that exist in Ember:"}),"\n",(0,o.jsx)(n.h2,{id:"running-the-simulation",children:"Running the simulation"}),"\n",(0,o.jsx)(n.p,{children:"Finally, we create the 'system', which then runs the simulation. The topology is set with the setTopology function, and the endpoint is specified by system.allocateNodes. Build executes the motifs in the endpoint."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-py",children:'    system = System()\n    system.setTopology(topo)\n    system.allocateNodes(ep,"linear")\n    system.build()\n'})}),"\n",(0,o.jsx)(n.p,{children:'While most of the System is self-explanatory, the system allows the user to specify how threads/processes are assigned to nodes in the allocateNodes function.\nThe allocateNodes function allows the user to specify how the nodes are allocated. In the example, "linear" is chosen. In linear, the nodes are sorted, and threads are placed in linear order onto the simulated nodes. There are additional ways to allocate nodes, such as "random", "interval", and "indexed".'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var o=i(96540);const r={},t=o.createContext(r);function s(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);