"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[58707],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(96540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}},87339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"core/module/class","title":"Module","description":"Modules are lightweight, dynamically-loadable pieces of functionality. They can be loaded into Components. A Module is always co-located with the Component it is loaded into when running SST in parallel.Modules do not have any defined API and have no access to SST APIs. Modules requiring any API access, for example, Clocks, Statistics, etc., need to be defined as SubComponents instead.","source":"@site/../docs/core/module/class.md","sourceDirName":"core/module","slug":"/core/module/class","permalink":"/sst-docs/docs/core/module/class","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/module/class.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"Module"},"sidebar":"core","previous":{"title":"getId","permalink":"/sst-docs/docs/core/link/getId"},"next":{"title":"constructor","permalink":"/sst-docs/docs/core/module/constructor"}}');var s=t(74848),o=t(28453);const i={title:"Module"},l=void 0,d={},c=[{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function r(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Modules are lightweight, dynamically-loadable pieces of functionality. They can be ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/component/load/loadModule",children:"loaded into Components"}),". A Module is always co-located with the Component it is loaded into when running SST in parallel.Modules do not have any defined API and have no access to SST APIs. Modules requiring any API access, for example, Clocks, Statistics, etc., need to be defined as ",(0,s.jsx)(n.a,{href:"/sst-docs/docs/core/component/subcomponent/class",children:"SubComponents"})," instead."]}),"\n",(0,s.jsx)(n.p,{children:"Modules must inherit from a Module API which must in turn inherit from the SST::Module class. This allows SST to load any Module that inherits from a given API into a slot designed for that API."}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(n.p,{children:["The following example shows a module to allow swapping different hash functions. The API contains a function that hashes a ",(0,s.jsx)(n.code,{children:"value"})," into a ",(0,s.jsx)(n.code,{children:"hash_value"}),' and each module implements a different hash function. A Component could load "example.noHash" to skip hashing and "example.linearHash" to apply a linear hash.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="Example Hash Module API and Modules"',children:"#include <sst/core/module.h>\n#include <stdint.h>\n\n// Module API - define an API for a type of module\nclass HashFunction: public SST::Module\n{\npublic:\n    // Tell SST that this class is a Module API\n    SST_ELI_REGISTER_MODULE_API(SST::HashFunction)\n\n    HashFunction(Params& params) : Module() {}\n    virtual ~Module() {}\n\n    virtual uint64_t hash(uint64_t value) =0;\n};\n\n// This is a module that implements the API defined above\nclass NoHash : public HashFunction \n{\npublic:\n    SST_ELI_REGISTER_MODULE(\n        NoHash,                            // Class name\n        \"example\",                         // Library name, the 'lib' in SST's lib.name format\n        \"noHash\",                          // Name used to refer to this module, the 'name' in SST's lib.name format\n        SST_ELI_ELEMENT_VERSION(1,0,0),    // A version number\n        \"Hash function that does nothing\", // Description\n        SST::HashFunction)                 // Fully qualified name of the API this module implements\n\n    NoHash(Params& params) : HashFunction(params) {}\n    ~NoHash() {}\n\n    // Implement the API function\n    uint64_t hash(uint64_t value) override\n    {\n        return value;\n    }\n};\n\n// Another module that implements the API defined above\nclass Linear : public HashFunction\n{\n    SST_ELI_REGISTER_MODULE(\n        Linear,                            // Class name\n        \"example\",                         // Library name, the 'lib' in SST's lib.name format\n        \"linearHash\",                      // Name used to refer to this module, the 'name' in SST's lib.name format\n        SST_ELI_ELEMENT_VERSION(1,0,0),    // A version number\n        \"Linear hash function\",            // Description\n        SST::HashFunction)                 // Fully qualified name of the API this module implements\n\n    Linear(Params& params) : HashFunction(params) {}\n    ~Linear() {}\n\n    // Implement the API function\n    uint64_t hash(uint64_t value) override\n    {\n        return 1103515245*value + 12345;\n    }\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/module.h>\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}}}]);