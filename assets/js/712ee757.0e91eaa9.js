"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[79968],{28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>r});var t=s(96540);const i={},o=t.createContext(i);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(o.Provider,{value:n},e.children)}},70305:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/concepts/lifecycle","title":"Simulation lifecycle","description":"Each SST simulation goes through a number of stages, from start-up to exit. These stages are referred to as the SST Lifecycle. Component trees (i.e., a component together with its subcomponents and/or component extensions) are able to perform different actions in each stage through the Component APIs. These are the stages.","source":"@site/../docs/guides/concepts/lifecycle.mdx","sourceDirName":"guides/concepts","slug":"/guides/concepts/lifecycle","permalink":"/sst-docs/docs/guides/concepts/lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/guides/concepts/lifecycle.mdx","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1729787241000,"frontMatter":{"title":"Simulation lifecycle"},"sidebar":"guides","previous":{"title":"Types of SST elements","permalink":"/sst-docs/docs/guides/concepts/elementtypes"},"next":{"title":"Time in SST","permalink":"/sst-docs/docs/guides/concepts/time"}}');var i=s(74848),o=s(28453);const c=s.p+"assets/images/lifecycle-e7ae092989aa36b2fa5c626e61f0f2f2.png",r={title:"Simulation lifecycle"},l=void 0,a={},d=[{value:"Lifecycle Stages",id:"lifecycle-stages",level:3},{value:"Extra stages",id:"extra-stages",level:3},{value:"The stages in detail",id:"the-stages-in-detail",level:2},{value:"Construction",id:"construction",level:3},{value:"Init",id:"init",level:3},{value:"Setup",id:"setup",level:3},{value:"Run",id:"run",level:3},{value:"Complete",id:"complete",level:3},{value:"Finish",id:"finish",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"Emergency shutdown",id:"emergency-shutdown",level:3},{value:"Print status",id:"print-status",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Each SST simulation goes through a number of stages, from start-up to exit. These stages are referred to as the ",(0,i.jsx)(n.em,{children:"SST Lifecycle"}),". Component trees (i.e., a component together with its subcomponents and/or component extensions) are able to perform different actions in each stage through the Component APIs. These are the stages."]}),"\n",(0,i.jsx)(n.h3,{id:"lifecycle-stages",children:"Lifecycle Stages"}),"\n","\n",(0,i.jsx)("img",{src:c,alt:"A picture of the simulation lifecycle - creation, init, setup, run, complete, finish, cleanup",style:{maxWidth:"600px"}}),"\n",(0,i.jsxs)(n.p,{children:["Init and Complete are multi-phase stages. They continue until component trees collectively stop exchanging events. Likewise, the Run stage continues until all ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/component/registerAsPrimaryComponent",children:"primary components"})," have signaled they are done or until SST runs out of events to execute."]}),"\n",(0,i.jsx)(n.p,{children:"Note that with the exception of Cleanup and Run, these stages involve component objects only. If a subcomponent or component extension needs to perform work in a stage, their parent component needs to call the relevant API function on that element. This allows components to control the execution order among their children."}),"\n",(0,i.jsx)(n.h3,{id:"extra-stages",children:"Extra stages"}),"\n",(0,i.jsx)(n.p,{children:"Under normal circumstances, SST simulations proceed through each of these stages in order. However, certain triggers can cause SST to skip or short circuit stages. These triggers make use of two extra stage:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Emergency shutdown"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["In this stage, components are notified that the simulation is going to end prematurely. Both internal triggers, such as an ",(0,i.jsx)(n.code,{children:"Output::fatal()"})," call, and external triggers, such as a ",(0,i.jsx)(n.code,{children:"SIGTERM"})," signal, can lead to this stage."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Print status"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In this stage, components are asked to report their status."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-stages-in-detail",children:"The stages in detail"}),"\n",(0,i.jsx)(n.h3,{id:"construction",children:"Construction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," Constructors such as the ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/component/constructor",children:"Component constructor"})," and element loading functions such as ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/load/loadUserSubComponent",children:(0,i.jsx)(n.code,{children:"loadUserSubComponent"})})]}),"\n",(0,i.jsx)(n.p,{children:'When SST starts, it first reads in the simulation configuration file. This file defines the graph of components that SST will simulate. After parsing the graph to identify its structure, SST partitions the graph and sends each partition to a rank and/or thread in the simulation. The partitioning step is skipped in serial simulations. Each parallel partition then builds its own portion of the graph, invoking component constructors which in turn load any other elements the component needs (e.g., subcomponents). For very large simulations where the graph is difficult to parse on a single rank, SST does support pre-partitioning the graph and providing each rank/thread its own configuration input file ("parallel loading").\nThe following activities should be completed during this stage.'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/link/configureLink",children:"Link configuration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/stat/registerStatistic",children:"Statistics must be registered"})}),"\n",(0,i.jsx)(n.li,{children:"Any SharedObjects must be initialized"}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/load/loadUserSubComponent",children:"User subcomponents should be loaded"})}),"\n",(0,i.jsx)(n.li,{children:"Parameter objects passed to element constructors are deleted after the constructor returns. Elements should save any information they may need from the parameter object before their constructor ends."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"init",children:"Init"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/init",children:(0,i.jsx)(n.code,{children:"init()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["The init stage runs in multiple phase. In each phase, the SST Core calls every component's ",(0,i.jsx)(n.code,{children:"init()"})," function, giving them an opportunity to exchange events. Events sent in a phase are delivered in the following phase. If after a phase, no events have been sent, the init stage ends. Elements can participate in initialization using the ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/init",children:(0,i.jsx)(n.code,{children:"init()"})})," function. This function takes a parameter, ",(0,i.jsx)(n.em,{children:"phase"}),", that passes the number of phases that have occurred so far. Components should invoke the ",(0,i.jsx)(n.code,{children:"init()"})," function of their subcomponents as needed.\nKeep in mind these limitations of the init stage:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Any event sent must use the ",(0,i.jsxs)(n.a,{href:"/sst-docs/docs/core/link/sendUntimedData",children:[(0,i.jsx)(n.em,{children:"untimed"})," version of Link send"]}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Event handlers are not active yet. Links should be polled using the untimed polling function, ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/link/recvUntimedData",children:(0,i.jsx)(n.code,{children:"recvUntimedData()"})}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Clock handlers are not active and simulation time is 0"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"At the end of the init stage:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Event handlers and link time bases need to be finalized."}),"\n",(0,i.jsx)(n.li,{children:"Writes to SharedObjects must be complete. SharedObjects are read-only once setup begins."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Example:"})," The merlin network routers use init to exchange bandwidth parameters and resolve any disagreements.\n",(0,i.jsx)(n.em,{children:"Example:"})," The memHierarchy components use init to discover the memory system topology and generate memory address based routing tables."]}),"\n",(0,i.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/setup",children:(0,i.jsx)(n.code,{children:"setup()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["The setup stage is a final opportunity to configure state prior the simulation beginning. In this stage, SST calls each component's ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/setup",children:(0,i.jsx)(n.code,{children:"setup()"})})," function once. Components should invoke the the ",(0,i.jsx)(n.code,{children:"setup()"})," function of their subcomponents as needed. This is also the first stage in which regular events can be sent. Simulations in which no components are using clocks ",(0,i.jsx)(n.em,{children:"must"})," ensure that at least one event is sent in this stage. If not, SST will have no events to process in the run stage and will immediately reach the end of simulation.\nDuring this stage:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SharedObjects are read-only"}),"\n",(0,i.jsxs)(n.li,{children:["Events should be sent using ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/link/send",children:(0,i.jsx)(n.code,{children:"send()"})}),". Untimed events may not be sent."]}),"\n",(0,i.jsxs)(n.li,{children:["Simulations without clocks ",(0,i.jsx)(n.em,{children:"must"})," send at least one event."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"run",children:"Run"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"}),"* ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/clock/clock_handler",children:"Clock handlers"})," and ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/events/event_handler",children:"event handlers"})]}),"\n",(0,i.jsxs)(n.p,{children:["The run stage is the actual simulation. In this stage, SST processes events, triggering event and/or clock handlers to progress the simulation. The run stage ends when (1) all primary components declare the simulation is done using ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/component/primaryComponentOKToEndSim",children:(0,i.jsx)(n.code,{children:"primaryComponentOKToEndSim()"})}),", (2) there are no further events to process, (3) the simulated or wall-clock time specified by SST options (stop-at, exit-after) is reached, or (4) an abnormal exit condition occurs (e.g., a ",(0,i.jsx)(n.code,{children:"SIGTERM"})," signal or call to ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/output/fatal",children:(0,i.jsx)(n.code,{children:"output.fatal()"})}),"). In case (2), the simulation will report a simulated time of ",(0,i.jsx)(n.code,{children:"MAX_SIMTIME_T"}),", or the maximum time the simulation can reach per the simulation time base, though statistics will be correct. It is generally better for models to use methods (1) or (3) to  end simulation."]}),"\n",(0,i.jsx)(n.p,{children:"In the run stage:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Event handlers cannot be changed."}),"\n",(0,i.jsx)(n.li,{children:"Anonymous subcomponents may be loaded but they cannot register statistics."}),"\n",(0,i.jsx)(n.li,{children:"Clock handlers may be changed but must have been registered during the creation phase."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"complete",children:"Complete"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/complete",children:(0,i.jsx)(n.code,{children:"complete()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["The complete stage is similar to the initialization stage. It runs in multiple phases, during which component trees may exchange untimed events. Exchange of timed events is no longer permitted as of this stage. A common use case for ",(0,i.jsx)(n.code,{children:"complete()"})," is to globally aggregate data from across component trees to output during the finish stage. Elements participate by defining the ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/complete",children:(0,i.jsx)(n.code,{children:"complete()"})})," function. Components should invoke their subcomponents' ",(0,i.jsx)(n.code,{children:"complete()"})," functions as needed."]}),"\n",(0,i.jsx)(n.h3,{id:"finish",children:"Finish"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/finish",children:(0,i.jsx)(n.code,{children:"finish()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Finish is a final opportunity for component trees to perform operations prior to their destructors being invoked. SST calls each component's ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/finish",children:(0,i.jsx)(n.code,{children:"finish()"})})," function once in this stage. Components should invoke their subcomponents' ",(0,i.jsx)(n.code,{children:"finish()"})," functions as needed."]}),"\n",(0,i.jsx)(n.h3,{id:"cleanup",children:"Cleanup"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," Destructors such as the ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/component/destructor",children:"Component destructor"})]}),"\n",(0,i.jsxs)(n.p,{children:["During the cleanup stage, SST first generates a final statistic output if statistics are enabled. It then deletes each element in the simulation. Note that SST manages the following object types; elements should ",(0,i.jsx)(n.em,{children:"not"})," delete these in their own destructors."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Objects deleted by SST-Core"})})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Clock::Handler"}),"\n",(0,i.jsx)(n.li,{children:"Component"}),"\n",(0,i.jsx)(n.li,{children:"ComponentExtension"}),"\n",(0,i.jsx)(n.li,{children:"Event::Handler"}),"\n",(0,i.jsx)(n.li,{children:"Link"}),"\n",(0,i.jsx)(n.li,{children:"Module"}),"\n",(0,i.jsx)(n.li,{children:"ProfileTool"}),"\n",(0,i.jsx)(n.li,{children:"Statistic"}),"\n",(0,i.jsx)(n.li,{children:"SharedObject"}),"\n",(0,i.jsx)(n.li,{children:"SubComponent"}),"\n",(0,i.jsx)(n.li,{children:"Any Event currently in flight in the SST-Core"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"emergency-shutdown",children:"Emergency shutdown"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/emergencyShutdown",children:(0,i.jsx)(n.code,{children:"emergencyShutdown()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Calling ",(0,i.jsx)(n.code,{children:"Output::fatal()"}),", ",(0,i.jsx)(n.code,{children:"sst_assert()"})," or sending SST a ",(0,i.jsx)(n.code,{children:"SIGTERM"})," or ",(0,i.jsx)(n.code,{children:"SIGINT"})," signal all cause SST to call ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/emergencyShutdown",children:(0,i.jsx)(n.code,{children:"emergencyShutdown()"})})," on every component in the simulation. This is primarily used to clean up state that needs special handling, such as a subprocess that may be orphaned otherwise. It can also be used to report component status. Components should invoke their subcomponents' ",(0,i.jsx)(n.code,{children:"emergencyShutdown()"})," functions as needed."]}),"\n",(0,i.jsx)(n.h3,{id:"print-status",children:"Print status"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API:"})," ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/component/lifecycle/printStatus",children:(0,i.jsx)(n.code,{children:"printStatus()"})})]}),"\n",(0,i.jsxs)(n.p,{children:["This is a special stage that is triggered by SST's default ",(0,i.jsx)(n.code,{children:"SIGUSR2"})," signal handler. Upon receiving a ",(0,i.jsx)(n.code,{children:"SIGUSR2"}),", SST calls ",(0,i.jsx)(n.code,{children:"printStatus()"})," on every component in the simulation. Elements should print their status in this stage. Components should invoke their subcomponents' ",(0,i.jsx)(n.code,{children:"printStatus()"})," functions as needed."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);