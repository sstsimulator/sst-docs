"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9572],{84727:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(74848),s=n(28453);const a={title:"find_map"},o=void 0,r={id:"core/params/find_map",title:"find_map",description:"Search for the specified key and return its value as a map in the provided argument map. The map will be empty if the key is not found. The function is parameterized on a types keyT and valT which must be valid Params parameter types (e.g., numeric including bool, string, or other class with a constructor that accepts a single string).",source:"@site/../docs/core/params/find_map.md",sourceDirName:"core/params",slug:"/core/params/find_map",permalink:"/sst-docs/docs/core/params/find_map",draft:!1,unlisted:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/params/find_map.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1702928554e3,frontMatter:{title:"find_map"},sidebar:"core",previous:{title:"find_array",permalink:"/sst-docs/docs/core/params/find_array"},next:{title:"find_set",permalink:"/sst-docs/docs/core/params/find_set"}},d={},l=[{value:"Parameters",id:"parameters",level:2},{value:"Example",id:"example",level:2},{value:"Additional information on parsing",id:"additional-information-on-parsing",level:2},{value:"Header",id:"header",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"template <class keyT, class valT>\nvoid find_map(const std::string& key, std::map<keyT, valT>& map) const;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Search for the specified key and return its value as a map in the provided argument ",(0,i.jsx)(t.code,{children:"map"}),". The map will be empty if the key is not found. The function is parameterized on a types ",(0,i.jsx)(t.code,{children:"keyT"})," and ",(0,i.jsx)(t.code,{children:"valT"})," which must be valid Params parameter types (e.g., numeric including bool, string, or other class with a constructor that accepts a single string)."]}),"\n",(0,i.jsxs)(t.p,{children:["To be interpreted as a map, a map string must adhere to a specific format. The map must be enclosed in curly braces (","). The key/value pairs should be comma separated (commas inside single or double quotes will not be considered a delimiter). Each pair should consist of a key and value separated by a colon (colons inside single or double quotes will not be considered a delimiter). If there are no curly braces , the function will throw a ",(0,i.jsx)(t.code,{children:"std::invalid_argument"}),' exception without adding anything to the map. The function is designed to accept the string that is generated when a Python dictionary is passed as a parameter value in the input configuration file. The function will then call the appropriate conversion function on the string to the templated type requested by the map. If a conversion does not exist (e.g., attempting to convert the string "hi" to an int), the function will throw an ',(0,i.jsx)(t.code,{children:"invalid_argument"})," exception. Similarly, because C++ maps do not support mixed types, the Python map string should not mix types for either keys or values."]}),"\n",(0,i.jsxs)(t.p,{children:["Examples of valid map strings in Python. These can be read into C++ maps of type ",(0,i.jsx)(t.code,{children:"std::map<std:;string,int>"})," or ",(0,i.jsx)(t.code,{children:"std::map<std::string,std::string>"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:'{"one" : 1, "two" : 2, "three" : 3, "four" : 4}'})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"{\"one\" : '1', \"two\" : '2', \"three\" : '3', \"four\" : '4'}"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:'{"one" : 1, "two" : "2", "three" : 3, "four" : "4"}'})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Example of an invalid map string in Python (mixed types cannot be converted):"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:'{"one" : 1, "two" : "two", "three" : False, "four" : 4}'})}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"key"})," (std::string) Parameter key to search for"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"map"})," (std::map<keyT, valT>) Map templated on types keyT and valT to populate from the parameter's value"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"returns"})," none"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'example::example(ComponentId_t id, Params& params) : Component(id)\n{\n    out = new Output("", 1, 0, Output::STDOUT);\n\n    /* Some other constructor stuff */\n\n    // For a parameter called "probabilities" that contains a mapping of outcome IDs (ints) to outcome probabilities (doubles)\n    std::map<int,double> probMap;\n    //highlight-next-line\n    params.find_map<int,double>("probabilities", probMap);\n\n    out->output("Probabilities are: \\n");\n    for (std::map<int,double>::iterator it = probMap.begin(); it != probMap.end(); it++)\n    {\n        out->output("Outcome: %d, Probability: %f\\n", it->first, it->second);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"additional-information-on-parsing",children:"Additional information on parsing"}),"\n",(0,i.jsxs)(t.p,{children:["For those interested in a more detailed description of how this function parses a string into a map, read on. The function is tailored to the type strings you get when passing a Python dictionary as the param value. When you call ",(0,i.jsx)(t.a,{href:"../../config/component/addParam",children:(0,i.jsx)(t.code,{children:"addParam()"})})," on a Python dictionary in the input file, it will call the ",(0,i.jsx)(t.code,{children:"str()"})," function on the dictionary, which creates a string with the format: ",(0,i.jsx)(t.code,{children:"{key1 : value1, key2 : value2, key3 : value3}"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The format of each item depends on where it came from. The string for each key and value is generated by calling the ",(0,i.jsx)(t.code,{children:"repr()"})," function on the item. For strings, this means they will typically be enclosed in single quotes. It is possible that they end up enclosed in double quotes if the string itself contains a single quote. For strings which contain both single and double quotes, the ",(0,i.jsx)(t.code,{children:"repr()"})," will create a single quoted string with all internal single quotes escaped with ''. Most other items used in SST do not enclose the string in quotes, though any string that contains a comma would need to be enclosed in quotes, since the comma is the delimiter character used. This is not done automatically, so if you have something that generates a comma in the string created by ",(0,i.jsx)(t.code,{children:"repr()"}),", you may need to create a map string manually. Also, any string that starts with a quote character, must end with the same quote character."]}),"\n",(0,i.jsx)(t.p,{children:"Tokens are generated by splitting the string on commas and colons that are not within quotes (double or single). All whitespace at the beginning and end of a token is ignored (unless inside quotes). Once the tokens are generated, any quoted string will have the front and back quotes removed. The '' for any escaped quote of the same type as the front and back is also removed."}),"\n",(0,i.jsx)(t.p,{children:"Examples of parsing strings using double and/or single quotes:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'\'This is "a" test\' -> This is "a" test'}),"\n",(0,i.jsx)(t.li,{children:"\"This is 'a' test\" -> This is 'a' test"}),"\n",(0,i.jsx)(t.li,{children:"'This \"is 'a'\" test' -> This \"is 'a''\" test"}),"\n",(0,i.jsx)(t.li,{children:'\'This "is "a"" test\' -> This "is "a"" test'}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,i.jsx)(t.p,{children:"The Params header file is included with any SST object that supports Params."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/componentExtension.h> // or\n#include <sst/core/params.h> // if not included in base class\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(96540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);