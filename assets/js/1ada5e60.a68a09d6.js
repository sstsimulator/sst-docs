"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[20112],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},44628:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"guides/features/checkpoint","title":"Checkpoint and restart","description":"In SST 14, SST began bringing back checkpoint/restart support. Elements are not automatically checkpoint-able. To enable checkpoint/restart, developers must create a function in each element that describes how to serialize the element. A simulation can be checkpointed if all of the elements it uses support checkpoint (i.e., are serializable).","source":"@site/../docs/guides/features/checkpoint.mdx","sourceDirName":"guides/features","slug":"/guides/features/checkpoint","permalink":"/sst-docs/docs/guides/features/checkpoint","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/guides/features/checkpoint.mdx","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1729787241000,"frontMatter":{"title":"Checkpoint and restart"},"sidebar":"guides","previous":{"title":"Features","permalink":"/sst-docs/docs/category/features"},"next":{"title":"Signal handling","permalink":"/sst-docs/docs/guides/features/signal"}}');var s=i(74848),r=i(28453),a=i(65537),l=i(79329);const o={title:"Checkpoint and restart"},c=void 0,d={},h=[{value:"Support status",id:"support-status",level:2},{value:"Creating a checkpoint",id:"creating-a-checkpoint",level:2},{value:"Restarting from a checkpoint",id:"restarting-from-a-checkpoint",level:2},{value:"Adding checkpoint support to element libraries",id:"adding-checkpoint-support-to-element-libraries",level:2},{value:"Step 1: Inherit from the Serializable class - non-Element classes ONLY",id:"step-1-inherit-from-the-serializable-class---non-element-classes-only",level:3},{value:"Step 2: Change Clock and Event handler functions",id:"step-2-change-clock-and-event-handler-functions",level:3},{value:"Step 3: Add a default constructor",id:"step-3-add-a-default-constructor",level:3},{value:"Step 4: Add a serialization function",id:"step-4-add-a-serialization-function",level:3},{value:"Step 5: Add the appropriate serialization macro",id:"step-5-add-the-appropriate-serialization-macro",level:3},{value:"Put it together: An example",id:"put-it-together-an-example",level:3},{value:"Advanced notes on serialization",id:"advanced-notes-on-serialization",level:2},{value:"Background",id:"background",level:3},{value:"Example: Serializing UnitAlgebra",id:"example-serializing-unitalgebra",level:3},{value:"Planned improvements",id:"planned-improvements",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In SST 14, SST began bringing back checkpoint/restart support. Elements are not automatically checkpoint-able. To enable checkpoint/restart, developers must create a function in each element that describes how to serialize the element. A simulation can be checkpointed if ",(0,s.jsx)(n.em,{children:"all"})," of the elements it uses support checkpoint (i.e., are serializable)."]}),"\n",(0,s.jsxs)(n.p,{children:["The checkpoint/restart infrastructure is intended to enable users to recover from node failure or to comply with job timeouts on machines with job time limits. Thus the assumption is that restart will occur on the same or a similar machine with the same version of SST. SST's serialization uses C++ ",(0,s.jsx)(n.code,{children:"typeid"}),"s which are not guaranteed to be portable across architectures or compilers."]}),"\n",(0,s.jsx)(n.p,{children:"This guide describes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#support-status",children:"Support status"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#creating-a-checkpoint",children:"How to checkpoint"})," and ",(0,s.jsx)(n.a,{href:"#restarting-from-a-checkpoint",children:"restart a simulation"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#adding-checkpoint-support-to-element-libraries",children:"How to add checkpoint support to an element library"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#planned-improvements",children:"Planned improvements"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"support-status",children:"Support status"}),"\n",(0,s.jsx)(n.p,{children:"Select the version of SST you are using to see version-specific information. As support evolves, the repository information will be updated."}),"\n","\n",(0,s.jsxs)(a.A,{groupId:"release-version",children:[(0,s.jsxs)(l.A,{value:"14.0",label:"14.0 Release",default:!0,children:[(0,s.jsx)(n.p,{children:'"Serializable types" lists types that SST automatically serializes or that have an API available.'}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel support:"})," Only serial simulations can be checkpointed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checkpoint triggers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Simulated time interval using the ",(0,s.jsx)(n.code,{children:"--checkpoint-period"})," command line option."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['A binary file named "PREFIX_TIME_ID.sstcpt" where PREFIX=checkpoint, TIME is simulated time of the checkpoint and ID is a incrementing integer starting at 0. PREFIX can be changed using the ',(0,s.jsx)(n.code,{children:"--checkpoint-prefix"})," command-line option."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API available: Component, SubComponent, ComponentExtension, Module"}),"\n",(0,s.jsx)(n.li,{children:"POD types and pointers to POD types"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::vector"}),", ",(0,s.jsx)(n.code,{children:"std::set"}),", ",(0,s.jsx)(n.code,{children:"std::map"}),", ",(0,s.jsx)(n.code,{children:"std::multiset"}),", ",(0,s.jsx)(n.code,{children:"std::priority_queue"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Statistics are not checkpointed. On restart, any previously enabled statistics will be disabled."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["SST Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n"]}),"\n"]}),"\n"]})]}),(0,s.jsxs)(l.A,{value:"14.1",label:"14.1 Release",default:!0,children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"The SST 14.1 release added support for parallel simulations, additional checkpoint triggers, and checkpointing statistics."})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel support:"})," All simulations, parallel and serial, can be checkpointed. Checkpoint and restart require the same parallelization (e.g., if checkpoint was generated with SST running two threads, SST must be restarted using two threads)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API available: Component, SubComponent, ComponentExtension, Module"}),"\n",(0,s.jsx)(n.li,{children:"POD types and pointers to POD types"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::vector"}),", ",(0,s.jsx)(n.code,{children:"std::set"}),", ",(0,s.jsx)(n.code,{children:"std::map"}),", ",(0,s.jsx)(n.code,{children:"std::multiset"}),", ",(0,s.jsx)(n.code,{children:"std::priority_queue"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checkpoint triggers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Simulated time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["Real (wall) time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-wall-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["On a signal by using the ",(0,s.jsx)(n.code,{children:"--sigusr1=sst.rt.checkpoint"})," or ",(0,s.jsx)(n.code,{children:"--sigusr2=sst.rt.checkpoint"})," command line options."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['Checkpoints are placed in a directory named "PREFIX" which is "checkpoint" by default. Use ',(0,s.jsx)(n.code,{children:"--checkpoint-prefix"}),' to change the prefix. If the directory already exists, SST will create a new one named "PREFIX_ID" using a unique integer for ID.']}),"\n",(0,s.jsx)(n.li,{children:'Within the directory, there is a subdirectory for each checkpoint which is named "PREFIX_ID_TIME". ID is a unique integer and TIME is the simulated time at checkpoint.'}),"\n",(0,s.jsxs)(n.li,{children:["Within the checkpoint subdirectory are a number of files.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Registry: A plaintext file named "PREFIX_ID_TIME.sstcpt". This is the file to specify when restarting.'}),"\n",(0,s.jsx)(n.li,{children:'Globals: A binary file containing global checkpoint data named "PREFIX_ID_TIME_globals.bin"'}),"\n",(0,s.jsx)(n.li,{children:"Data files: One per thread/rank and named PREFIX_ID_TIME_RANK_THREAD.bin"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]}),(0,s.jsxs)(l.A,{value:"repo",label:"SST Repositories",default:!0,children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Repository support is currently identical to the SST 14.1 release."})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel support:"})," All simulations, parallel and serial, can be checkpointed. Checkpoint and restart require the same parallelization (e.g., if checkpoint was generated with SST running two threads, SST must be restarted using two threads)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Serializable types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API available: Component, SubComponent, ComponentExtension, Module"}),"\n",(0,s.jsx)(n.li,{children:"POD types and pointers to POD types"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::vector"}),", ",(0,s.jsx)(n.code,{children:"std::set"}),", ",(0,s.jsx)(n.code,{children:"std::map"}),", ",(0,s.jsx)(n.code,{children:"std::multiset"}),", ",(0,s.jsx)(n.code,{children:"std::priority_queue"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checkpoint triggers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Simulated time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["Real (wall) time using the ",(0,s.jsx)(n.code,{children:"--checkpoint-wall-period"})," command line option."]}),"\n",(0,s.jsxs)(n.li,{children:["On a signal by using the ",(0,s.jsx)(n.code,{children:"--sigusr1=sst.rt.checkpoint"})," or ",(0,s.jsx)(n.code,{children:"--sigusr2=sst.rt.checkpoint"})," command line options."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['Checkpoints are placed in a subdirectory in the current working directory named "PREFIX" which is "checkpoint" by default. Use ',(0,s.jsx)(n.code,{children:"--checkpoint-prefix"}),' to change the prefix. If the subdirectory already exists, SST will create a new one named "PREFIX_ID" using a unique integer for ID.']}),"\n",(0,s.jsx)(n.li,{children:'Within the directory, there is a subdirectory for each checkpoint which is named "PREFIX_ID_TIME". ID is a unique integer and TIME is the simulated time at checkpoint.'}),"\n",(0,s.jsxs)(n.li,{children:["Within each individual checkpoint subdirectory are a number of files.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Registry: A plaintext file named "PREFIX_ID_TIME.sstcpt". This is the file to specify when restarting.'}),"\n",(0,s.jsx)(n.li,{children:'Globals: A binary file containing global checkpoint data named "PREFIX_ID_TIME_globals.bin"'}),"\n",(0,s.jsx)(n.li,{children:"Data files: One per thread/rank and named PREFIX_ID_TIME_RANK_THREAD.bin"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-checkpoint",children:"Creating a checkpoint"}),"\n",(0,s.jsx)(n.p,{children:"The command line option to create a checkpoint changed between SST 14.0 and SST 14.1 and the repositories. Select your version."}),"\n",(0,s.jsxs)(a.A,{groupId:"release-version",children:[(0,s.jsxs)(l.A,{value:"14.0",label:"14.0 Release",default:!0,children:[(0,s.jsx)(n.p,{children:'Enable checkpoints by giving SST a frequency at which to generate checkpoints either on the command line or in the simulation configuration file. The checkpoint file name prefix can also be customized (default is "checkpoint").'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints on the command line"',children:'$ sst --checkpoint-period=250us configuration.py\n$ sst --checkpoint-period=250us --checkpoint-prefix="simulation" configuration.py\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",metastring:'title="Enabling checkpoints in the SST configuration file"',children:'import sst\n\nsst.setProgramOption("checkpoint-period", "250us")\nsst.setProgramOption("checkpoint-prefix", "simulation") # Optional\n'})}),(0,s.jsxs)(n.p,{children:["The period refers to ",(0,s.jsx)(n.strong,{children:"simulated time"})," and must include units. SI-prefixes are valid."]}),(0,s.jsx)(n.p,{children:'The examples above produce a checkpoint every 250us. Checkpoints are written to the current working directory with the file name PREFIX_TIME_ID.sstcpt. If no prefix option was given, the PREFIX is "checkpoint". TIME is the time of the checkpoint as measured in the simulation\'s core time base. For most simulations, this is picoseconds. ID starts at 0 for the first checkpoint and is incremented for each subsequent checkpoint.'})]}),(0,s.jsxs)(l.A,{value:"14.1",label:"14.1 Release",default:!0,children:[(0,s.jsx)(n.p,{children:'There are three options for triggering checkpoints: (1) on a simulation time interval, (2) on a wall (real) time interval, and (3) by sending SST a signal. A prefix to use for checkpoint directories and file names can also be given (default is "checkpoint").'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints at a simulation time interval on the command line"',children:'$ sst --checkpoint-sim-period=250us configuration.py\n$ sst --checkpoint-sim-period=250us --checkpoint-prefix="simulation" configuration.py\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints on a wall time interval on the command line"',children:'$ sst --checkpoint-wall-period=10m configuration.py\n$ sst --checkpoint-wall-period=10m --checkpoint-prefix="simulation" configuration.py\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoint when a SIGUSR1 or SIGUSR2 is sent to SST"',children:'$ sst --sigusr1=sst.rt.checkpoint configuration.py\n$ sst --sigusr2=sst.rt.checkpoint --checkpoint-prefix="simulation" configuration.py\n\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",metastring:'title="Any command line parameter can be set in the configuration file instead"',children:'import sst\n\nsst.setProgramOption("checkpoint-wall-period", "10m")    # Enable on a frequency in terms of wall time\nsst.setProgramOption("checkpoint-prefix", "simulation")  # Optional\n# sst.setProgramOption("checkpoint-sim-period", "250us") # Uncomment to enable on a frequency in terms of simulated time\n# sst.setProgramOption("sigusr1", "sst.rt.checkpoint")   # Uncomment to trigger a checkpoint when SST receives SIGUSR1\n# sst.setProgramOption("sigusr2", "sst.rt.checkpoint")   # Uncomment to trigger a checkpoint when SST receives SIGUSR2\n'})}),(0,s.jsxs)(n.p,{children:["Simulated times must include units and SI-prefixes are valid. Wall times must be formatted as HH::MM::SS, MM::SS, or SS. Alternately, an integer with a time unit (",(0,s.jsx)(n.code,{children:"h"}),", ",(0,s.jsx)(n.code,{children:"m"}),", or ",(0,s.jsx)(n.code,{children:"s"}),") can be given."]}),(0,s.jsx)(n.p,{children:'If checkpoints are enabled, SST creates a directory named PREFIX in the current working directory where checkpoints will be placed. If a directory called PREFIX already exists, SST will name the directory PREFIX_ID and increment ID to the smallest integer that is a new directory name. (e.g., if "checkpoint_0" exists, SST will use "checkpoint_1"). An example directory structure is shown below.'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"current working directory\n|--checkpoint\n   |--checkpoint_0_1000\n      |--checkpoint_0_1000.sstcpt\n      |--checkpoint_0_1000_globals.bin\n      |--checkpoint_0_1000_0_0.bin\n      |--checkpoint_0_1000_1_0.bin\n    |--checkpoint_1_2000\n      |--checkpoint_1_2000.sstcpt\n      |--checkpoint_1_2000_globals.bin\n      |--checkpoint_1_2000_0_0.bin\n      |--checkpoint_1_2000_1_0.bin\n"})}),(0,s.jsx)(n.p,{children:"Each generated checkpoint creates its own subdirectory named PREFIX_ID_TIME where ID is a unique (incrementing) integer and time is the simulated time. In that directory is a plaintext checkpoint registry file and a number of global files (one per thread/rank). The registry file should be given to SST to restart the simulation."})]}),(0,s.jsxs)(l.A,{value:"repo",label:"SST Repositories",default:!0,children:[(0,s.jsx)(n.p,{children:'There are three options for triggering checkpoints: (1) on a simulation time interval, (2) on a wall (real) time interval, and (3) by sending SST a signal. A prefix to use for checkpoint directories and file names can also be given (default is "checkpoint").'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints at a simulation time interval on the command line"',children:'$ sst --checkpoint-sim-period=250us configuration.py\n$ sst --checkpoint-sim-period=250us --checkpoint-prefix="simulation" configuration.py\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoints on a wall time interval on the command line"',children:'$ sst --checkpoint-wall-period=10m configuration.py\n$ sst --checkpoint-wall-period=10m --checkpoint-prefix="simulation" configuration.py\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",metastring:'title="Enabling checkpoint when a SIGUSR1 or SIGUSR2 is sent to SST"',children:'$ sst --sigusr1=sst.rt.checkpoint configuration.py\n$ sst --sigusr2=sst.rt.checkpoint --checkpoint-prefix="simulation" configuration.py\n\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",metastring:'title="Any command line parameter can be set in the configuration file instead"',children:'import sst\n\nsst.setProgramOption("checkpoint-wall-period", "10m")    # Enable on a frequency in terms of wall time\nsst.setProgramOption("checkpoint-prefix", "simulation")  # Optional\n# sst.setProgramOption("checkpoint-sim-period", "250us") # Uncomment to enable on a frequency in terms of simulated time\n# sst.setProgramOption("sigusr1", "sst.rt.checkpoint")   # Uncomment to trigger a checkpoint when SST receives SIGUSR1\n# sst.setProgramOption("sigusr2", "sst.rt.checkpoint")   # Uncomment to trigger a checkpoint when SST receives SIGUSR2\n'})}),(0,s.jsxs)(n.p,{children:["Simulated times must include units and SI-prefixes are valid. Wall times must be formatted as HH::MM::SS, MM::SS, or SS. ALternately, an integer with a time unit (",(0,s.jsx)(n.code,{children:"h"}),", ",(0,s.jsx)(n.code,{children:"m"}),", or ",(0,s.jsx)(n.code,{children:"s"}),") can be given."]}),(0,s.jsx)(n.p,{children:'If checkpoints are enabled, SST creates a directory named PREFIX in the current working directory where checkpoints will be placed. If a directory called PREFIX already exists, SST will name the directory PREFIX_ID and increment ID to the smallest integer that is a new directory name. (e.g., if "checkpoint_0" exists, SST will use "checkpoint_1"). An example directory structure is shown below.'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"current working directory\n|--checkpoint\n   |--checkpoint_0_1000\n      |--checkpoint_0_1000.sstcpt\n      |--checkpoint_0_1000_globals.bin\n      |--checkpoint_0_1000_0_0.bin\n      |--checkpoint_0_1000_1_0.bin\n    |--checkpoint_1_2000\n      |--checkpoint_1_2000.sstcpt\n      |--checkpoint_1_2000_globals.bin\n      |--checkpoint_1_2000_0_0.bin\n      |--checkpoint_1_2000_1_0.bin\n"})}),(0,s.jsx)(n.p,{children:"Each generated checkpoint creates its own subdirectory named PREFIX_ID_TIME where ID is a unique (incrementing) integer and time is the simulated time. In that directory is a plaintext checkpoint registry file and a number of global files (one per thread/rank). The registry file should be given to SST to restart the simulation."})]})]}),"\n",(0,s.jsx)(n.h2,{id:"restarting-from-a-checkpoint",children:"Restarting from a checkpoint"}),"\n",(0,s.jsxs)(n.p,{children:["To restart from a checkpoint, use the ",(0,s.jsx)(n.code,{children:"--load-checkpoint"}),' option and pass the checkpoint file (with suffix ".sstcpt") instead of a configuration file.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ sst --load-checkpoint checkpoint/checkpoint_0_1000/checkpoint_0_1000.sstcpt\n"})}),"\n",(0,s.jsx)(n.h2,{id:"adding-checkpoint-support-to-element-libraries",children:"Adding checkpoint support to element libraries"}),"\n",(0,s.jsx)(n.p,{children:"Follow the steps below for each class, struct, etc. in your element Library. This will tell SST how to serialize your data structures. Depending on your object type, some steps may be skipped."}),"\n",(0,s.jsx)(n.p,{children:"Note: The same serialization engine is used both for the existing Event serialization in parallel simulations and for checkpointing. Thus, the steps are similar to the steps needed to make Events serializable. Like Event serialization, checkpointing requires data to be explicitly added to the serialization stream. Unlike Event serialization, checkpointing tracks and tags pointers to objects so that upon restart, a pointer will correctly point to the recreated object."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-inherit-from-the-serializable-class---non-element-classes-only",children:"Step 1: Inherit from the Serializable class - non-Element classes ONLY"}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"Skip this step if any of the following apply:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Your class is an SST Element or inherits from a class that is already serializable (examples: ",(0,s.jsx)(n.code,{children:"SST::Component"}),", ",(0,s.jsx)(n.code,{children:"SST::SubComponent"}),", ",(0,s.jsx)(n.code,{children:"SST::Module"}),", ",(0,s.jsx)(n.code,{children:"SST::Event"}),", etc)."]}),"\n",(0,s.jsx)(n.li,{children:"Your object is a struct"}),"\n",(0,s.jsx)(n.li,{children:"Your object is a non-polymorphic class."}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"For all other classes, inherit from SST's serializable class as shown."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="Inheriting from SST\'s serializable class"',children:"#include <sst/core/serialization/serializable.h>\n\nclass MyClass : public SST::Core::Serialization::serializable {\n    ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-change-clock-and-event-handler-functions",children:"Step 2: Change Clock and Event handler functions"}),"\n",(0,s.jsxs)(n.p,{children:["Change the handler type from ",(0,s.jsx)(n.code,{children:"Handler"})," to ",(0,s.jsx)(n.code,{children:"Handler2"})," and move the function pointer from the constructor parameters into the template parameters as shown. The old handler types are not serializable and will cause errors if you attempt to serialize them."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Clock handler without metadata\nSST::Clock::HandlerBase* old_handler = \n    new SST::Clock::Handler<ComponentName>(this, &ComponentName::HandlerFunction); // Not serializable\nSST::Clock::HandlerBase* new_handler = \n    new SST::Clock::Handler2<ComponentName, &ComponentName::HandlerFunction>(this); // Serializable\n\n// Clock handler with metadata\nSST::Clock::HandlerBase* old_handler = \n    new SST::Clock::Handler<ComponentName, uint32_t>(this, &ComponentName::HandlerFunction, 0); // Not serializable\nSST::Clock::HandlerBase* new_handler = \n    new SST::Clock::Handler2<ComponentName, &ComponentName::HandlerFunction, uint32_t>(this, 0); // Serializable\n\n// Event handler without metadata\nSST::Link::HandlerBase* old_handler = \n    new SST::Event::Handler<ComponentName>(this, &ComponentName::HandlerFunction); // Not serializable\nSST::Link::HandlerBase* new_handler = \n    new SST::Event::Handler2<ComponentName, &ComponentName::HandlerFunction>(this); // Serializable\n\n// Event handler with metadata\nSST::Event::HandlerBase* old_handler = \n    new SST::Event::Handler<ComponentName, uint32_t>(this, &ComponentName::HandlerFunction, 0); // Not serializable\nSST::Event::HandlerBase* new_handler = \n    new SST::Event::Handler2<ComponentName, &ComponentName::HandlerFunction, uint32_t>(this, 0); // Serializable\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-add-a-default-constructor",children:"Step 3: Add a default constructor"}),"\n",(0,s.jsx)(n.p,{children:"During deserialization, SST will call this constructor to create an object before populating its state from the checkpoint."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MyClass();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-add-a-serialization-function",children:"Step 4: Add a serialization function"}),"\n",(0,s.jsxs)(n.p,{children:["SST's serializer calls ",(0,s.jsx)(n.code,{children:"serialize_order"})," on elements during both serialization and deserialization.\nAdd this function to a public section of your class definition:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title = "class.h"',children:"public:\n    // highlight-start\n    void serialize_order(SST::Core::Serialization::serializer& ser) override;\n    // highlight-end\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, if you class inherits from another, call that classes's ",(0,s.jsx)(n.code,{children:"serialize_order"})," function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void MyClass:serialize_order(SST::Core::Serialization::serializer& ser)\n{\n    BaseClass::serialize_oder(ser);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Last, add ",(0,s.jsx)(n.em,{children:"all"})," class data members that need to be saved to the checkpoint using the macros ",(0,s.jsx)(n.code,{children:"SST_SER"})," and ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If you are adding a data member that is not itself a pointer but other pointers to it exist and will be serialized, use ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"}),". See note below."]}),"\n",(0,s.jsxs)(n.li,{children:["In all other cases (serializing pointers or serializing non-pointers which are not pointed to), use ",(0,s.jsx)(n.code,{children:"SST_SER"}),".\nIf you are familiar with Event serialization, these macros implement the ",(0,s.jsx)(n.code,{children:"ser& x"})," and ",(0,s.jsx)(n.code,{children:"ser| x"})," syntax used there. However, they also enable interactive debugging of your element (as of SST 14.1) so the macros are preferred."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note: The ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"}),"(",(0,s.jsx)(n.code,{children:"|"}),") operator works only for non-pointer data and adds both the data to the checkpoint ",(0,s.jsx)(n.em,{children:"and"})," registers a pointer to the data. This operator is only required if the object being serialized is not a pointer and you have a pointer elsewhere to the object that you intend to serialize as well. Using this macro allows a serialized pointer to correctly link itself to the serialized data. Using ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"})," consumes both extra space in the checkpoint and adds a (small) overhead during serialization. The non-pointer data must serialize before any pointers to the data are serialized, otherwise the deserialized data will not be correct. One use case for ",(0,s.jsx)(n.code,{children:"SST_SER_AS_PTR"})," is when the data is stored in a container (such as a map or set) and there are other pointers to the data."]}),"\n",(0,s.jsx)(n.p,{children:"By way of example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"/* Class variables */\n// \nSST::Link* link;\nSST::Output* output;\nSST::TimeConverter* tc;\nint count;\nstd::string name;\nstd::vector<uint32_t> nums;\nstd::string pointedToObj;\nstd::string* pointer = &pointedToObj;\n\n/* Serialization function */\nvoid serialize_order(SST::Core::Serialization::Serializer& ser) override\n{\n    BaseClass::serialize_order(ser); // Assuming this class has a base class called 'BaseClass'. ALWAYS call the base class's serialize_order function prior to adding data from this class.\n    SST_SER(link)\n    SST_SER(output)\n    SST_SER(tc)\n    SST_SER(count)\n    SST_SER(name)\n    SST_SER(nums)\n    SST_SER_AS_PTR(pointedToObj) // Track a pointer to this object\n    SST_SER(pointer)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Many data types are supported natively in SST's serialization libraries. These include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"POD types"}),"\n",(0,s.jsx)(n.li,{children:"Pointers to POD types"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::vector"}),", ",(0,s.jsx)(n.code,{children:"std::set"}),", ",(0,s.jsx)(n.code,{children:"std::map"}),", ",(0,s.jsx)(n.code,{children:"std::multiset"}),", ",(0,s.jsx)(n.code,{children:"std::priority_queue"})]}),"\n",(0,s.jsxs)(n.li,{children:["SST types: ",(0,s.jsx)(n.code,{children:"Link"}),", ",(0,s.jsx)(n.code,{children:"TimeConverter"}),", ",(0,s.jsx)(n.code,{children:"Output"}),", ",(0,s.jsx)(n.code,{children:"RNG:Random"}),", ",(0,s.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,s.jsx)(n.code,{children:"SharedArray"}),", ",(0,s.jsx)(n.code,{children:"SharedMap"}),", ",(0,s.jsx)(n.code,{children:"SharedSet"}),", ",(0,s.jsx)(n.code,{children:"UnitAlgebra"}),", ",(0,s.jsx)(n.code,{children:"Statistic"}),", ",(0,s.jsx)(n.code,{children:"StatisticOutput"})]}),"\n",(0,s.jsxs)(n.li,{children:["Handlers: ",(0,s.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,s.jsx)(n.code,{children:"Event::Handler2"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Note that non-polymorphic classes/structs are special cases in the serialization library. Because there is no way to reference the class with a different type, there is no need to inherit from ",(0,s.jsx)(n.code,{children:"Serializable"})," or call the ",(0,s.jsx)(n.code,{children:"ImplementSerializable"})," macro (step 5 below). You may simply add a ",(0,s.jsx)(n.code,{children:"serialize_order()"})," function to the class as listed above and the class will be compatible with the serializer."]}),"\n",(0,s.jsx)(n.h3,{id:"step-5-add-the-appropriate-serialization-macro",children:"Step 5: Add the appropriate serialization macro"}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"Skip this step if any of the following apply:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You are serializing a struct"}),"\n",(0,s.jsx)(n.li,{children:"Your class is non-polymorphic"}),"\n"]})]}),"\n",(0,s.jsxs)(n.p,{children:["Classes that inherit from ",(0,s.jsx)(n.code,{children:"SST::Core::Serialization::serializable"})," must call the ",(0,s.jsx)(n.code,{children:"ImplementSerializable"})," macro with their class name. Note that the macro should be called from a public section of the class definition."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"MyClass : public SST::Component\n{\npublic:\n    // Class functions\n    \n    ImplementSerializable(MyClass)\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Pure virtual classes must use ",(0,s.jsx)(n.code,{children:"ImplementVirtualSerializable"})," instead of ",(0,s.jsx)(n.code,{children:"ImplementSerializable"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"put-it-together-an-example",children:"Put it together: An example"}),"\n",(0,s.jsx)(n.p,{children:"Here is an example of what this looks like. Note we've removed all but the relevant-to-checkpointing pieces of the class (ELI macros, most class functions, etc.)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="example.h"',children:"#ifndef SST_EXAMPLE_CHECKPOINT_HEADER\n#define SST_EXAMPLE_CHECKPOINT_HEADER\n\n#include <sst/core/component.h>\n#include <sst/core/link.h>\n#include <sst/core/rng/marsaglia.h>\n\nnamespace SST {\nnamespace ExampleSSTLibrary {\n\nclass example : public SST::Component { // Step 1 - SST::Component already inherits from Serializable\npublic:\n    // ELI macros would be here\n    \n    // Public class members would be here\n\n    //highlight-start\n    // Step 3 - Add default constructor, serialize_order, and serializable macro\n    example();\n    void serialize_order(SST::Core::Serialization::serializer& ser) override;\n    ImplementSerializable(SST::ExampleSSTLibrary::example)\n    //highlight-end\nprivate:\n    // Private member functions would be here\n\n    // Private data members - to be serialized in serialize_order\n    int64_t param0;\n    uint32_t param1;\n    std::string param2;\n    Statistic<uint64_t> stat;\n    SST::Output* out;\n    std::vector<std::string> stringVec;\n    SST::Link* link;\n    RNG::Random* rng;\n};\n\n} } // End namespaces\n#endif\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",metastring:'title="example.cc"',children:"// Rest of class defined here\n\n// highlight-start\nexample::example() : Component() {}\n\nvoid example::serialize_order(SST::Core::Serialization::serializer& ser) {\n    // MUST call parent's serialize_order FIRST\n    Component::serialize_order(ser);\n\n    // Now, serialize everything we need to save\n    SST_SER(param0)\n    SST_SER(param1)\n    SST_SER(param2)\n    SST_SER(stat)\n    SST_SER(out)\n    SST_SER(stringVec)\n    SST_SER(link)\n    SST_SER(rng)\n}\n//highlight-end\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-notes-on-serialization",children:"Advanced notes on serialization"}),"\n",(0,s.jsx)(n.p,{children:"While many types are serializable already within SST's serialization engine, complex types may require additional work."}),"\n",(0,s.jsx)(n.h3,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:["Checkpoint uses three stages of serialization (a fourth, MAP, exists for interactive debugging). They are: (1) SIZER, (2) PACK, and (3) UNPACK. When writing a checkpoint, SIZER and PACK are used to serialize the state of simulation and write it to file. During restart, UNPACK is used to deserialize the checkpointed data. In each stage, the serializer will call ",(0,s.jsx)(n.code,{children:"serialize_order"})," on each object. Thus, if the default serialization does not work for a particular type, a custom serialization can be implemented by querying the serializer's mode in the ",(0,s.jsx)(n.code,{children:"serialize_order"})," function and taking the appropriate action to serialize the type. During ",(0,s.jsx)(n.code,{children:"SIZER"}),", the ",(0,s.jsx)(n.code,{children:"serialize_order"})," function should add the size of the data to be serialized using the ",(0,s.jsx)(n.code,{children:"&"})," (typically) or ",(0,s.jsx)(n.code,{children:"|"})," (serialize-as-pointer) operator. During ",(0,s.jsx)(n.code,{children:"PACK"}),", ",(0,s.jsx)(n.code,{children:"serialize_order"})," should add the data to be added to the serialization stream using the ",(0,s.jsx)(n.code,{children:"&"})," or ",(0,s.jsx)(n.code,{children:"|"})," operator. Finally, during ",(0,s.jsx)(n.code,{children:"UNPACK"}),", ",(0,s.jsx)(n.code,{children:"serialize_order"})," should read the serialized data from the stream, again using the ",(0,s.jsx)(n.code,{children:"&"})," or ",(0,s.jsx)(n.code,{children:"|"})," operator. The same operator should be used in all three stages. The fourth stage, ",(0,s.jsx)(n.code,{children:"MAP"}),", should be defined in the case switch statements and left empty."]}),"\n",(0,s.jsx)(n.h3,{id:"example-serializing-unitalgebra",children:"Example: Serializing UnitAlgebra"}),"\n",(0,s.jsxs)(n.p,{children:["As an example, the code snippet below shows how ",(0,s.jsx)(n.code,{children:"SST::UnitAlgebra"}),' is serialized. UnitAlgebra has two components, a "unit" struct that contains a numerator (string) and denominator (string) and a "value" object that is a custom type called ',(0,s.jsx)(n.code,{children:"decimal_fixedpoint"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:['The "unit" struct consists of strings so UnitAlgebra serializes the struct\'s members using the ',(0,s.jsx)(n.code,{children:"&"})," operator in all three serializer stages (",(0,s.jsx)(n.code,{children:"SIZER"}),", ",(0,s.jsx)(n.code,{children:"PACK"}),", and ",(0,s.jsx)(n.code,{children:"UNPACK"}),"). To serialize ",(0,s.jsx)(n.code,{children:"decimal_fixedpoint"}),", SST converts it to a string, stores the string, and then, on deserialization, re-initializes a new ",(0,s.jsx)(n.code,{children:"decimal_fixedpoint"})," type using the stored string."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the ",(0,s.jsx)(n.code,{children:"SST_SER"})," macro is only useful for class members - ",(0,s.jsx)(n.code,{children:"unit.numerator"})," and ",(0,s.jsx)(n.code,{children:"unit.denominator"})," in the example below. For temporaries, use the raw (",(0,s.jsx)(n.code,{children:"&"})," or ",(0,s.jsx)(n.code,{children:"|"}),") serialization operators."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"    void serialize_order(SST::Core::Serialization::serializer& ser) override\n    {\n        // Do the unit - these are both strings, no special handling required\n        SST_SER(unit.numerator);\n        SST_SER(unit.denominator);\n\n        // For value, first convert to a string\n        // Then, reinitialize from the string\n        switch ( ser.mode() ) {\n        case SST::Core::Serialization::serializer::SIZER:\n        case SST::Core::Serialization::serializer::PACK:\n        {\n            std::string s = value.toString(0);\n            // The next line will get the size of the string during SIZER\n            // and will pack the string into the serialization stream during PACK\n            ser&        s; // Could equivalently use SST_SER but not needed since 's' is not a class member\n            break;\n        }\n        case SST::Core::Serialization::serializer::UNPACK:\n        {   \n            // Extract the serialized string from the stream\n            std::string s;\n            ser&        s;\n            // Reinitialize 'value' using the string\n            value = sst_big_num(s);\n            break;\n        }\n        case SST::Core::Serialization::serializer::MAP:\n        {\n            // Case required but no implementation needed\n            break;\n        }\n        }\n    }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"planned-improvements",children:"Planned improvements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Add ability to query if an element supports checkpoint"}),"\n",(0,s.jsx)(n.li,{children:"Options to limit number of checkpoints kept and change checkpoint directory path"}),"\n",(0,s.jsx)(n.li,{children:"Serialization support for SST interfaces (SimpleNetwork, StandardMem)"}),"\n",(0,s.jsxs)(n.li,{children:["Additional flexibility when restarting SST including ability to change parallelization and re-partition components.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The current implementations allow overriding command line options that govern output such as ",(0,s.jsx)(n.code,{children:"--verbose"})," and ",(0,s.jsx)(n.code,{children:"--output-directory"})," when restarting."]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},65537:(e,n,i)=>{i.d(n,{A:()=>y});var t=i(96540),s=i(18215),r=i(65627),a=i(56347),l=i(50372),o=i(30604),c=i(11861),d=i(78749);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:i,attributes:t,default:s}}=e;return{value:n,label:i,attributes:t,default:s}}))}(i);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function u(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:i}=e;const s=(0,a.W6)(),r=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,o.aZ)(r),(0,t.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(s.location.search);n.set(r,e),s.replace({...s.location,search:n.toString()})}),[r,s])]}function x(e){const{defaultValue:n,queryString:i=!1,groupId:s}=e,r=p(e),[a,o]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=i.find((e=>e.default))??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r}))),[c,h]=m({queryString:i,groupId:s}),[x,S]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,r]=(0,d.Dv)(i);return[s,(0,t.useCallback)((e=>{i&&r.set(e)}),[i,r])]}({groupId:s}),g=(()=>{const e=c??x;return u({value:e,tabValues:r})?e:null})();(0,l.A)((()=>{g&&o(g)}),[g]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!u({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),h(e),S(e)}),[h,S,r]),tabValues:r}}var S=i(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=i(74848);function f(e){let{className:n,block:i,selectedValue:t,selectValue:a,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),d=e=>{const n=e.currentTarget,i=o.indexOf(n),s=l[i].value;s!==t&&(c(n),a(s))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=o.indexOf(e.currentTarget)+1;n=o[i]??o[0];break}case"ArrowLeft":{const i=o.indexOf(e.currentTarget)-1;n=o[i]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":i},n),children:l.map((e=>{let{value:n,label:i,attributes:r}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>{o.push(e)},onKeyDown:h,onClick:d,...r,className:(0,s.A)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":t===n}),children:i??n},n)}))})}function b(e){let{lazy:n,children:i,selectedValue:r}=e;const a=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===r));return e?(0,t.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function k(e){const n=x(e);return(0,j.jsxs)("div",{className:(0,s.A)("tabs-container",g.tabList),children:[(0,j.jsx)(f,{...n,...e}),(0,j.jsx)(b,{...n,...e})]})}function y(e){const n=(0,S.A)();return(0,j.jsx)(k,{...e,children:h(e.children)},String(n))}},79329:(e,n,i)=>{i.d(n,{A:()=>a});i(96540);var t=i(18215);const s={tabItem:"tabItem_Ymn6"};var r=i(74848);function a(e){let{children:n,hidden:i,className:a}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(s.tabItem,a),hidden:i,children:n})}}}]);