"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[74879],{2119:(e,d,s)=>{s.r(d),s.d(d,{assets:()=>a,contentTitle:()=>c,default:()=>o,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"elements/memHierarchy/stdmem","title":"StandardMem Interface","description":"MemHierarchy implements the SST::StandardMem API for integration with a processor model. The picture below shows how components like processors, accelerators, etc. interface with memHierarchy using StandardMem. The processor or other \\"endpoint\\" exchanges StandardMem requests with memHierarchy\'s StandardMem API implementation, standardInterface. The implementation handles translating requests into MemHierarchy\'s internal event types. To use the interface, a processor should load the memHierarchy.standardInterface subcomponent and connect the subcomponent\'s port to a memHierarchy component as shown.","source":"@site/../docs/elements/memHierarchy/stdmem.mdx","sourceDirName":"elements/memHierarchy","slug":"/elements/memHierarchy/stdmem","permalink":"/sst-docs/docs/elements/memHierarchy/stdmem","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/memHierarchy/stdmem.mdx","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"StandardMem Interface"},"sidebar":"elements","previous":{"title":"memHierarchy","permalink":"/sst-docs/docs/elements/memHierarchy/intro"},"next":{"title":"Connecting to MemHierarchy","permalink":"/sst-docs/docs/elements/memHierarchy/connecting"}}');var n=s(74848),t=s(28453);const i={title:"StandardMem Interface"},c=void 0,a={},l=[{value:"Requests versus Events",id:"requests-versus-events",level:2},{value:"Requests Sent to MemHierarchy&#39;s StandardInterface",id:"requests-sent-to-memhierarchys-standardinterface",level:2},{value:"StandardMem::Read",id:"standardmemread",level:3},{value:"StandardMem::Read fields",id:"standardmemread-fields",level:4},{value:"Assumptions",id:"assumptions",level:4},{value:"Response",id:"response",level:4},{value:"MemEvent Translation",id:"memevent-translation",level:4},{value:"StandardMem::Write",id:"standardmemwrite",level:3},{value:"StandardMem::Write fields",id:"standardmemwrite-fields",level:4},{value:"Assumptions",id:"assumptions-1",level:4},{value:"Response",id:"response-1",level:4},{value:"MemEvent Translation",id:"memevent-translation-1",level:4},{value:"StandardMem::FlushAddr",id:"standardmemflushaddr",level:3},{value:"StandardMem::FlushAddr fields",id:"standardmemflushaddr-fields",level:4},{value:"Assumptions",id:"assumptions-2",level:4},{value:"Response",id:"response-2",level:4},{value:"MemEvent Translation",id:"memevent-translation-2",level:4},{value:"StandardMem::FlushCache",id:"standardmemflushcache",level:3},{value:"StandardMem::FlushCache fields",id:"standardmemflushcache-fields",level:4},{value:"Assumptions",id:"assumptions-3",level:4},{value:"Response",id:"response-3",level:4},{value:"MemEvent Translation",id:"memevent-translation-3",level:4},{value:"StandardMem::LoadLink",id:"standardmemloadlink",level:3},{value:"StandardMem::LoadLink fields:",id:"standardmemloadlink-fields",level:4},{value:"Assumptions",id:"assumptions-4",level:4},{value:"Response",id:"response-4",level:4},{value:"MemEvent Translation",id:"memevent-translation-4",level:4},{value:"StandardMem::StoreConditional",id:"standardmemstoreconditional",level:3},{value:"StandardMem::StoreConditional fields",id:"standardmemstoreconditional-fields",level:4},{value:"Assumptions",id:"assumptions-5",level:4},{value:"Response",id:"response-5",level:4},{value:"MemEvent Translation",id:"memevent-translation-5",level:4},{value:"StandardMem::ReadLock",id:"standardmemreadlock",level:3},{value:"StandardMem::ReadLock fields",id:"standardmemreadlock-fields",level:4},{value:"Assumptions",id:"assumptions-6",level:4},{value:"Response",id:"response-6",level:4},{value:"MemEvent Translation",id:"memevent-translation-6",level:4},{value:"StandardMem::WriteUnlock",id:"standardmemwriteunlock",level:3},{value:"StandardMem::WriteUnlock fields",id:"standardmemwriteunlock-fields",level:4},{value:"Assumptions",id:"assumptions-7",level:4},{value:"Response",id:"response-7",level:4},{value:"MemEvent Translation",id:"memevent-translation-7",level:4},{value:"StandardMem::MoveData",id:"standardmemmovedata",level:3},{value:"StandardMem::MoveData fields",id:"standardmemmovedata-fields",level:4},{value:"Assumptions",id:"assumptions-8",level:4},{value:"Response",id:"response-8",level:4},{value:"MoveEvent Translation",id:"moveevent-translation",level:4},{value:"StandardMem::CustomReq",id:"standardmemcustomreq",level:3},{value:"StandardMem::CustomReq fields",id:"standardmemcustomreq-fields",level:4},{value:"Assumptions",id:"assumptions-9",level:4},{value:"Response",id:"response-9",level:4},{value:"CustomMemEvent Translation",id:"custommemevent-translation",level:4},{value:"Requests Sent From MemHierarchy&#39;s StandardInterface",id:"requests-sent-from-memhierarchys-standardinterface",level:2},{value:"StandardMem::ReadResp",id:"standardmemreadresp",level:3},{value:"StandardMem::Resp fields",id:"standardmemresp-fields",level:4},{value:"StandardMem::WriteResp",id:"standardmemwriteresp",level:3},{value:"StandardMem::WriteResp fields",id:"standardmemwriteresp-fields",level:4},{value:"StandardMem::FlushResp",id:"standardmemflushresp",level:3},{value:"StandardMem::FlushResp fields",id:"standardmemflushresp-fields",level:4},{value:"StandardMem::InvNotify",id:"standardmeminvnotify",level:3},{value:"StandardMem::InvNotify fields",id:"standardmeminvnotify-fields",level:4},{value:"StandardMem::CustomResp",id:"standardmemcustomresp",level:3},{value:"StandardMem::CustomResp fields",id:"standardmemcustomresp-fields",level:4},{value:"Other Implementation Notes",id:"other-implementation-notes",level:2},{value:"Tracing",id:"tracing",level:3},{value:"Polling",id:"polling",level:3},{value:"Flags",id:"flags",level:3},{value:"Requests exchanged during SST&#39;s <code>init()</code> phase",id:"requests-exchanged-during-ssts-init-phase",level:3},{value:"Scratchpad addressing",id:"scratchpad-addressing",level:3},{value:"MMIO",id:"mmio",level:3}];function h(e){const d={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(d.p,{children:["MemHierarchy implements the ",(0,n.jsx)(d.a,{href:"../../core/iface/StandardMem/class",children:(0,n.jsx)(d.code,{children:"SST::Interfaces::StandardMem"})})," API for integration with a processor model. The picture below shows how components like processors, accelerators, etc. interface with memHierarchy using ",(0,n.jsx)(d.code,{children:"StandardMem"}),'. The processor or other "endpoint" exchanges StandardMem requests with memHierarchy\'s StandardMem API implementation, ',(0,n.jsx)(d.code,{children:"standardInterface"}),". The implementation handles translating requests into MemHierarchy's internal event types. To use the interface, a processor should load the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," subcomponent and connect the subcomponent's port to a memHierarchy component as shown."]}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.img,{alt:"Interfacing with MemHierarchy&#39;s SST::StandardMem implementation",src:s(60891).A+"",width:"1104",height:"802"})}),"\n",(0,n.jsxs)(d.p,{children:["Even though the picture shows the processor connected to a cache, the same ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," subcomponent also supports connections to scratchpads, memory controllers, and networks with memHierarchy components on them. This page discusses how memHierarchy implements the interface and assumptions it makes, as well as specifics about how particular memHierarchy components treat various request types. The ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," subcomponent is implemented by the ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," class."]}),"\n",(0,n.jsx)(d.h2,{id:"requests-versus-events",children:"Requests versus Events"}),"\n",(0,n.jsxs)(d.p,{children:["In SST terminology, an ",(0,n.jsx)(d.em,{children:"Event"})," is an object that can be passed over an SST ",(0,n.jsx)(d.em,{children:"Link"}),". Events inherit from ",(0,n.jsx)(d.code,{children:"SST::Event"}),". ",(0,n.jsx)(d.code,{children:"StandardMem::Request"})," and derivatives such as ",(0,n.jsx)(d.code,{children:"StandardMem::Read"})," or ",(0,n.jsx)(d.code,{children:"StandardMem::WriteResp"})," are not events in this sense and are exchanged with the StandardMem interface using function calls. MemHierarchy then translates these ",(0,n.jsx)(d.em,{children:"requests"})," to events in the SST sense. To avoid confusion between (SST) events and requests, this guide refers to ",(0,n.jsx)(d.code,{children:"StandardMem::Request"})," derivatives as 'requests', whether the object represent an actual request (e.g., read) or a response. For requests that get translated into a MemHierarchy event, it also gives the event type.\nThis diagram shows the inheritance structure of MemHierarchy events, with base classes to the left."]}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.img,{alt:"MemHierarchy event inheritance",src:s(46336).A+"",width:"2690",height:"591"})}),"\n",(0,n.jsx)(d.h2,{id:"requests-sent-to-memhierarchys-standardinterface",children:"Requests Sent to MemHierarchy's StandardInterface"}),"\n",(0,n.jsxs)(d.p,{children:['These are requests that are sent from a processor or other endpoint into memHierarchy.\nInterpret "request sent to memHierarchy" to mean a request sent to ',(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using StandardMem's ",(0,n.jsx)(d.code,{children:"void send(Request* req)"})," function."]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemread",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/read",children:"StandardMem::Read"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"Read"})," request sent to memHierarchy is interpreted as a read of the specified physical address. All memHierarchy components support reads."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemread-fields",children:"StandardMem::Read fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address where the read should start. MemHierarchy will use this to compute a cache line address for cacheable requests."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be read, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - ",(0,n.jsx)(d.code,{children:"F_NONCACHEABLE"})," is supported. If set, memHierarchy components will forward the request until it reaches the appropriate memory controller. Noncacheable requests do not query caches for potential hits and are not checked against outstanding cacheable requests for conflicts."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines (if cacheable) or multiple distinct memory controller address spaces (if noncacheable). MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests. For performance reasons, MemHierarchy will only run checks to detect violations of these conditions if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["Internally, MemHierarchy translates ",(0,n.jsx)(d.code,{children:"SST::StandardMem::Read"})," to ",(0,n.jsx)(d.code,{children:"SST::MemHierarchy::MemEvent"}),".\nThis table describes the translation of each field. Only relevant MemEvent fields are listed."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::Read"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::Read"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Read::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"MemHierarchy::Command::GetS"})," (Get-Shared)"]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsxs)(d.td,{children:["Set to ",(0,n.jsx)(d.code,{children:"MemEventBase::F_NONCACHEABLE"})," if ",(0,n.jsx)(d.code,{children:"StandardMem::Read::flags == F_NONCACHEABLE"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Read:size"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Read:pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["For cacheable requests, this is calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size. For noncacheable requests, this matches ",(0,n.jsx)(d.code,{children:"addr_"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Read::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Read::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemwrite",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/write",children:"StandardMem::Write"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"Write"})," request sent to memHierarchy is interpreted as a write to the specified address. Writes to caches are performed in the cache after the block is obtained. Noncacheable writes and those sent to memory controllers are performed at the memory controller. Scratchpad writes occur in the scratchpad."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemwrite-fields",children:"StandardMem::Write fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address where the write should start. MemHierarchy will use this to compute a cache line address for cacheable requests."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be written, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"data"})," - a vector of ",(0,n.jsx)(d.code,{children:"uint8_t"})," containing the bytes to be written. If the processor does not use actual data, this field is not required. However, if its size is nonzero, the vector size should match the write's 'size' field."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"posted"})," - if true, the write will not be acknowledged. By default, ",(0,n.jsx)(d.code,{children:"posted"})," is false and memHierarchy will acknowledge every write."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - ",(0,n.jsx)(d.code,{children:"F_NONCACHEABLE"})," is supported. If set, memHierarchy components will forward the request until it reaches the appropriate memory controller. Noncacheable requests do not query caches for potential hits and are not checked against outstanding cacheable requests for conflicts."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-1",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines (if cacheable) or multiple distinct memory controller address spaces (if noncacheable). For performance reasons, MemHierarchy will only run checks to detect violations of these conditions if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n",(0,n.jsxs)(d.li,{children:["The data vector should either be empty or its size should match the size field. Otherwise, both sizes will be used inconsistently. If SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),", mismatched sizes will be detected and produce a warning."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-1",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-1",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::Write"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::Write"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::Write"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Write::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemHierarchy::Command::Write"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsxs)(d.td,{children:["If ",(0,n.jsx)(d.code,{children:"StandardMem::Write::flags == F_NONCACHEABLE"}),",",(0,n.jsx)(d.code,{children:"flags_"})," contains ",(0,n.jsx)(d.code,{children:"MemEventBase::F_NONCACHEABLE"}),". If ",(0,n.jsx)(d.code,{children:"StandardMem::Write::posted == true"}),",",(0,n.jsx)(d.code,{children:"flags_"})," contains ",(0,n.jsx)(d.code,{children:"MemEventBase::F_NORESPONSE"}),"."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"StandardMem::Write:size"})," if ",(0,n.jsx)(d.code,{children:"StandardMem::Write::data"})," is empty, otherwise size of ",(0,n.jsx)(d.code,{children:"StandardMem::Write::data"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Write:pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["For cacheable requests, this is calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size. For noncacheable requests, this matches ",(0,n.jsx)(d.code,{children:"addr_"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"payload_"})}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"StandardMem::Write::data"})," if non-empty, otherwise a vector of size ",(0,n.jsx)(d.code,{children:"StandardMem::Write::size"})," containing 0s."]}),(0,n.jsx)(d.td,{})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Write::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::Write::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemflushaddr",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/flushaddr",children:"StandardMem::FlushAddr"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"FlushAddr"})," request sent to memHierarchy flushes an address from cache and/or directory.\nScratchpads do not handle flush requests and will error if one is received.\nMemory controllers do process flushes to support persistent memory.\nFlushes write dirty (written) data back to memory or a lower level cache\nand can optionally invalidate the flushed address from cache too.\nFlushes cause the line to be written back and/or evicted from all levels of cache.\nFlushing any part of a cache line will flush the entire line."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemflushaddr-fields",children:"StandardMem::FlushAddr fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address where the flush should start. For memory, this can be non-cache line aligned. For caches, a flush of any portion of the cache line will flush the entire line."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to flush, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. Cache flushes to any portion of a cache line will flush the entire line. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"inv"})," - if true, the flush will also invalidate the line from cache. If false, the flush will only write back dirty data."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"depth"})," - NOT YET SUPPORTED. Once supported, this will be the number of memHierarchy levels to apply the flush to. For example, depth=1, will only flush the first cache or memory encountered. Depth=2 will flush the first two. If depth is equal to or greater than the number of components in the hierarchy, the flush will propagate all the way to memory. Currently, flushes propagate all the way to memory."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - No standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-2",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines or multiple distinct memory controller address spaces. For performance reasons, MemHierarchy will only run checks to detect violations of these conditions if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n",(0,n.jsxs)(d.li,{children:["A FlushAddr may not be noncacheable. For performance reasons, MemHierarchy will only detect noncacheable flushes and generate an error if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-2",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-2",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsxs)(d.td,{children:["If ",(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr::inv == true"})," then ",(0,n.jsx)(d.code,{children:"cmd_ = MemHierarchy::Command::FlushLineInv"}),". Otherwise, ",(0,n.jsx)(d.code,{children:"cmd_ = MemHierarchy::Command::FlushLine"}),"."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsx)(d.td,{children:"Empty (not supported)."})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr:size"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr:pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["Calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size. If there is no cache in the system, this matches ",(0,n.jsx)(d.code,{children:"addr_"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushAddr::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemflushcache",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/flushcache",children:"StandardMem::FlushCache"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"FlushCache"})," request sent to memHierarchy flushes the entire cache hierarchy.\nScratchpads do not handle flush requests and will error if one is received.\nMemory controllers do process flushes to support persistent memory.\nFlushes write dirty (written) data back to memory or a lower level cache and invalidate\nthe flushed addresses from the cache."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemflushcache-fields",children:"StandardMem::FlushCache fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"depth"})," - NOT YET SUPPORTED. Once supported, this will be the number of memHierarchy levels to apply the flush to. For example, depth=1, will only flush the first cache or memory encountered. Depth=2 will flush the first two. If depth is equal to or greater than the number of components in the hierarchy, the flush will propagate all the way to memory. Currently, flushes propagate all the way to memory."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - No standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate flushes generated by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-3",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsx)(d.li,{children:"A single thread may not issue multiple concurrent FlushCache requests."}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-3",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-3",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::FlushCache"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::FlushCache"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::FlushCache"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushCache::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:" MemHierarchy::Command::FlushAll"}),"."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsx)(d.td,{children:"Empty (not supported)."})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsx)(d.td,{children:"Empty (not relevant)."})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:"Empty (not relevant)."})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsx)(d.td,{children:"Empty (not relevant)."})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::FlushCache::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:"Empty (not relevant)."})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemloadlink",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/loadlink",children:"StandardMem::LoadLink"})}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.code,{children:"LoadLink"})," is the read part of a conditional read-modify-write atomic operation. See ",(0,n.jsx)(d.code,{children:"StoreConditional"})," below for conditions that cause a LoadLink/StoreConditional (LL/SC) pair to fail. LoadLink and StoreConditional operations are only supported in L1 caches. A LoadLink brings a cache line into cache in exclusive state to ensure a subsequent atomic StoreConditional is a cache hit. Because of the exclusive state, multiple simultaneous LoadLinks to the same line are not supported. LoadLink is tracked on a per-cache-line basis so (1) atomicity is detected at cache line granularity and (2) nested LL/SC pairs, as well as accesses to ",(0,n.jsx)(d.em,{children:"other"})," lines between the LoadLink and StoreConditional are supported."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemloadlink-fields",children:"StandardMem::LoadLink fields:"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address to be read. MemHierarchy will use this to compute a cache line address for atomicity detection."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be read, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. This only controls the number of bytes returned by the read. Atomicity violations will be enforced at cache line granularity. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The L1 uses this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-4",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check for violations if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n",(0,n.jsx)(d.li,{children:"A LoadLink cannot be noncacheable as only L1 caches implement the LL/SC logic. This restriction may be removed in the future."}),"\n",(0,n.jsx)(d.li,{children:"Atomicity violations between LoadLink and StoreConditional are detected at the cache line granularity"}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-4",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-4",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::LoadLink"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::LoadLink"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::LoadLink"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::LoadLink::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"MemHierarchy::Command::GetSX"})," (Get-shared-and-exclusive)"]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemEventBase::F_LLSC"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::LoadLink::size"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::LoadLink:pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["Calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::LoadLink::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::LoadLink::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemstoreconditional",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/storeconditional",children:"StandardMem::StoreConditional"})}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.code,{children:"StoreConditional"})," is the write part of a conditional read-modify-write atomic operation. See ",(0,n.jsx)(d.code,{children:"LoadLink"})," above for the read part. Like LoadLink, StoreConditional is only handled by L1 cache components. A StoreConditional is a conditional write that succeeds only if the write is atomic with respect to a prior LoadLink read. A number of conditions will cause MemHierarchy StoreConditionals to fail following a LoadLink and as described above, atomicity is detected at a cache line granularity. Conditions that cause the write to fail are:"]}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsx)(d.li,{children:"The line has been written by any processor or thread (including the requesting thread) since the most recent LoadLink"}),"\n",(0,n.jsx)(d.li,{children:"The line has been LoadLink'd by any other processor or thread since the most recent LoadLink"}),"\n",(0,n.jsx)(d.li,{children:"The line is evicted, downgraded, flushed, or invalidated from cache after the LoadLink and before the StoreConditional"}),"\n"]}),"\n",(0,n.jsx)(d.p,{children:"LL/SC is prone to livelock. To support forward progress guarantees, L1 caches have a parameterizable window in which non-atomic accesses to a LoadLink'd line can be blocked. The window begins when the LoadLink completes in the L1 and ends as soon as a successful StoreConditional arrives or the window's timeout period has elapsed. A StoreConditional must arrive and begin processing within the LL/SC window to guarantee forward progress. Once the window expires, a subsequent StoreConditional is subject to failure."}),"\n",(0,n.jsx)(d.h4,{id:"standardmemstoreconditional-fields",children:"StandardMem::StoreConditional fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address where the write should start. MemHierarchy will use this to compute a cache line address for atomicity detection."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be written, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"data"})," - a vector of ",(0,n.jsx)(d.code,{children:"uint8_t"})," containing the bytes to be written. If the processor does not use actual data, the vector can be empty. However, if its size is nonzero, the vector size should match the StoreConditional's 'size' field."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-5",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check  to detect violations of these conditions if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n",(0,n.jsx)(d.li,{children:"A StoreConditional cannot be noncacheable as only L1 caches implement the LL/SC logic. This restriction may be removed in the future."}),"\n",(0,n.jsxs)(d.li,{children:["The data vector should either be empty or its size should match the size field. Otherwise, the data vector size will be used. If SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),", mismatched sizes will be detected and produce a warning."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-5",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-5",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemHierarchy::Command::Write"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemEventBase::F_LLSC"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional:size"})," if ",(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::data"})," is empty, otherwise size of ",(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::data"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional:pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["For cacheable requests, this is calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size. For noncacheable requests, this matches ",(0,n.jsx)(d.code,{children:"addr_"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"payload_"})}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::data"})," if non-empty, otherwise a vector of size ",(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::size"})," containing 0s."]}),(0,n.jsx)(d.td,{})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::StoreConditional::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemreadlock",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/readlock",children:"StandardMem::ReadLock"})}),"\n",(0,n.jsxs)(d.p,{children:["Together with ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock"}),", ",(0,n.jsx)(d.code,{children:"StandardMem::ReadLock"})," implements an unconditional read-modify-write. ReadLock and WriteUnlock operations are only supported at L1 caches. A ",(0,n.jsx)(d.code,{children:"ReadLock"})," causes the cache line containing the request address to be brought into the L1 in an exclusive state. The line is then locked, preventing access by any other processor or thread until the L1 receives a WriteUnlock from the locking thread. Multiple ReadLocks can be issued to the same line from a thread. The line will not be unlocked until the same number of WriteUnlocks have been received. Locking is implemented at cache line granularity. ",(0,n.jsx)(d.strong,{children:"Failure to send a WriteUnlock for every ReadLock sent will result in the line being permanently locked."})]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemreadlock-fields",children:"StandardMem::ReadLock fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address to be read. MemHierarchy will use this to compute a cache line address for atomicity enforcement."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be read, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. This only controls the number of bytes returned by the read. Atomicity violations will be enforced at cache line granularity. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The L1 uses this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-6",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check for violations if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n",(0,n.jsx)(d.li,{children:"A ReadLock cannot be noncacheable as only L1 caches implement the ReadLock/WriteUnlock logic. This restriction may be removed in the future."}),"\n",(0,n.jsx)(d.li,{children:"Atomicity enforcement between a ReadLock and WriteUnlock is done at the cache line granularity"}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-6",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-6",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::ReadLock"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::ReadLock"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::ReadLock"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadLock::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"MemHierarchy::Command::GetSX"})," (Get-shared-and-exclusive)"]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemEventBase::F_LOCKED"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadLock::size"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadLock:pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["Calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadLock::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::ReadLock::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemwriteunlock",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/writeunlock",children:"StandardMem::WriteUnlock"})}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.code,{children:"WriteUnlock"})," is the write part of an unconditional read-modify-write atomic operation. See ",(0,n.jsx)(d.code,{children:"ReadLock"})," above for the read part. A ",(0,n.jsx)(d.code,{children:"WriteUnlock"})," ",(0,n.jsx)(d.strong,{children:"must"})," be sent at some point following a ",(0,n.jsx)(d.code,{children:"ReadLock"})," or the line will be permanently locked, preventing eviction, invalidation, and accesses by other threads or processors. Note that it is possible for a ReadLock/WriteUnlock pair to result in deadlock if they are not issued back-to-back. As an example, if a WriteUnlock cannot be processed until an intervening access executes and the intervening access cannot execute because it needs to evict the locked line, deadlock will occur."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemwriteunlock-fields",children:"StandardMem::WriteUnlock fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address where the write should start. MemHierarchy will use this to compute a cache line address for atomicity enforcement."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be written, starting at ",(0,n.jsx)(d.code,{children:"pAddr"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span cache lines or memory controller address spaces. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"data"})," - a vector of ",(0,n.jsx)(d.code,{children:"uint8_t"})," containing the bytes to be written. If the processor does not use actual data, the vector can be empty. However, if its size is nonzero, the vector size should match the WriteUnlock's 'size' field."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-7",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["A request must not span multiple cache lines. For performance reasons, MemHierarchy will only check  to detect violations of these conditions if the SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),"."]}),"\n",(0,n.jsx)(d.li,{children:"A WriteUnlock cannot be noncacheable as only L1 caches implement the ReadLock/WriteUnlock logic. This restriction may be removed in the future."}),"\n",(0,n.jsxs)(d.li,{children:["The data vector should either be empty or its size should match the size field. Otherwise, the data vector size will be used. If SST-Core is compiled with ",(0,n.jsx)(d.code,{children:"--enable-debug"}),", mismatched sizes will be detected and produce a warning."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-7",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteResp"})}),"\n",(0,n.jsx)(d.h4,{id:"memevent-translation-7",children:"MemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemHierarchy::Command::Write"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemEventBase::F_LOCKED"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock:size"})," if ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::data"})," is empty, otherwise size of ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::data"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"addr_"})}),(0,n.jsx)(d.td,{children:"Physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::pAddr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"baseAddr_"})}),(0,n.jsx)(d.td,{children:"Line address"}),(0,n.jsxs)(d.td,{children:["Calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected cache line size."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"payload_"})}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::data"})," if non-empty, otherwise a vector of size ",(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::size"})," containing 0s."]}),(0,n.jsx)(d.td,{})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteUnlock::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemmovedata",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/movedata",children:"StandardMem::MoveData"})}),"\n",(0,n.jsxs)(d.p,{children:["The ",(0,n.jsx)(d.code,{children:"MoveData"})," request is a request to move data between a scratchpad and a memory. In memHierarchy, only scratchpads handle MoveData requests."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemmovedata-fields",children:"StandardMem::MoveData fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pSrc"})," (source physical address) - the physical byte address of the data to be moved"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pDst"})," (destination physical address) - the physical byte address to which the data should be moved"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes to be moved, starting at ",(0,n.jsx)(d.code,{children:"pSrc"}),". MemHierarchy does ",(0,n.jsx)(d.em,{children:"not"})," split requests that span memory controller address spaces so if a request maps to more than one memory controller, the processor should issue multiple ",(0,n.jsx)(d.code,{children:"MoveData"})," requests, one per memory controller. See the Assumptions below."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"posted"})," - if true, the move will not be acknowledged. By default, ",(0,n.jsx)(d.code,{children:"posted"})," is false."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vSrc"})," (source virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vDst"})," (destination virtual address) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. The caches use this ID to disambiguate atomic accesses by different threads."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-8",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsx)(d.li,{children:"The requested data must map to a single source component (scratchpad or memory) and a single destination component. The request may span scratchpad or cache lines."}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-8",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::WriteResp"})}),"\n",(0,n.jsx)(d.h4,{id:"moveevent-translation",children:"MoveEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::MoveData"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::MoveEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"MemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::MoveData"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::MoveData"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsxs)(d.td,{children:[(0,n.jsx)(d.code,{children:"MemHierarchy::Command::Put"})," if source address belongs to a scratchpad otherwise ",(0,n.jsx)(d.code,{children:"MemHierarchy::Command::Get"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"flags_"})}),(0,n.jsx)(d.td,{children:"Flags"}),(0,n.jsxs)(d.td,{children:["If ",(0,n.jsx)(d.code,{children:"StandardMem::MoveData::posted == true"}),",",(0,n.jsx)(d.code,{children:"flags_"})," contains ",(0,n.jsx)(d.code,{children:"MemEventBase::F_NORESPONSE"}),"."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dstAddr_"})}),(0,n.jsx)(d.td,{children:"Destination physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData:pDst"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dstBaseAddr_"})}),(0,n.jsx)(d.td,{children:"Destination line address"}),(0,n.jsxs)(d.td,{children:["Calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected line size."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"srcAddr_"})}),(0,n.jsx)(d.td,{children:"Source physical address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData:pSrc"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"srcBaseAddr_"})}),(0,n.jsx)(d.td,{children:"Source line address"}),(0,n.jsxs)(d.td,{children:["Calculated by ",(0,n.jsx)(d.code,{children:"MemHierarchy::StandardInterface"})," using the detected line size."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"size_"})}),(0,n.jsx)(d.td,{children:"Size"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData:size"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dstVAddr_"})}),(0,n.jsx)(d.td,{children:"Destination virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData:vDst"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"srcVAddr_"})}),(0,n.jsx)(d.td,{children:"Source virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData:vSrc"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"instPtr_"})}),(0,n.jsx)(d.td,{children:"Instruction pointer"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData::iPtr"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"vAddr_"})}),(0,n.jsx)(d.td,{children:"Virtual address"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::MoveData::vAddr"})})]})]})]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemcustomreq",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/customreq",children:"StandardMem::CustomReq"})}),"\n",(0,n.jsxs)(d.p,{children:["The StandardMem API allows extension using custom request data structures derived from ",(0,n.jsx)(d.code,{children:"StandardMem::CustomData"}),". As an example, a use case may be to send memory-mapped I/O (MMIO) requests between a processor and accelerator. The ",(0,n.jsx)(d.code,{children:"StandardMem::CustomReq"})," request wraps the data structure as a request and the ",(0,n.jsx)(d.code,{children:"StandardMem::CustomRsp"})," wraps the data structure as a response. When MemHierarchy receives a ",(0,n.jsx)(d.code,{children:"StandardMem::CustomReq"}),", it copies the wrapped ",(0,n.jsx)(d.code,{children:"CustomData"})," structure into a ",(0,n.jsx)(d.code,{children:"MemHierarchy::CustomMemEvent"}),". MemHierarchy uses the ",(0,n.jsx)(d.code,{children:"StandardMem::CustomData::getRoutingAddress()"})," function to forward the event to its destination and uses ",(0,n.jsx)(d.code,{children:"StandardMem::CustomData::getSize()"})," to account for bandwidth consumed by the event. ",(0,n.jsx)(d.code,{children:"getRoutingAddress()"})," should return a physical address in memHierarchy's known address space. Caches forward custom events based on the routing address, memory controllers can attempt to handle them if an appropriate handler has been registered with the controller, and scratchpads do not currently support custom requests."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemcustomreq-fields",children:"StandardMem::CustomReq fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"data"})," (",(0,n.jsx)(d.code,{children:"CustomData*"}),") - a pointer to an object derived from ",(0,n.jsx)(d.code,{children:"StandardMem::CustomData"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused by memHierarchy. It is appended to memHierarchy events to aid debugging."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - If a processor implements simultaneous multi-thread (SMT), this field should be set to the physical thread ID. While memHierarchy does not currently use this field to process ",(0,n.jsx)(d.code,{children:"CustomReq"})," requests, it may in the future."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"assumptions-9",children:"Assumptions"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:["The custom data structure passed via custom requests must be serializable. SST will use the data structure's serialization method if it needs to serialize the generated ",(0,n.jsx)(d.code,{children:"MemHierarchy::CustomMemEvent"}),"."]}),"\n"]}),"\n",(0,n.jsx)(d.h4,{id:"response-9",children:"Response"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.code,{children:"StandardMem::CustomResp"})}),"\n",(0,n.jsx)(d.h4,{id:"custommemevent-translation",children:"CustomMemEvent Translation"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy translates ",(0,n.jsx)(d.code,{children:"StandardMem::CustomReq"})," requests to ",(0,n.jsx)(d.code,{children:"MemHierarchy::CustomMemEvent"})," events."]}),"\n",(0,n.jsxs)(d.table,{children:[(0,n.jsx)(d.thead,{children:(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.th,{children:"CustomMemEvent Field"}),(0,n.jsx)(d.th,{children:"Description"}),(0,n.jsx)(d.th,{children:"How set"})]})}),(0,n.jsxs)(d.tbody,{children:[(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"eventID_"})}),(0,n.jsx)(d.td,{children:"Unique ID"}),(0,n.jsxs)(d.td,{children:["Generated when event is generated. Does not match the ",(0,n.jsx)(d.code,{children:"StandardMem::CustomReq"})," ID."]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"src_"})}),(0,n.jsx)(d.td,{children:"Event source name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"dst_"})}),(0,n.jsx)(d.td,{children:"Event destination name"}),(0,n.jsx)(d.td,{children:"Updated by memHierarchy each time event is forwarded"})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"rqstr_"})}),(0,n.jsx)(d.td,{children:"Event requestor"}),(0,n.jsxs)(d.td,{children:["The name of the ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," that originated the ",(0,n.jsx)(d.code,{children:"StandardMem::Write"})]})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"tid_"})}),(0,n.jsx)(d.td,{children:"Thread ID"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::CustomReq::tid"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"cmd_"})}),(0,n.jsx)(d.td,{children:"Command"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"MemHierarchy::Command::CustomReq"})})]}),(0,n.jsxs)(d.tr,{children:[(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"data_"})}),(0,n.jsx)(d.td,{children:"Pointer to custom data structure"}),(0,n.jsx)(d.td,{children:(0,n.jsx)(d.code,{children:"StandardMem::CustomReq::data"})})]})]})]}),"\n",(0,n.jsx)(d.h2,{id:"requests-sent-from-memhierarchys-standardinterface",children:"Requests Sent From MemHierarchy's StandardInterface"}),"\n",(0,n.jsxs)(d.p,{children:["The following are ",(0,n.jsx)(d.code,{children:"StandardMem::Request"})," types sent from memHierarchy to a processor via the StandardMem API. Processors should be equipped to handle these. Most are responses to the request types described above as, with the exception of ",(0,n.jsx)(d.code,{children:"posted"})," requests, every ",(0,n.jsx)(d.code,{children:"StandardMem::Request"})," results in a response once the request completes in memHierarchy."]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemreadresp",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/readresp",children:"StandardMem::ReadResp"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"ReadResp"})," is sent in response to every ",(0,n.jsx)(d.code,{children:"Read"}),", ",(0,n.jsx)(d.code,{children:"LoadLink"}),", and ",(0,n.jsx)(d.code,{children:"ReadLock"})," request once the request has completed in the memory system. The response carries the data bytes read starting at the requested ",(0,n.jsx)(d.code,{children:"pAddr"}),"."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemresp-fields",children:"StandardMem::Resp fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"rid"})," (Request ID) - the ID of the matching request for this response"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address of the read data, copied from the matching request"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes read, copied from the matching request"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"data"})," - a vector of ",(0,n.jsx)(d.code,{children:"uint8_t"})," containing the read bytes"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"vAddr"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"iPtr"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"tid"})]}),"\n"]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemwriteresp",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/writeresp",children:"StandardMem::WriteResp"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"WriteResp"})," is sent in response to every ",(0,n.jsx)(d.code,{children:"Write"}),", ",(0,n.jsx)(d.code,{children:"StoreConditional"}),", and ",(0,n.jsx)(d.code,{children:"WriteUnlock"})," request once the request has completed in the memory system unless the write was posted. If a ",(0,n.jsx)(d.code,{children:"StoreConditional"})," failed and the write was not completed, the ",(0,n.jsx)(d.code,{children:"WriteResp::flags"})," contain the ",(0,n.jsx)(d.code,{children:"StandardMem::F_FAIL"})," flag. This can queried using ",(0,n.jsx)(d.code,{children:"StandardMem::WriteResp::getSuccess()"})," or ",(0,n.jsx)(d.code,{children:"StandardMem::WriteResp::getFail()"}),"."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemwriteresp-fields",children:"StandardMem::WriteResp fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"rid"})," (Request ID) - the ID of the matching request for this response"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address of the written data, copied from the matching request"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes that were to be written, copied from the matching request"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - if the matching was request was ",(0,n.jsx)(d.code,{children:"StoreConditional"})," and failed, the ",(0,n.jsx)(d.code,{children:"F_FAIL"})," flag will be set. Otherwise, the request was either unconditional (",(0,n.jsx)(d.code,{children:"Write"}),", ",(0,n.jsx)(d.code,{children:"WriteUnlock"}),"), or conditional but succeeded."]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"vAddr"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"iPtr"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"tid"})]}),"\n"]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemflushresp",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/flushresp",children:"StandardMem::FlushResp"})}),"\n",(0,n.jsxs)(d.p,{children:["A ",(0,n.jsx)(d.code,{children:"FlushResp"})," is sent in response to every ",(0,n.jsx)(d.code,{children:"FlushReq"})," once the flush has completed. MemHierarchy can, in rare cases, fail to flush - this occurs if a Flush encounters a locked line (due to a ",(0,n.jsx)(d.code,{children:"ReadLock"})," or during a ",(0,n.jsx)(d.code,{children:"LoadLink"})," lockout window). If the flush fails, the ",(0,n.jsx)(d.code,{children:"F_FAIL"})," flag will be set on the ",(0,n.jsx)(d.code,{children:"FlushResp"}),". ",(0,n.jsx)(d.code,{children:"StandardMem::FlushResp::getFail()"})," or ",(0,n.jsx)(d.code,{children:"StandardMem::FlushResp::getSuccess()"})," can be used to check the flag."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemflushresp-fields",children:"StandardMem::FlushResp fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"rid"})," (Request ID) - the ID of the matching request for this response"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical byte address of the written data, copied from the matching request"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes that were to be written, copied from the matching request"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - if the flush request failed, the ",(0,n.jsx)(d.code,{children:"F_FAIL"})," flag will be set"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"vAddr"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr (instruction pointer) - copied from the matching request's "}),"iPtr`"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"tid"})]}),"\n"]}),"\n",(0,n.jsx)(d.h3,{id:"standardmeminvnotify",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/invnotify",children:"StandardMem::InvNotify"})}),"\n",(0,n.jsxs)(d.p,{children:["Some processor atomic semantics require them to snoop L1 cache invalidations. To support that, the MemHierarchy L1 can be configured to notify the processor when a line is invalidated. The notification is sent through the StandardMem interface as a ",(0,n.jsx)(d.code,{children:"StandardMem::InvNotify"}),". No response to this notification is needed."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmeminvnotify-fields",children:"StandardMem::InvNotify fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"pAddr"})," (physical address) - the physical address of the line that was evicted"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"size"})," - number of bytes evicted (typically, the cache line size)"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"vAddr"})," (virtual address) - unused"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - unused"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - unused"]}),"\n"]}),"\n",(0,n.jsx)(d.h3,{id:"standardmemcustomresp",children:(0,n.jsx)(d.a,{href:"/sst-docs/docs/core/iface/StandardMem/req/customreq",children:"StandardMem::CustomResp"})}),"\n",(0,n.jsxs)(d.p,{children:["Custom requests can control whether a response is returned using the ",(0,n.jsx)(d.code,{children:"StandardMem::CustomData::needsResponse()"})," function. If a response is needed, the response arrives as a ",(0,n.jsx)(d.code,{children:"StandardMem::CustomResp"}),". Like ",(0,n.jsx)(d.code,{children:"CustomReq"}),", ",(0,n.jsx)(d.code,{children:"CustomResp"})," wraps an object derived from ",(0,n.jsx)(d.code,{children:"StandardMem::CustomData"})," which contains in the custom response data fields."]}),"\n",(0,n.jsx)(d.h4,{id:"standardmemcustomresp-fields",children:"StandardMem::CustomResp fields"}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"rid"})," (Request ID) - the ID of the matching request for this response"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"data"})," (",(0,n.jsx)(d.code,{children:"StandardMem::CustomData*"}),") - pointer to the custom data structure being returned by the response"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"flags"})," - no standard flags supported"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"iPtr"})," (instruction pointer) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"iPtr"})]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"tid"})," (thread ID) - copied from the matching request's ",(0,n.jsx)(d.code,{children:"tid"})]}),"\n"]}),"\n",(0,n.jsx)(d.h2,{id:"other-implementation-notes",children:"Other Implementation Notes"}),"\n",(0,n.jsx)(d.h3,{id:"tracing",children:"Tracing"}),"\n",(0,n.jsxs)(d.p,{children:["The ",(0,n.jsx)(d.code,{children:"StandardMem"})," interface has an ",(0,n.jsx)(d.code,{children:"F_TRACE"})," flag that can be put on requests. The intent is for memHierarchy to eventually propagate and query that flag and generate trace output for events with the flag set. As of now, memHierarchy ignores the flag."]}),"\n",(0,n.jsx)(d.h3,{id:"polling",children:"Polling"}),"\n",(0,n.jsxs)(d.p,{children:["The ",(0,n.jsx)(d.code,{children:"StandardMem"})," interface supports polling received requests using the ",(0,n.jsx)(d.code,{children:"poll()"})," function. The memHierarchy implementation does not support polling. Instead, the component loading ",(0,n.jsx)(d.code,{children:"memHierarchy.standardInterface"})," must register a callback handler with the interface to handle received requests."]}),"\n",(0,n.jsx)(d.h3,{id:"flags",children:"Flags"}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.code,{children:"StandardMem"})," defines some standard flags and also reserves space in the ",(0,n.jsx)(d.code,{children:"flags"})," bit vector for custom flags. Not all standard flags are supported by memHierarchy for all request types, but memHierarchy will copy and propagate any custom flags through its events."]}),"\n",(0,n.jsxs)(d.h3,{id:"requests-exchanged-during-ssts-init-phase",children:["Requests exchanged during SST's ",(0,n.jsx)(d.code,{children:"init()"})," phase"]}),"\n",(0,n.jsxs)(d.p,{children:["Prior to simulation start, SST components can exchange events during ",(0,n.jsx)(d.code,{children:"init()"}),". MemHierarchy supports initializing memory contents during this phase using the ",(0,n.jsx)(d.code,{children:"StandardMem::sendUntimedData()"})," function. Processors issue writes which will be forwarded to the appropriate memory controller. During ",(0,n.jsx)(d.code,{children:"init()"})," only, data can be written at granularities larger than a cache line. A single write request may not map to multiple memory controllers however. The caches/scratchpads do not operate during this phase and only forward requests. The interface does not (yet) support receiving messages during ",(0,n.jsx)(d.code,{children:"init()"}),", so, for example, processors cannot exchange MMIO requests."]}),"\n",(0,n.jsx)(d.h3,{id:"scratchpad-addressing",children:"Scratchpad addressing"}),"\n",(0,n.jsx)(d.p,{children:"When the memHierarchy scratchpad was originally written, scratchpads were assumed to be private to a processor with an address space of 0 to sizeof(scratchpad) and memory addresses mapped above that. MemHierarchy relies on this assumption to determine whether a StandardMem::MoveData request is converted to a MemHierarchy Get (copy data from memory to scratch) or Put (copy data from scratch to memory). We are looking into changing this assumption."}),"\n",(0,n.jsx)(d.h3,{id:"mmio",children:"MMIO"}),"\n",(0,n.jsxs)(d.p,{children:["MemHierarchy supports memory-mapped I/O. Processors/accelerators/etc. should use ",(0,n.jsx)(d.code,{children:"StandardMem::setMemoryMappedAddressRegion()"})," to set a contiguous range of addresses that map to the endpoint. This must be called prior to SST's ",(0,n.jsx)(d.code,{children:"init()"})," phase. Accesses to MMIO addresses are always noncacheable."]})]})}function o(e={}){const{wrapper:d}={...(0,t.R)(),...e.components};return d?(0,n.jsx)(d,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,d,s)=>{s.d(d,{R:()=>i,x:()=>c});var r=s(96540);const n={},t=r.createContext(n);function i(e){const d=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(d):{...d,...e}}),[d,e])}function c(e){let d;return d=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(t.Provider,{value:d},e.children)}},46336:(e,d,s)=>{s.d(d,{A:()=>r});const r=s.p+"assets/images/memh_events-fa1306d4e2d6602e8d3362e5267cb6e3.png"},60891:(e,d,s)=>{s.d(d,{A:()=>r});const r=s.p+"assets/images/stdmem_structure-89de4aa621dca1299338478de7b1efca.png"}}]);