"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[45255],{8606:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"core/statoutput/getFieldInfoArray","title":"getFieldInfoArray","description":"Each StatisticFieldsOutput contains a std::vector of the fields that the statistics registered to it contain. For example, if all registered statistics are AcculatorStatistics and tracking values of type uint32t, then the array would contain entries for sum(u32), sumSq(32), count(u32), min(u32), max(u32). If some statistics were tracking float or int64t, then the fields array would also contain entries for those types (e.g., sum(float)). Likewise, if any statistics were being collected as histograms, each field of the histogram (bin size, bin width, start index, etc.) would have an entry in this array.","source":"@site/../docs/core/statoutput/getFieldInfoArray.md","sourceDirName":"core/statoutput","slug":"/core/statoutput/getFieldInfoArray","permalink":"/sst-docs/docs/core/statoutput/getFieldInfoArray","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/statoutput/getFieldInfoArray.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1747692370000,"frontMatter":{"title":"getFieldInfoArray"},"sidebar":"core","previous":{"title":"getCurrentSimCycle","permalink":"/sst-docs/docs/core/statoutput/getCurrentSimCycle"},"next":{"title":"getFieldTypeShortName","permalink":"/sst-docs/docs/core/statoutput/getFieldTypeShortName"}}');var n=i(74848),r=i(28453);const a={title:"getFieldInfoArray"},o=void 0,c={},d=[{value:"Parameters",id:"parameters",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function l(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"// FieldInfoArray_t = std::vector<StatisticFieldInfo*>\nFieldInfoArray_t& getFieldInfoArray() const;\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Each StatisticFieldsOutput contains a ",(0,n.jsx)(t.code,{children:"std::vector"})," of the fields that the statistics registered to it contain. For example, if all registered statistics are ",(0,n.jsx)(t.code,{children:"AcculatorStatistic"}),"s and tracking values of type ",(0,n.jsx)(t.code,{children:"uint32_t"}),", then the array would contain entries for ",(0,n.jsx)(t.code,{children:"sum(u32), sumSq(32), count(u32), min(u32), max(u32)"}),". If some statistics were tracking ",(0,n.jsx)(t.code,{children:"float"})," or ",(0,n.jsx)(t.code,{children:"int64_t"}),", then the fields array would also contain entries for those types (e.g., ",(0,n.jsx)(t.code,{children:"sum(float)"}),"). Likewise, if any statistics were being collected as histograms, each field of the histogram (bin size, bin width, start index, etc.) would have an entry in this array."]}),"\n",(0,n.jsxs)(t.p,{children:["Each entry in ",(0,n.jsx)(t.code,{children:"FieldInfoArray_t"})," is a pointer to a ",(0,n.jsx)(t.code,{children:"StatisticFieldInfo"})," object and can be read using the following functions."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"const std::string& getStatName()"}),': Returns the statistic name (e.g., "Accumulator" or "Histogram") associated with this field.']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"const std::string& getFieldName()"}),': Returns the name of the field such as "Sum", "Count", "BinWidth", etc.']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"fieldType_t getFieldType()"}),": Returns an indicator of the data type being tracked by this field. Use this in conjunction with the two functions below to get a string representation of the type.","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"static const char* getFieldTypeShortName(fieldType_t type)"}),": Returns a short version of the type name, such as ",(0,n.jsx)(t.code,{children:'"u32"'})," for ",(0,n.jsx)(t.code,{children:"uint32_t"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"static const char* getFieldTypeFullName(fieldType_t type)"})," : Returns the full type name such as ",(0,n.jsx)(t.code,{children:'"float"'})," or ",(0,n.jsx)(t.code,{children:'"uint32_t"'}),"."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"std::string getFieldUniqueName()"}),": Returns the field name and type separated by a ",(0,n.jsx)(t.code,{children:"."}),". For example: ",(0,n.jsx)(t.code,{children:'"count.0"'}),' where "0" is the field type (',(0,n.jsx)(t.code,{children:"fieldType_t = uint32_t"}),") associated with the field."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"returns"})," (FieldInfoArray_t) A reference to the FieldInfoArray for the statistics registered to this output object"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:'// Print a list of fields with their types registered to this stat output\n//highlight-next-line\nFieldInfoArray_t::iterator it_v = getFieldInfoArray().begin();\n//highlight-next-line\nwhile ( it_v != getFieldInfoArray().end() ) {\n    StatisticFieldInfo* statField    = *it_v;\n    printf("%s.%s", statField->getFieldName(), StatisticFieldInfo::getFieldTypeShortName(statField->getFieldType()));\n\n    it_v++;\n    if ( it_v != getFieldInfoArray().end() ) {\n        printf(", ");\n    } else {\n        printf("\\n");\n    }\n}\n'})}),"\n",(0,n.jsx)(t.h2,{id:"header",children:"Header"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-cpp",children:"#include <sst/core/statapi/statoutput.h>\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var s=i(96540);const n={},r=s.createContext(n);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);