"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[65629],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}},74600:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"core/portmodule/class","title":"PortModule","description":"The PortModule API has not been finalized and may be changed without notice in subsequent versions of SST.","source":"@site/../docs/core/portmodule/class.md","sourceDirName":"core/portmodule","slug":"/core/portmodule/class","permalink":"/sst-docs/docs/core/portmodule/class","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/portmodule/class.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1762293106000,"frontMatter":{"title":"PortModule"},"sidebar":"core","previous":{"title":"print_all_params","permalink":"/sst-docs/docs/core/params/print_all_params"},"next":{"title":"constructor","permalink":"/sst-docs/docs/core/portmodule/constructor"}}');var r=t(74848),s=t(28453);const i={title:"PortModule"},d=void 0,l={},c=[{value:"PortModule names",id:"portmodule-names",level:2},{value:"PortModule Implementation",id:"portmodule-implementation",level:2},{value:"Access to SST-Core APIs",id:"access-to-sst-core-apis",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"API Not Final",type:"info",children:(0,r.jsx)(n.p,{children:"The PortModule API has not been finalized and may be changed without notice in subsequent versions of SST."})}),"\n",(0,r.jsxs)(n.p,{children:["PortModules can be attached to the send and/or receive side of a port. The module intercepts the event stream through that port and can monitor, modify, replace, and delete events. A PortModule is always co-located with the Component whose port it is attached to. PortModules have limited access to SST APIs. For more complex needs, consider using a ",(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/component/subcomponent/class",children:"SubComponent"})," instead."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Attaching a PortModule to a port on the send side (i.e., to monitor outgoing traffic) has known performance issues. We recommend attaching to the receive side (input port) when possible or using a SubComponent instead to avoid perturbing the ",(0,r.jsx)(n.code,{children:"SST::Link"})," send path."]})}),"\n",(0,r.jsx)(n.h2,{id:"portmodule-names",children:"PortModule names"}),"\n",(0,r.jsx)(n.p,{children:'As with SubComponents, PortModules are unnamed. When needed (such as for statistic output), a PortModule will be assigned a name that indicates its location: "component_name.port_name.module_index".'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'"component_name" : Name of the component to which the PortModule is attached'}),"\n",(0,r.jsx)(n.li,{children:'"port_name" : Name of the port that the PortModule was attached to'}),"\n",(0,r.jsx)(n.li,{children:'"port_index" : A vector index indicating which PortModule on the attached port corresponds to this PortModule. If only one PortModule is attached to a port then the index will be 0.'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"portmodule-implementation",children:"PortModule Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["PortModules inherit the following functions from the base PortModule and ",(0,r.jsx)(n.em,{children:"must"})," override them."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/constructor",children:"Constructor"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/destructor",children:"Destructor"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/eventSent",children:(0,r.jsx)(n.code,{children:"eventSent"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/interceptHandler",children:(0,r.jsx)(n.code,{children:"interceptHandler"})})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"PortModules inherit the following functions from the base PortModule and should override them as needed."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/installOnReceive",children:(0,r.jsx)(n.code,{children:"installOnReceive"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/installOnSend",children:(0,r.jsx)(n.code,{children:"installOnSend"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/serialize_order",children:(0,r.jsx)(n.code,{children:"serialize_order"})})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'PortModules share base APIs with other tools that attach to various places ("AttachPoints") in SST. However, PortModules cover a narrower use case (tools that attach only to ports) and therefore PortModules can override these inherited functions as well but are unlikely to need to do so.'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/registerHandlerIntercept",children:(0,r.jsx)(n.code,{children:"registerHandlerIntercept"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/registerLinkAttachTool",children:(0,r.jsx)(n.code,{children:"registerLinkAttachTool"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/serializeEventAttachPointKey",children:(0,r.jsx)(n.code,{children:"serializeEventAttachPointKey"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/serializeHandlerInterceptPointKey",children:(0,r.jsx)(n.code,{children:"serializeHandlerInterceptPointKey"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"access-to-sst-core-apis",children:"Access to SST-Core APIs"}),"\n",(0,r.jsx)(n.p,{children:"PortModules also have the following functions available to access SST-Core state."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCoreTimeBase",children:(0,r.jsx)(n.code,{children:"getCoreTimeBase"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimCycle",children:(0,r.jsx)(n.code,{children:"getCurrentSimCycle"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentPriority",children:(0,r.jsx)(n.code,{children:"getCurrentPriority"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getElapsedSimTime",children:(0,r.jsx)(n.code,{children:"getElapsedSimTime"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getSimulationOutput",children:(0,r.jsx)(n.code,{children:"getSimulationOutput"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/fatal",children:(0,r.jsx)(n.code,{children:"fatal"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/fatal",children:(0,r.jsx)(n.code,{children:"sst_assert"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getName",children:(0,r.jsx)(n.code,{children:"getName"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTime",children:(0,r.jsx)(n.code,{children:"getCurrentSimTime"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTimeNano",children:(0,r.jsx)(n.code,{children:"getCurrentSimTimeNano"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTimeMicro",children:(0,r.jsx)(n.code,{children:"getCurrentSimTimeMicro"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/getCurrentSimTimeMilli",children:(0,r.jsx)(n.code,{children:"getCurrentSimTimeMilli"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/sst-docs/docs/core/portmodule/registerStatistic",children:(0,r.jsx)(n.code,{children:"registerStatistic"})})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Example PortModule that randomly drops events; header file"',children:'class DropEvent : public SST::PortModule\n{\npublic:\n    SST_ELI_REGISTER_PORTMODULE(\n        DropEvent,                      // Class name\n        "example",                      // Library name, the \'lib\' in SST\'s lib.name format\n        "drop",                         // Name used to refer to this port module, the \'name\' in SST\'s lib.name format\n        SST_ELI_ELEMENT_VERSION(1,0,0), // A version number\n        "Randomly drops events")        // Description\n\n    SST_ELI_DOCUMENT_PARAMS(\n        { "drop_probability", "Set the probability of a dropped event between 0\\% and 100\\%", "10",},\n        { "seed", "Seed to use for random number generation", "1" }\n    )\n\n    DropEvent(Params& params);\n    ~DropEvent();\n\n    void eventSend(uintptr_t key, Event*& ev) override;\n    void interceptHandler(uintptr_t key, Event*& ev, bool& cancel) override;\n\n    bool installOnReceive() override { return true; }\n    bool installOnSend() override { return false; }\n\nprivate:\n    SST::RNG::MersenneRNG * rng;\n    uint32_t probability;\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",metastring:'title="Example PortModule that randomly drops events; implementation file"',children:'#include "drop_event.h"\n\nDropEvent::DropEvent(Params& params) : PortModule()\n{\n    rng = new SST::RNG::MersenneRNG(params.find<unsigned>("seed", 1));\n    probability = params.find<uint32_t>("drop_probability", 10);\n}\n\n~DropEvent::DropEvent() \n{\n    delete rng;\n}\n\nvoid DropEvent::eventSent(uintptr_t key, Event*& ev)\n{\n    uint32_t prob = (rng->getNextUInt32() % 100);\n    if (prob <= probability) {\n        delete ev;\n        ev = nullptr;\n    }\n}\n\nvoid DropEvent::interceptHandler(uintptr_t key, Event*& ev, bool& cancel)\n{\n    uint32_t prob = (rng->getNextUInt32() % 100);\n    if (prob <= probability) {\n        delete ev;\n        ev = nullptr;\n        cancel = true;\n    } else {\n        cancel = false;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/portModule.h>\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);