"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[74864],{27940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"guides/concepts/elementtypes","title":"Types of SST elements","description":"In SST, Elements are individual building blocks that make up not only simulated systems, but can also add functionality to SST-Core. Elements are dynamically loaded at runtime for highly customized simulations.","source":"@site/../docs/guides/concepts/elementtypes.mdx","sourceDirName":"guides/concepts","slug":"/guides/concepts/elementtypes","permalink":"/sst-docs/docs/guides/concepts/elementtypes","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/guides/concepts/elementtypes.mdx","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1756404213000,"frontMatter":{"title":"Types of SST elements"},"sidebar":"guides","previous":{"title":"Concepts","permalink":"/sst-docs/docs/category/concepts"},"next":{"title":"Simulation lifecycle","permalink":"/sst-docs/docs/guides/concepts/lifecycle"}}');var i=n(74848),s=n(28453);const a={title:"Types of SST elements"},l=void 0,r={},c=[{value:"Simulation Elements",id:"simulation-elements",level:2},{value:"Component",id:"component",level:3},{value:"SubComponent",id:"subcomponent",level:3},{value:"ComponentExtension",id:"componentextension",level:3},{value:"Module",id:"module",level:3},{value:"PortModule",id:"portmodule",level:3},{value:"Deciding which element type to use",id:"deciding-which-element-type-to-use",level:3},{value:"SST-Core Elements",id:"sst-core-elements",level:2},{value:"Partitioner",id:"partitioner",level:3},{value:"Statistic",id:"statistic",level:3},{value:"StatisticOutput",id:"statisticoutput",level:3},{value:"ProfileTool",id:"profiletool",level:3},{value:"RealTimeAction",id:"realtimeaction",level:3},{value:"InteractiveConsole",id:"interactiveconsole",level:3},{value:"Creating custom elements",id:"creating-custom-elements",level:2},{value:"Using custom elements",id:"using-custom-elements",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"In SST, Elements are individual building blocks that make up not only simulated systems, but can also add functionality to SST-Core. Elements are dynamically loaded at runtime for highly customized simulations."}),"\n",(0,i.jsx)(t.h2,{id:"simulation-elements",children:"Simulation Elements"}),"\n",(0,i.jsx)(t.p,{children:"These are types of Elements typically used to model systems in simulation."}),"\n",(0,i.jsx)(t.h3,{id:"component",children:(0,i.jsx)(t.a,{href:"/sst-docs/docs/core/component/component/class",children:"Component"})}),"\n",(0,i.jsxs)(t.p,{children:["The fundamental simulation element is the ",(0,i.jsx)(t.em,{children:"Component"}),". A Component is a model of a particular piece of the simulated system. Parallel simulations partition the simulated system at the Component level. For example, a Component might model a router, cache, or processor core. Components must only interact with other Components via SST Events. Internally, a Component is for the most part, free to operate as it chooses."]}),"\n",(0,i.jsx)(t.h3,{id:"subcomponent",children:(0,i.jsx)(t.a,{href:"/sst-docs/docs/core/component/subcomponent/class",children:"SubComponent"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"SubComponents"})," can be dynamically loaded into a Component or another SubComponent to provide modular flexibility within Components. For example, a router Component might load a SubComponent to manage arbitration. Other than always belonging to a Component, SubComponents are similar to Components with a nearly identical API (e.g., support for Clocks, Statistics, etc.). Because SubComponents are part of a Component, they may interact with the Component and other SubComponents in the same ",(0,i.jsx)(t.em,{children:"Component tree"})," via function calls and shared state."]}),"\n",(0,i.jsx)(t.p,{children:"SST supports two flavors of SubComponent: user-defined and anonymous. User-defined SubComponents are declared explicitly in an SST input file, similar to the way Components are. As a result, user-defined SubComponents can provide their own ports and connect to other components via SST Links. Anonymous SubComponents on the other hand, are loaded internally by a (Sub)Component. Any user-level control of an anonymous SubComponent is done through parameters to the loading component. Anonymous SubComponents are not visible to the SST graph builder and so they cannot have their own ports into the SST graph. They can however, use ports that belong to their parent component."}),"\n",(0,i.jsx)(t.h3,{id:"componentextension",children:(0,i.jsx)(t.a,{href:"/sst-docs/docs/core/component/componentext/class",children:"ComponentExtension"})}),"\n",(0,i.jsx)(t.p,{children:"A ComponentExtension is loaded into a Component or SubComponent. It is used to statically break up the functionality of a Component into multiple classes while allowing all classes equal access to the SST Component APIs. It is not necessary for every class belonging to a Component to be a ComponentExtension, however it can be useful if the class needs access to Statistics, register its own Clocks, etc. Thus, in contrast to SubComponents which provide runtime flexibility, ComponentExtensions support code organization. For example, if your Component is a multi-core CPU, it may be more maintainable to model each individual core in a ComponentExtension. Each core may load its own clock, manage its own events, etc., as part of the larger multi-core Component."}),"\n",(0,i.jsx)(t.h3,{id:"module",children:(0,i.jsx)(t.a,{href:"/sst-docs/docs/core/module/class",children:"Module"})}),"\n",(0,i.jsx)(t.p,{children:"A Module is similar to a SubComponent but it has almost no available SST API. Think of it as a very lightweight subcomponent. Modules are used for small pieces of functionality such as providing a mechanism for dynamically loading a hashing algorithm. They cannot register Clocks, send Events, query SST for simulated time, register Statistics, etc."}),"\n",(0,i.jsx)(t.h3,{id:"portmodule",children:(0,i.jsx)(t.a,{href:"/sst-docs/docs/core/portmodule/class",children:"PortModule"})}),"\n",(0,i.jsx)(t.p,{children:"A PortModule is like a SubComponent but instead of loading into a Component, it loads onto a port. The PortModule is invoked automatically whenever an SST Event is sent or received through a port. PortModules can monitor, modify, and even delete Events."}),"\n",(0,i.jsx)(t.h3,{id:"deciding-which-element-type-to-use",children:"Deciding which element type to use"}),"\n",(0,i.jsx)(t.p,{children:"Deciding how to map a simulated system into a graph of Components, SubComponents, and other elements requires considering the performance tradeoffs of each and deciding what makes sense for the system to be simulated. Consider the following:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Partitioning parallel simulations is done at Component granularity."}),"\n",(0,i.jsx)(t.li,{children:"Components may only interact with other Components by sending Events."}),"\n",(0,i.jsx)(t.li,{children:"SubComponents have almost the same memory overhead as a Component. If SST APIs are not needed and memory footprint is a concern, consider using a Module."}),"\n",(0,i.jsx)(t.li,{children:"Loading a PortModule onto the send side of a link (i.e., monitoring outgoing Events) causes known performance degradations. Consider monitoring Events from the receive side of a link or from within a (Sub)Component instead."}),"\n",(0,i.jsx)(t.li,{children:"If Components are too large, SST may not be able to sufficiently parallelize. If Components are too small, the overhead of interacting via Events may become too high."}),"\n",(0,i.jsxs)(t.li,{children:["Events sent between Component trees ",(0,i.jsx)(t.em,{children:"always incur simulated latency"}),". Zero-latency exchanges can only be done within a Component tree."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"sst-core-elements",children:"SST-Core Elements"}),"\n",(0,i.jsxs)(t.p,{children:["SST-Core also uses Elements to enable runtime flexibility and extensibility for certain functionality. While SST-Core provides a set of default elements for each type, Element libraries can augment these by providing their own and having SST-Core load them at runtime. The set of available SST-Core elements provided with SST can be viewed using ",(0,i.jsx)(t.code,{children:"$sst-info sst"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"partitioner",children:"Partitioner"}),"\n",(0,i.jsx)(t.p,{children:"Partitioners are used by SST to partition the simulation graph into ranks and/or threads. Built-in partitioners include linear, round-robin, serial, a simple partitioning scheme that cuts on high-latency links, and a self-partitioner which allows the SST input file to specify partitioning."}),"\n",(0,i.jsx)(t.h3,{id:"statistic",children:"Statistic"}),"\n",(0,i.jsx)(t.p,{children:"A Statistic object collects information given to it. Built-in types include accumulator, unique count, and histogram. New types can be registered to allow custom data collection."}),"\n",(0,i.jsx)(t.h3,{id:"statisticoutput",children:"StatisticOutput"}),"\n",(0,i.jsx)(t.p,{children:"A StatisticOutput object iterates over the list of statistics registered to it and generates an output. Built-in output types include text file, console/stdout, CSV, JSON, and HDF5. Additional StatisticOutput types can be registered to provide statistics in the preferred format."}),"\n",(0,i.jsx)(t.h3,{id:"profiletool",children:"ProfileTool"}),"\n",(0,i.jsxs)(t.p,{children:['SST has a generic "AttachPoint" concept which is a place in SST-Core where certain types of elements may attach for the purpose of profiling or modifying simulation. A ProfileTool is one such element type (along with PortModules and WatchPoints) and it attaches to ',(0,i.jsx)(t.em,{children:"ProfilePoints"})," or AttachPoints designed for profiling. ProfilePoints for clock handlers, event handlers, and sync operations are available and Components may also expose their own. A ProfileTool attaches to one of these points and is called each time the handler or sync operation is executed. A ProfileTool could measure time spent in SST synchronization for example, or count how many times a handler is invoked."]}),"\n",(0,i.jsx)(t.h3,{id:"realtimeaction",children:"RealTimeAction"}),"\n",(0,i.jsxs)(t.p,{children:["RealTimeActions are actions that can be attached to signal handlers as well as invoked at a regular real (wall) time interval. Elements can provide custom RealTimeActions to do things like introspect simulation state and trigger checkpoints. See ",(0,i.jsx)(t.a,{href:"/sst-docs/docs/guides/features/signal",children:"Signal Handling"})," for more information."]}),"\n",(0,i.jsx)(t.h3,{id:"interactiveconsole",children:"InteractiveConsole"}),"\n",(0,i.jsx)(t.p,{children:'An InteractiveConsole is an API allowing an external "console" to stop simulation and introspect state. Consoles register with WatchPoints which are specific places in an SST simulation where they are to be triggered. A WatchPoint is a variable together with a condition for triggering entry into an InteractiveConsole. The InteractiveConsole API is new and evolving with an intention to stabilize it before SST 16.0.'}),"\n",(0,i.jsx)(t.h2,{id:"creating-custom-elements",children:"Creating custom elements"}),"\n",(0,i.jsxs)(t.p,{children:["To create a custom element, define a class that inherits from the element API and declare the appropriate ",(0,i.jsx)(t.a,{href:"/sst-docs/docs/core/eli/overview",children:"ELI (Element Library Info) macros"}),". Compile your element(s) into a dynamic library and register the library with SST-core using ",(0,i.jsx)(t.a,{href:"/sst-docs/docs/tools/commandLine/sst-register",children:(0,i.jsx)(t.code,{children:"sst-register"})}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"using-custom-elements",children:"Using custom elements"}),"\n",(0,i.jsxs)(t.p,{children:["Anywhere an SST element type is used (",(0,i.jsx)(t.code,{children:"lib.elementname"}),"), a custom type can be substituted. For example, SST input/configuration files often contain Components, SubComponents, Statistics, PortModules, and StatisticOutputs. Components directly load anonymous SubComponents and Modules by type. And several SST command line options accept an element type to do things like attach ProfileTools, InteractiveConsoles, and RealTimeActions."]})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var o=n(96540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);