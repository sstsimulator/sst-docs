"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6328],{26470:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>o,frontMatter:()=>a,metadata:()=>i,toc:()=>r});var t=n(85893),l=n(11151);const a={title:"StandardMem::Request"},c=void 0,i={id:"core/iface/StandardMem/req/class",title:"StandardMem::Request",description:"The Request class is the base class for all requests and responses that get sent through the StandardMem interface. Several basic request types are defined in the interface, including reads, writes, and flushes. In addition, a CustomReq and CustomResp type are provided. Implementations can use these to wrap custom request and response types that can also be passed through the interface alongside the basic request types.",source:"@site/../docs/core/iface/StandardMem/req/class.md",sourceDirName:"core/iface/StandardMem/req",slug:"/core/iface/StandardMem/req/class",permalink:"/sst-docs/docs/core/iface/StandardMem/req/class",draft:!1,unlisted:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/StandardMem/req/class.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1695940750,formattedLastUpdatedAt:"Sep 28, 2023",frontMatter:{title:"StandardMem::Request"},sidebar:"core",previous:{title:"setMemoryMappedAddressRegion",permalink:"/sst-docs/docs/core/iface/StandardMem/setMemoryMappedAddressRegion"},next:{title:"Read",permalink:"/sst-docs/docs/core/iface/StandardMem/req/read"}},d={},r=[{value:"Types",id:"types",level:2},{value:"Request handling",id:"request-handling",level:2},{value:"Functions",id:"functions",level:2},{value:"getID",id:"getid",level:3},{value:"makeResponse",id:"makeresponse",level:3},{value:"needsResponse",id:"needsresponse",level:3},{value:"convert",id:"convert",level:3},{value:"handle",id:"handle",level:3},{value:"getString",id:"getstring",level:3},{value:"setNoncacheable",id:"setnoncacheable",level:3},{value:"unsetNoncacheable",id:"unsetnoncacheable",level:3},{value:"getNoncacheable",id:"getnoncacheable",level:3},{value:"setSuccess",id:"setsuccess",level:3},{value:"unsetSuccess",id:"unsetsuccess",level:3},{value:"getSuccess",id:"getsuccess",level:3},{value:"setFail",id:"setfail",level:3},{value:"unsetFail",id:"unsetfail",level:3},{value:"getFail",id:"getfail",level:3},{value:"setTrace",id:"settrace",level:3},{value:"unsetTrace",id:"unsettrace",level:3},{value:"getTrace",id:"gettrace",level:3},{value:"setFlag",id:"setflag",level:3},{value:"unsetFlag",id:"unsetflag",level:3},{value:"getFlag",id:"getflag",level:3},{value:"clearAllFlags",id:"clearallflags",level:3},{value:"getAllFlags",id:"getallflags",level:3},{value:"getFlagString",id:"getflagstring",level:3}];function h(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["The Request class is the base class for all requests and responses that get sent through the StandardMem interface. Several basic request types are defined in the interface, including reads, writes, and flushes. In addition, a ",(0,t.jsx)(s.a,{href:"customreq",children:(0,t.jsx)(s.code,{children:"CustomReq"})})," and ",(0,t.jsx)(s.a,{href:"customresp",children:(0,t.jsx)(s.code,{children:"CustomResp"})})," type are provided. Implementations can use these to wrap custom request and response types that can also be passed through the interface alongside the basic request types."]}),"\n",(0,t.jsx)(s.p,{children:"It is not expected that every StandardMem implementation (and by extension, every memory system component) will handle all of the available request types. Some are specific to particular categories of memory component, for example, flushes may only apply to cache components. If a StandardMem implementation does not implement a handler for a particular type, passing that type to the interface will result in an error message indicating that the request type is not supported."}),"\n",(0,t.jsx)(s.h2,{id:"types",children:"Types"}),"\n",(0,t.jsx)(s.p,{children:"StandardMem::Request defines two types."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"id_t"})," (uint64_t) Every StandardMem::Request is assigned a unique (per-component) identifier. A request and response contain the same identifier to facilitate matching."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"flags_t"})," (uint32_t) The flags field is a 32-bit vector. The lower 16 bits are either in use or reserved for future use by the StandardMem::Request field. The upper 16 bits are available for memory and endpoint libraries to define their own flags. The ",(0,t.jsx)(s.code,{children:"F_RESERVED"})," flag marks the 16-bit boundary.","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Flag::F_NONCACHEABLE"})," (",(0,t.jsx)(s.code,{children:"0x1"}),") Indicates caches should be bypassed for this Request"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Flag::F_FAIL"})," (",(0,t.jsx)(s.code,{children:"0x2"}),") For accesses that can fail, this flag indicates that the access failed"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Flag::F_TRACE"})," (",(0,t.jsx)(s.code,{children:"0x4"}),") Set this flag to request that the memory system generate trace or debug output for this event"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Flag::F_RESERVED"})," (",(0,t.jsx)(s.code,{children:"0x10000"}),") Marks the 16-bit boundary between the lower 16 bits of the flag field that are reserved for StandardMem::Request use and the upper 16 that are available for implementations to define."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"request-handling",children:"Request handling"}),"\n",(0,t.jsxs)(s.p,{children:["Requests are handled by the interface using two visitor classes, ",(0,t.jsx)(s.code,{children:"RequestConverter"})," and ",(0,t.jsx)(s.code,{children:"RequestHandler"}),". The former is intended to be used by a StandardMem implementation to convert a StandardMem::Request into an SST::Event type used by the implementation internally. The latter is used by the interface to handle events coming in from the memory system according to type."]}),"\n",(0,t.jsx)(s.h2,{id:"functions",children:"Functions"}),"\n",(0,t.jsxs)(s.p,{children:["These functions are provided by the base ",(0,t.jsx)(s.code,{children:"StandardMem::Request"})," class and available to all child classes. The following functions must be defined by all child classes."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"makeResponse"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"needsResponse"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"convert"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"handle"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"getString"})}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"getid",children:"getID"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"id_t getID();\n"})}),"\n",(0,t.jsx)(s.p,{children:"Returns the request's identifier. A request and corresponding response will share an identifier."}),"\n",(0,t.jsx)(s.h3,{id:"makeresponse",children:"makeResponse"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"virtual Request* makeResponse() =0;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["This function must be implemented by all ",(0,t.jsx)(s.code,{children:"Request"})," classes. Interfaces and endpoints can call this function to generate an appropriate response type if the ",(0,t.jsx)(s.code,{children:"Request"})," is the request part of a request-response pair. Otherwise, it should return ",(0,t.jsx)(s.code,{children:"nullptr"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"needsresponse",children:"needsResponse"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"virtual bool needsResponse() =0;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["All ",(0,t.jsx)(s.code,{children:"Request"})," classes must implement this function. It should return ",(0,t.jsx)(s.code,{children:"true"})," if a response is expected for the ",(0,t.jsx)(s.code,{children:"Request"})," type."]}),"\n",(0,t.jsx)(s.h3,{id:"convert",children:"convert"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"virtual SST::Event* convert(RequestConverter* converter) = 0;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["All ",(0,t.jsx)(s.code,{children:"Request"})," classes must implement this function. It should return an event generated by called ",(0,t.jsx)(s.code,{children:"convert"})," on the ",(0,t.jsx)(s.code,{children:"converter"})," visitor class."]}),"\n",(0,t.jsx)(s.h3,{id:"handle",children:"handle"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"virtual void handle(RequestHandler* handler) =0;\n"})}),"\n",(0,t.jsxs)(s.p,{children:["All ",(0,t.jsx)(s.code,{children:"Request"})," classes must implement this function. It should call ",(0,t.jsx)(s.code,{children:"handle"})," on the handler passed into the function."]}),"\n",(0,t.jsx)(s.h3,{id:"getstring",children:"getString"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"virtual std::string getString() =0;\n"})}),"\n",(0,t.jsx)(s.p,{children:"This function returns a string representation of the class for debug or informational purposes."}),"\n",(0,t.jsx)(s.h3,{id:"setnoncacheable",children:"setNoncacheable"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void setNoncacheable();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Calling this function sets the ",(0,t.jsx)(s.code,{children:"F_NONCACHEABLE"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),", indicating that the ",(0,t.jsx)(s.code,{children:"Request"})," is not intended to be cached."]}),"\n",(0,t.jsx)(s.h3,{id:"unsetnoncacheable",children:"unsetNoncacheable"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void unsetNoncacheable();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Clears the ",(0,t.jsx)(s.code,{children:"F_NONCACHEABLE"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"getnoncacheable",children:"getNoncacheable"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"bool getNoncacheable();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns whether the ",(0,t.jsx)(s.code,{children:"F_NONCACHEABLE"})," flag has been set (",(0,t.jsx)(s.code,{children:"true"}),") or not (",(0,t.jsx)(s.code,{children:"false"}),")."]}),"\n",(0,t.jsx)(s.h3,{id:"setsuccess",children:"setSuccess"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void setSuccess();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Calling this function removes the ",(0,t.jsx)(s.code,{children:"F_FAIL"})," flag from the ",(0,t.jsx)(s.code,{children:"Request"}),", indicating that the ",(0,t.jsx)(s.code,{children:"Request"})," was successful. It is not necessary to call this function on unconditional requests."]}),"\n",(0,t.jsx)(s.h3,{id:"unsetsuccess",children:"unsetSuccess"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void unsetSuccess();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Set the ",(0,t.jsx)(s.code,{children:"F_FAIL"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),", indicating that the request failed."]}),"\n",(0,t.jsx)(s.h3,{id:"getsuccess",children:"getSuccess"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"bool getSuccess();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns whether the request was successful by returning the status of the ",(0,t.jsx)(s.code,{children:"F_FAIL"})," flag. Returns ",(0,t.jsx)(s.code,{children:"true"})," if the request succeeded (",(0,t.jsx)(s.code,{children:"F_FAIL"})," not set) or ",(0,t.jsx)(s.code,{children:"false"})," if it failed (",(0,t.jsx)(s.code,{children:"F_FAIL"})," is set)."]}),"\n",(0,t.jsx)(s.h3,{id:"setfail",children:"setFail"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void setFail();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Set the ",(0,t.jsx)(s.code,{children:"F_FAIL"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),", indicating that the request failed."]}),"\n",(0,t.jsx)(s.h3,{id:"unsetfail",children:"unsetFail"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void unsetFail();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Unset the ",(0,t.jsx)(s.code,{children:"F_FAIL"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),", indicating that the request did not fail."]}),"\n",(0,t.jsx)(s.h3,{id:"getfail",children:"getFail"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"bool getFail();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns whether the request failed by returning the status of the ",(0,t.jsx)(s.code,{children:"F_FAIL"})," flag. Returns ",(0,t.jsx)(s.code,{children:"true"})," if the request failed (",(0,t.jsx)(s.code,{children:"F_FAIL"})," is set) or ",(0,t.jsx)(s.code,{children:"false"})," if it did not fail (",(0,t.jsx)(s.code,{children:"F_FAIL"})," is not set)."]}),"\n",(0,t.jsx)(s.h3,{id:"settrace",children:"setTrace"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void setTrace();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Sets the ",(0,t.jsx)(s.code,{children:"F_TRACE"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),". This indicates that any debug and/or tracing should include this ",(0,t.jsx)(s.code,{children:"Request"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"unsettrace",children:"unsetTrace"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void unsetTrace();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Clears the ",(0,t.jsx)(s.code,{children:"F_TRACE"})," flag on the ",(0,t.jsx)(s.code,{children:"Request"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"gettrace",children:"getTrace"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"bool getTrace();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns whether the ",(0,t.jsx)(s.code,{children:"F_TRACE"})," flag has been set (",(0,t.jsx)(s.code,{children:"true"}),") or not (",(0,t.jsx)(s.code,{children:"false"}),")."]}),"\n",(0,t.jsx)(s.h3,{id:"setflag",children:"setFlag"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void setFlag(flags_t flag);\nvoid setFlag(Flag flag);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Sets the specified flag(s) to the ",(0,t.jsx)(s.code,{children:"Request"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"unsetflag",children:"unsetFlag"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void unsetFlag(flags_t flag);\nvoid unsetFlag(Flag flag);\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Clears the specified flag(s) on the ",(0,t.jsx)(s.code,{children:"Request"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"getflag",children:"getFlag"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"bool getFlag(flags_t flag);\nbool getFlag(Flag flag);\n"})}),"\n",(0,t.jsx)(s.p,{children:"Returns whether the specified flag(s) are set."}),"\n",(0,t.jsx)(s.h3,{id:"clearallflags",children:"clearAllFlags"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"void clearAllFlags();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Resets the Request's ",(0,t.jsx)(s.code,{children:"flags"})," field to zero (no flags set)."]}),"\n",(0,t.jsx)(s.h3,{id:"getallflags",children:"getAllFlags"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"flags_t getAllFlags();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Return the value of the Request's ",(0,t.jsx)(s.code,{children:"flags"})," field."]}),"\n",(0,t.jsx)(s.h3,{id:"getflagstring",children:"getFlagString"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-cpp",children:"std::string getFlagString();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Returns a comma separated list (as a string) of the flags set on the request. Built in flags are listed by name (e.g., ",(0,t.jsx)(s.code,{children:"F_<FLAG>"}),"). Other flags are returned as ",(0,t.jsx)(s.code,{children:"F_<NUM>"})," where ",(0,t.jsx)(s.code,{children:"NUM"})," is the bit index of the set flag."]})]})}function o(e={}){const{wrapper:s}={...(0,l.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>i,a:()=>c});var t=n(67294);const l={},a=t.createContext(l);function c(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:c(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);