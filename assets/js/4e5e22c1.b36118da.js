"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[72668],{2821:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"elements/ariel/intro","title":"ariel","description":"The ariel library models a multicore CPU using a dynamic application trace. The CPU models memory accesses in detail and non-memory accesses as a single cycle operation. Instruction dependencies are not tracked. The ariel library divides the simulation into two parts: a frontend that provides a trace, and a CPU simulation model that consumes the trace and provides the modeling itself. The framework includes frontends for Pin and PEBIL. Both support dynamic trace generation but Pin dynamically instruments the running application while PEBIL statically instruments it. PEBIL supports sampling which can improve simulation time. Running applications may use threads and/or MPI. Ariel supports memory models that use the StandardMem interface.","source":"@site/../docs/elements/ariel/intro.md","sourceDirName":"elements/ariel","slug":"/elements/ariel/intro","permalink":"/sst-docs/docs/elements/ariel/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/ariel/intro.md","tags":[],"version":"current","lastUpdatedBy":"grvosku","lastUpdatedAt":1762293106000,"frontMatter":{"title":"ariel"},"sidebar":"elements","previous":{"title":"Overview","permalink":"/sst-docs/docs/elements/intro"},"next":{"title":"balar","permalink":"/sst-docs/docs/elements/balar/intro"}}');var i=t(74848),r=t(28453);const a={title:"ariel"},o=void 0,l={},d=[{value:"Required dependencies",id:"required-dependencies",level:3},{value:"Optional dependencies",id:"optional-dependencies",level:3}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"ariel"})," library models a multicore CPU using a dynamic application trace. The CPU models memory accesses in detail and non-memory accesses as a single cycle operation. Instruction dependencies are not tracked. The ariel library divides the simulation into two parts: a frontend that provides a trace, and a CPU simulation model that consumes the trace and provides the modeling itself. The framework includes frontends for Pin and PEBIL. Both support dynamic trace generation but Pin dynamically instruments the running application while PEBIL statically instruments it. PEBIL supports sampling which can improve simulation time. Running applications may use threads and/or MPI. Ariel supports memory models that use the ",(0,i.jsx)(n.a,{href:"/sst-docs/docs/core/iface/StandardMem/class",children:"StandardMem"})," interface."]}),"\n",(0,i.jsx)(n.admonition,{title:"At a Glance",type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Source Code:"})," ",(0,i.jsx)(n.a,{href:"https://github.com/sstsimulator/sst-elements/tree/master/src/sst/elements/ariel",children:"sst-elements/.../ariel"})," \xa0",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"SST Name:"})," ",(0,i.jsx)(n.code,{children:"ariel"})," \xa0",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Maturity Level:"})," Mature (3) \xa0",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Development Path:"})," Active \xa0",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Last Released:"})," SST 15.1"]})}),"\n",(0,i.jsx)(n.h3,{id:"required-dependencies",children:"Required dependencies"}),"\n",(0,i.jsx)(n.p,{children:"Ariel requires a binary instrumentation tool to trace a running process. Either of these will work with the built-in tracers."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pin"})," Required for the built-in Pintool tracer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PEBIL"})," Required for the built-in PEBIL tracer."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"optional-dependencies",children:"Optional dependencies"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"zlib"})," Enables generating a compressed execution trace"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);